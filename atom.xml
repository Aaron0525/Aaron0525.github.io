<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>途中人的博客</title>
  <subtitle>IT技术分享！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://upyang.com/"/>
  <updated>2017-09-13T09:07:57.286Z</updated>
  <id>http://upyang.com/</id>
  
  <author>
    <name>途中人</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BFC布局理解</title>
    <link href="http://upyang.com/2017/09/13/BFC/"/>
    <id>http://upyang.com/2017/09/13/BFC/</id>
    <published>2017-09-13T07:40:45.000Z</published>
    <updated>2017-09-13T09:07:57.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BFC是什么？"><a href="#BFC是什么？" class="headerlink" title="BFC是什么？"></a>BFC是什么？</h2><p>在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。</p>
<h3 id="Box-CSS布局的基本单位"><a href="#Box-CSS布局的基本单位" class="headerlink" title="Box: CSS布局的基本单位"></a>Box: CSS布局的基本单位</h3><p>　　Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。</p>
<ul>
<li>block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context;</li>
<li>inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context;</li>
</ul>
<h3 id="Formatting-context"><a href="#Formatting-context" class="headerlink" title="Formatting context"></a>Formatting context</h3><p>　　Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。<br>　　CSS2.1 中只有 BFC 和 IFC, CSS3 中还增加了 GFC 和 FFC。</p>
<h3 id="BFC定义"><a href="#BFC定义" class="headerlink" title="BFC定义"></a>BFC定义</h3><p>　　BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>
<h3 id="BFC约束规则"><a href="#BFC约束规则" class="headerlink" title="BFC约束规则"></a>BFC约束规则</h3><p>1.内部的BOX会在垂直方向上一个接一个的放置;<br>2.垂直方向上的距离有margin决定;（完整的说法是：属于同一个BFC的俩个相邻的BOX的margin会发生重叠，与方向无关。）<br>3.每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此;（这说明BFC中的子元素不会超出它的包含块，而position为absolute的元素可以超出它的包含块边界。）<br>4.BFC的区域不会与float的元素区域重叠;<br>5.计算BFC的高度时，浮动子元素也参与计算;<br>6.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然;</p>
<h2 id="哪些情况会生成BFC？"><a href="#哪些情况会生成BFC？" class="headerlink" title="哪些情况会生成BFC？"></a>哪些情况会生成BFC？</h2><p>既然上文提到BFC是一块渲染区域，那这块渲染区域到底在哪，它又是有多大，这些由生成BFC的元素决定，CSS2.1中规定满足下列CSS声明之一的元素便会生成BFC。</p>
<ul>
<li>float的值不为none;</li>
<li>overflow的值不为visible;</li>
<li>display的值为inline-block、table-cell、table-caption、flex、inline-flex;</li>
<li>position的值为absolute或fixed;</li>
</ul>
<h2 id="BFC布局的应用"><a href="#BFC布局的应用" class="headerlink" title="BFC布局的应用"></a>BFC布局的应用</h2><h3 id="多栏布局的一种实现"><a href="#多栏布局的一种实现" class="headerlink" title="多栏布局的一种实现"></a>多栏布局的一种实现</h3><p>上文提到的一条规则：与浮动元素相邻的已生成BFC的元素不能与浮动元素互相覆盖。利用该特性可以作为多栏布局的一种实现方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">.left &#123;</div><div class="line">    float: left;</div><div class="line">    width: 200px;</div><div class="line">    background: red;</div><div class="line">&#125;</div><div class="line">.center &#123;</div><div class="line">    height: 150px;</div><div class="line">    overflow: hidden;</div><div class="line">    background: pink;</div><div class="line">&#125;</div><div class="line">.right &#123;</div><div class="line">    width: 200px;</div><div class="line">    float: right;</div><div class="line">    background: red;</div><div class="line">&#125;</div><div class="line">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;center&quot;&gt;&lt;/div&gt;  //center需要放在最后</div></pre></td></tr></table></figure></p>
<h3 id="防止margin重叠"><a href="#防止margin重叠" class="headerlink" title="防止margin重叠"></a>防止margin重叠</h3><ul>
<li>同一个BFC中俩个相邻的box才会发生重叠与方向无关，不过由于上文提到的第一条限制，我们甚少看到水平方向的margin重叠。这在IE这中是个特例，IE可以设置write-mode。</li>
<li><p>要阻止margin重叠，只要将俩个元素别放在一个BFC中即可（可以用上文提到的方式让相邻元素其中一个生成BFC）。阻止俩个相邻元素的重叠看起来没有意义，主要用于嵌套元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">p &#123;</div><div class="line">    color: #f55;</div><div class="line">    background: #fcc;</div><div class="line">    width: 200px;</div><div class="line">    line-height: 100px;</div><div class="line">    text-align:center;</div><div class="line">    margin: 100px;</div><div class="line">&#125;</div><div class="line">&lt;p&gt;Hello&lt;/p&gt;</div><div class="line">&lt;p&gt;world&lt;/p&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>垂直方向上的距离有margin决定;（完整的说法是：属于同一个BFC的俩个相邻的BOX的margin会发生重叠，与方向无关。）所以两个p之间的距离为100px，发送了margin重叠。</p>
</li>
</ul>
<p>我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.wrap &#123;</div><div class="line">    overflow: hidden;</div><div class="line">&#125;</div><div class="line">p &#123;</div><div class="line">    color: #f55;</div><div class="line">    background: #fcc;</div><div class="line">    width: 200px;</div><div class="line">    line-height: 100px;</div><div class="line">    text-align:center;</div><div class="line">    margin: 100px;</div><div class="line">&#125;</div><div class="line">&lt;div class=&quot;wrap&quot;&gt;</div><div class="line">    &lt;p&gt;Hello&lt;/p&gt;</div><div class="line">    &lt;p&gt;world&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h3 id="清除内部浮动"><a href="#清除内部浮动" class="headerlink" title="清除内部浮动"></a>清除内部浮动</h3><ul>
<li>使得父元素包含子元素，常见的方式是为父元素设置overflow：hidden或者浮动父元素。根本原因在于创建BFC的元素，子浮动元素也会参与其高度计算，即不会产生高度塌陷问题。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">.parent &#123;</div><div class="line">    border: 5px solid #red;</div><div class="line">    width: 300px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.child &#123;</div><div class="line">    float: left;</div><div class="line">    width: 100px;</div><div class="line">    height: 100px;</div><div class="line">    border: 5px solid yellow;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;parent&quot;&gt;</div><div class="line">    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</div><div class="line">    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>有经验的一眼看去就会知道父元素会出现高度塌陷的问题，这是由于子元素浮动后脱离文档流，父元素无法被子元素撑开而造成的。</p>
<ul>
<li>根据BEC规则第五条：计算BFC的高度时，浮动子元素也参与计算。<br>我们可以让parent父元素去触发BFC，那么parent在计算高度的时候，child也会参与计算,而解决问题。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.parent &#123;overflow: hidden;&#125;</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;BFC是什么？&quot;&gt;&lt;a href=&quot;#BFC是什么？&quot; class=&quot;headerlink&quot; title=&quot;BFC是什么？&quot;&gt;&lt;/a&gt;BFC是什么？&lt;/h2&gt;&lt;p&gt;在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="BFC" scheme="http://upyang.com/tags/BFC/"/>
    
      <category term="CSS" scheme="http://upyang.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>前端节流</title>
    <link href="http://upyang.com/2017/09/07/%E5%89%8D%E7%AB%AF%E8%8A%82%E6%B5%81/"/>
    <id>http://upyang.com/2017/09/07/前端节流/</id>
    <published>2017-09-07T12:19:17.000Z</published>
    <updated>2017-09-09T14:04:51.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是函数节流？"><a href="#什么是函数节流？" class="headerlink" title="什么是函数节流？"></a>什么是函数节流？</h2><p>介绍前，先说下背景。前端开发中，浏览器某些计算和处理比其他的昂贵很多。例如，DOM操作比起非DOM交互需要更多的内存和CPU时间。连续尝试进行过多的DOM相关操作可能会导致浏览器挂起，有时甚至崩溃。尤其在IE中使用onresize事件处理程序的时候容易发生，当调整浏览器大小的时候，该shij9ian会连续触发。在onresize事件处理程序内部如果尝试进行DOM操作，其高频率的更改可能会让浏览器崩溃。为了绕开这个问题，可以使用定时器对该函数进行节流。</p>
<h2 id="函数节流的原理"><a href="#函数节流的原理" class="headerlink" title="函数节流的原理"></a>函数节流的原理</h2><p>函数节流背后的基本思想是指，某些代码不可以在没有间断的情况连续重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行。<br>以下是该模式的基本形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var processor = &#123;</div><div class="line">    timeoutId: null,</div><div class="line"></div><div class="line">    //实际进行处理的方法</div><div class="line">    performProcessing: function() &#123;</div><div class="line">        //实际执行的代码</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    //初始处理调用的方法</div><div class="line">    process: function() &#123;</div><div class="line">        clearTimeout(this.timeoutId);</div><div class="line"></div><div class="line">        var that = this;</div><div class="line">        this.timeoutId = setTimeout(function() &#123;</div><div class="line">                that.performProcessing();</div><div class="line">            &#125;,100);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">//尝试开始执行</div><div class="line">processor.process();</div></pre></td></tr></table></figure></p>
<p>在这段代码中，创建了一个叫做processor对象。这个对象还有2个方法：process()和performProcessing()。前者是初始化任何处理所必须调用的，后者则实际进行应完成的处理。当调用了process()，第一步是清除存好的timeoutId,来组织之前的调用被执行。然后，创建一个新的定时器调用performProcessing()。由于setTimeout()中用到的函数的环境总是window,所以有必要保存this的引用一方便以后使用。<br>时间间隔设为了100ms，折表示最后一次调用process()之后至少100ms后才会调用performProcessing()。所以如果100ms之内调用了process()共20次，performProcessing()仍只会被调用一次。</p>
<h2 id="模式简化"><a href="#模式简化" class="headerlink" title="模式简化"></a>模式简化</h2><p>这个模式可以使用throttle()函数来简化，这个函数可以自动进行定时器的设置和清除，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function throttle(method,context) &#123;</div><div class="line">    clearTimeout(method.tId);</div><div class="line">    method.tId = setTimeout(function() &#123;</div><div class="line">        method.call(context);</div><div class="line">    &#125;,100)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>throttle()函数接受两个参数：要执行的函数以及在哪个作用域中执行。定时器ID是存储在函数的tId属性中的，第一次把方法传递给throttle()的时候，这个属性可能并不存在。接下来，创建一个新的定时器，并将其ID存储在方法的tId属性中。<br>定时器代码使用call()来确保方法在适当的环境中执行。如果没有给出第二个参数，那么就在全局作用域内执行该方法。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>前面提到过，节流在resize事件中是最常用的。例如，假设有一个<code>&lt;div&gt;</code>元素需要保持它的高度适中等同于宽度，实现这一功能的javascript代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">window.onload = function() &#123;</div><div class="line">    var oBox = document.getElementById(&quot;mydiv&quot;);</div><div class="line">    oBox.style.height = oBox.offsetWidth+&apos;px&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段简短的代码可能就会造成浏览器运行缓慢。首先，需要计算offsetWidth属性，如果这个元素或者页面上有非常复杂的CSS样式，那么这个过程会很复杂。其次，设置某个元素的高度需要对页面进行回流来令改动生效，如果页面有很多元素同时应用了相当数量的CSS的话，这又需要很多计算。</p>
<ul>
<li>使用throttle()函数，如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function resizeDiv() &#123;</div><div class="line">    var oBox = document.getElementById(&quot;mydiv&quot;);</div><div class="line">    oBox.style.height = oBox.offsetWidth+&apos;px&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">window.onresize = function () &#123;</div><div class="line">    throttle(resizeDiv);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数节流的目的是为了优化性能，理论上只要代码是周期性执行的，都应该使用节流，但是不能控制请求执行的速率。这里展示的throttle()函数用了100ms作为间隔，可以根据需要来调整它。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是函数节流？&quot;&gt;&lt;a href=&quot;#什么是函数节流？&quot; class=&quot;headerlink&quot; title=&quot;什么是函数节流？&quot;&gt;&lt;/a&gt;什么是函数节流？&lt;/h2&gt;&lt;p&gt;介绍前，先说下背景。前端开发中，浏览器某些计算和处理比其他的昂贵很多。例如，DOM操作比起非
    
    </summary>
    
    
      <category term="javascript" scheme="http://upyang.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构</title>
    <link href="http://upyang.com/2017/08/26/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://upyang.com/2017/08/26/算法与数据结构/</id>
    <published>2017-08-26T12:01:51.000Z</published>
    <updated>2017-09-05T13:39:00.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js排序算法"><a href="#js排序算法" class="headerlink" title="js排序算法"></a>js排序算法</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li>原理：从数组第二个值开始，依次将后续的数值经过比较插入带前面已排好序的有序表中。</li>
<li>平均时间复杂度：O(n^2)</li>
<li>最好情况： O(n),数组从小到大已经排好</li>
<li>最坏情况： O(n^2),数组是从大到小的顺序</li>
<li>稳定性： 稳定<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function InsertSort(arr) &#123;</div><div class="line">        var result = arr.slice(0); //复制一个arr数组的副本</div><div class="line"></div><div class="line">        //从数组的第二个元素开始比较，所以从i=1开始</div><div class="line">        for(let i=1;i&lt;=arr.length;i++) &#123;</div><div class="line">            var temp = result[i];</div><div class="line">            var j = i-1;</div><div class="line">            while(j &gt;= 0 &amp;&amp; temp&lt;result[j]) &#123;</div><div class="line">                result[j+1] =result[j];</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            result[j+1]=temp;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul>
<li>原理：从数组中取一个值为基准值，并将剩下的值与之比较，小于基准值的放到左边，大于基准值的放到右边，并再次对左右两边进行快速排序，直至左右两边只剩一个元素。</li>
<li>平均时间复杂度：O(nlogn)</li>
<li>最好情况： O(nlogn)</li>
<li>最坏情况： O(n^2) 当选择的基准值为最大值或最小值时</li>
<li>稳定性： 不稳定<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function QuickSort(arr) &#123;</div><div class="line">        var len = arr.length;</div><div class="line">        if(len&lt;+1) &#123;</div><div class="line">            return arr;</div><div class="line">        &#125;</div><div class="line">        //向下取整，取出数组中间的值作为比较的对象</div><div class="line">        var index = Math.floor(len/2);</div><div class="line">        var temp = arr.splice(index,1)[0]; //删除刚得到的比较对象，取到新数组的第一个元素</div><div class="line">        var left=[];</div><div class="line">        var right=[];</div><div class="line">        for(let i=0;i&lt;len-1;i++) &#123;</div><div class="line">            if(arr[i]&gt;=temp) &#123;</div><div class="line">                right.push(arr[i]);</div><div class="line">            &#125;else&#123;</div><div class="line">                left.push(arr[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return QuickSort(left).concat([temp],QuickSort(right)); //递归并合并数组</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li>原理：对数组进行遍历，相邻元素根据大小进行交换，每次遍历将最小值推至最前方，然后对剩下的值再次进行比较。</li>
<li>平均时间复杂度：O(n^2)</li>
<li>最好情况： O(n)</li>
<li>最坏情况： O(n^2)</li>
<li>稳定性： 稳定<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function PopSort(arr) &#123;</div><div class="line">        var len = arr.length;</div><div class="line">        var result = arr.slice(0);//复制一个arr数组的副本</div><div class="line">        for(let i=0;i&lt;len;i++) &#123;</div><div class="line">            for(let j=len-1;j&gt;i;j--) &#123;</div><div class="line">                if(result[j] &lt; result[j-1]) &#123;</div><div class="line">                    let temp =result[j-1];</div><div class="line">                    result[j-1]=result[j];</div><div class="line">                    result[j]=temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul>
<li>原理：与冒泡排序类似，只不过选择排序不是通过相邻元素交换而将最小值“冒泡”到顶端，而是从数组第一个元素开始，与后面的的元素进行比较，如果后面的元素都比他大，则不需要交换，如果有比其小的，则两个值相互交换。</li>
<li>平均时间复杂度：O(n^2)</li>
<li>最好情况： O(n^2)</li>
<li>最坏情况： O(n^2)</li>
<li>稳定性： 稳定<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function SelectSort(arr) &#123;</div><div class="line">    var len = arr.length;</div><div class="line">    for(let i=0;i&lt;len;i++) &#123; //遍历数组的每一个值，并于其后的值比较找出最小值之后互换</div><div class="line">        let k=i;</div><div class="line">        for(let j=i+1;j&lt;len;j++) &#123;</div><div class="line">            if(arr[j]&lt;arr[k]) &#123;</div><div class="line">                k=j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if(k!=i) &#123;  //如果arr[i]已经是最小的则不需要互换</div><div class="line">            var temp=arr[k];</div><div class="line">            arr[k]=arr[i];</div><div class="line">            arr[i]=temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul>
<li>原理：基本思想是分治策略，先进行划分再进行合并，归并的含义是将两个或两个以上的有序表组合成一个新的有序表。</li>
<li>平均时间复杂度：O(nlogn)</li>
<li>最好情况： O(nlogn)</li>
<li>最坏情况： O(nlogn)</li>
<li>稳定性： 稳定<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function MergeSort(arr) &#123;</div><div class="line">        var len = arr.length;</div><div class="line">        if(len &lt; 2) &#123;</div><div class="line">            var index = Math.floor(len / 2);</div><div class="line">            left = arr.slice(0,index); //得到下标从0~index-1的数组</div><div class="line">            right = arr.slice(index);  //得到下标从index开始到末尾的数组</div><div class="line">            return merge(MergeSort(left) , MergeSort(right));  //里面采用递归</div><div class="line">        &#125;else &#123;</div><div class="line">            return arr;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    function merge(left , right) &#123;   //该函数与快排类似，但是仔细发现，每次left或者right都是要shift掉第一个元素，表示left或者right是会变化的，最后arr.concat，因为不知道left或者right其中一个哪个剩下元素，所以要将剩下的元素给加上</div><div class="line">        var arr = [];</div><div class="line">        while(left.length &amp;&amp; right.length) &#123;</div><div class="line">            if(left[0] &lt; right[0]) &#123;</div><div class="line">                arr.push(left.shift());</div><div class="line">            &#125;else &#123;</div><div class="line">                arr.push(right.shift())</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return arr.concat(left , right);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><ul>
<li>原理：基数排序只是针对于数字，思想就是将我们需要待排列的元素按照指定的进制将每一位排列，时间复杂度为：P(N+B)，注：其中P为待排列数字的最大位数，N为待排序列的长度，B为进制数<br>首先我们来看利用LSD(次位优先)进行基数排序。</li>
<li>平均时间复杂度：O(n*k)</li>
<li>最好情况： O(n*k)</li>
<li>最坏情况： O(n*k)</li>
<li>稳定性： 稳定<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function RadixSort(arr,maxDigit) &#123; //maxDigit位数组元素的最大位数</div><div class="line">    var mod = 10;</div><div class="line">    var dev = 1;</div><div class="line">    var counter = [];</div><div class="line">    for(let i=0;i&lt;maxDigit;i++,dev *= 10,mod *=10) &#123;</div><div class="line">        for(let j=0;j&lt;arr.length;j++) &#123;</div><div class="line">            var bucket = parseInt((arr[j]%mod)/dev);</div><div class="line">            if(counter[bucket]==null) &#123;</div><div class="line">                counter[bucket] = [];</div><div class="line">            &#125;</div><div class="line">            counter[bucket].push(arr[j]);</div><div class="line">        &#125;</div><div class="line">        var pos = 0;</div><div class="line">        for(let j=0;j&lt;counter.length;j++) &#123;</div><div class="line">            var value = null;</div><div class="line">            if(counter[j]!=null) &#123;</div><div class="line">                while((value=counter[j].shift()) != null) &#123;</div><div class="line">                    arr[pos++] = value;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul>
<li>原理：1.建堆。堆实质上是完全二叉树，必须满足：树中任一非叶子结点的关键字均不大于（或不小于）其左右孩子（若存在）结点的关键字。堆分为：大根堆和小根堆，升序排序采用大根堆，降序排序采用小根堆。如果是大根堆，则通过调整函数将值最大的节点调整至堆根。2.将堆根保存于尾部，并对剩余序列调用调整函数，调整完成后，再将最大跟保存于尾部-1（-1，-2，…，-i），再对剩余序列进行调整，反复进行该过程，直至排序完成。</li>
<li>平均时间复杂度：O(n*log2n)</li>
<li>最好情况： O(n*log2n)</li>
<li>最坏情况： O(n*log2n)</li>
<li>稳定性： 不稳定<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">function headAdjust(elements, pos, len)&#123;</div><div class="line">  //将当前节点值进行保存</div><div class="line">  var swap = elements[pos];</div><div class="line"></div><div class="line">  //定位到当前节点的左边的子节点</div><div class="line">  var child = pos * 2 + 1;</div><div class="line"></div><div class="line">  //递归，直至没有子节点为止</div><div class="line">  while(child &lt; len)&#123;</div><div class="line">    //如果当前节点有右边的子节点，并且右子节点较大的场合，采用右子节点</div><div class="line">    //和当前节点进行比较</div><div class="line">    if(child + 1 &lt; len &amp;&amp; elements[child] &lt; elements[child + 1])&#123;</div><div class="line">      child += 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //比较当前节点和最大的子节点，小于则进行值交换，交换后将当前节点定位</div><div class="line">    //于子节点上</div><div class="line">    if(elements[pos] &lt; elements[child])&#123;</div><div class="line">      elements[pos] = elements[child];</div><div class="line">      pos = child;</div><div class="line">      child = pos * 2 + 1;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    elements[pos] = swap;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//构建堆</div><div class="line">function buildHeap(elements)&#123;</div><div class="line">  //从最后一个拥有子节点的节点开始，将该节点连同其子节点进行比较，</div><div class="line">  //将最大的数交换与该节点,交换后，再依次向前节点进行相同交换处理，</div><div class="line">  //直至构建出大顶堆（升序为大顶，降序为小顶）</div><div class="line">  for(var i=elements.length/2; i&gt;=0; i--)&#123;</div><div class="line">    headAdjust(elements, i, elements.length);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function sort(elements)&#123;</div><div class="line">  //构建堆</div><div class="line">  buildHeap(elements);</div><div class="line"></div><div class="line">  //从数列的尾部开始进行调整</div><div class="line">  for(var i=elements.length-1; i&gt;0; i--)&#123;</div><div class="line">    //堆顶永远是最大元素，故，将堆顶和尾部元素交换，将</div><div class="line">    //最大元素保存于尾部，并且不参与后面的调整</div><div class="line">    var swap = elements[i];</div><div class="line">    elements[i] = elements[0];</div><div class="line">    elements[0] = swap;</div><div class="line"></div><div class="line">    //进行调整，将最大）元素调整至堆顶</div><div class="line">    headAdjust(elements, 0, i);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var elements = [3, 1, 5, 7, 2, 4, 9, 6, 10, 8];</div><div class="line">console.log(&apos;before: &apos; + elements);</div><div class="line">sort(elements);</div><div class="line">console.log(&apos; after: &apos; + elements);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>原理：findInArr函数，查找一个数在当前数组中是否存在，若存在返回true,找完所有没有找到，返回false，这个数就是我们要操作的那个数组。select，循环数组，并调用findInArr方法 查找当前arr[i]在arr2中是否存在，如果返回false 那么就把当前这个数 arr[i] ，push到新的数组 arr2中，最后return arr2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function findInArr(n,arr) &#123;</div><div class="line">    for(let i=0;i&lt;arr.length;i++) &#123;</div><div class="line">        if(n == arr[i]) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line">function select(arr) &#123;</div><div class="line">    var arr2 = [];</div><div class="line">    for(let i=0;i&lt;arr.length;i++) &#123;</div><div class="line">        if(!findInArr(arr[i],arr2)) &#123;</div><div class="line">            arr2.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return arr2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>原理：利用json特性，创建一个空的json，通过对key的检索，—&gt; !json[arr[i]],取反说明不存在<br>这样我们可以对其进行赋值，json[arr[i]] = true; 对于赋什么值，随意，保证它的键值对就行<br>并且把当前这个数push 或者其他方式都行 ，总是添加到新数组 arr2中，最后return arr2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Jsonselect(arr) &#123;</div><div class="line">    var json =&#123;&#125;;</div><div class="line">    var arr2 = [];</div><div class="line">    for(let i=0;i&lt;arr.length;i++) &#123;</div><div class="line">        if(!json[arr[i]]) &#123;</div><div class="line">            json[arr[i]] = true;</div><div class="line">            arr2.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return arr2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的遍历指的是按照某种顺序，依次访问二叉树的每个节点，有且访问一次。<br>二叉树的遍历有以下三种:<br>（1）前序遍历，从根节点，到左子树，再到右子树，简称根左右。<br>（2）中序遍历，从左节点，到根节点，再到右子树，简称左根右。<br>（3）后序遍历，从左子树，到右子树，再到根节点，简称左右根。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Document&lt;/title&gt;</div><div class="line">    &lt;style&gt;</div><div class="line">        *&#123;</div><div class="line">            margin: 0;</div><div class="line">            padding: 0;</div><div class="line">        &#125;</div><div class="line">        .wrap&#123;</div><div class="line">            display: flex;</div><div class="line">            border:1px solid #000;</div><div class="line">            width: 600px;</div><div class="line">            margin:0 auto;</div><div class="line">            height: 150px;</div><div class="line">            align-items: center;</div><div class="line">            justify-content:center;</div><div class="line">        &#125;</div><div class="line">        .wrap div&#123;</div><div class="line">            display: flex;</div><div class="line">            height: 70%;</div><div class="line">            width: 44%;</div><div class="line">            margin:0 3%;</div><div class="line">            border:1px solid #000;</div><div class="line">            justify-content:center;</div><div class="line">            align-items: center;</div><div class="line">            background: #fff;</div><div class="line">        &#125;</div><div class="line">        .btn-wrap&#123;</div><div class="line">            text-align: center;</div><div class="line">            padding-top: 20px;</div><div class="line">        &#125;</div><div class="line">        .btn-wrap button&#123;</div><div class="line">            display: inline-block;</div><div class="line">            padding:4px 10px;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div class=&quot;wrap&quot;&gt;</div><div class="line">        &lt;div&gt;</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;div&gt;</div><div class="line">                    &lt;div&gt;&lt;/div&gt;</div><div class="line">                    &lt;div&gt;&lt;/div&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">                &lt;div&gt;</div><div class="line">                    &lt;div&gt;&lt;/div&gt;</div><div class="line">                    &lt;div&gt;&lt;/div&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;div&gt;</div><div class="line">                    &lt;div&gt;&lt;/div&gt;</div><div class="line">                    &lt;div&gt;&lt;/div&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">                &lt;div&gt;</div><div class="line">                    &lt;div&gt;&lt;/div&gt;</div><div class="line">                    &lt;div&gt;&lt;/div&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;div&gt;</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;div&gt;</div><div class="line">                    &lt;div&gt;&lt;/div&gt;</div><div class="line">                    &lt;div&gt;&lt;/div&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">                &lt;div&gt;</div><div class="line">                    &lt;div&gt;&lt;/div&gt;</div><div class="line">                    &lt;div&gt;&lt;/div&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;div&gt;</div><div class="line">                    &lt;div&gt;&lt;/div&gt;</div><div class="line">                    &lt;div&gt;&lt;/div&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">                &lt;div&gt;</div><div class="line">                    &lt;div&gt;&lt;/div&gt;</div><div class="line">                    &lt;div&gt;&lt;/div&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;div class=&quot;btn-wrap&quot;&gt;</div><div class="line">        &lt;button&gt;前序&lt;/button&gt;</div><div class="line">        &lt;button&gt;中序&lt;/button&gt;</div><div class="line">        &lt;button&gt;后序&lt;/button&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">        var wrap = document.querySelector(&quot;.wrap&quot;);</div><div class="line">        var btn_wrap = document.querySelector(&quot;.btn-wrap&quot;);</div><div class="line">        var btn1 = btn_wrap.querySelectorAll(&quot;button&quot;)[0];</div><div class="line">        var btn2 = btn_wrap.querySelectorAll(&quot;button&quot;)[1];</div><div class="line">        var btn3 = btn_wrap.querySelectorAll(&quot;button&quot;)[2];</div><div class="line">        var arr = [];</div><div class="line">        var last;</div><div class="line">        var toggle = false;</div><div class="line">        //给按钮绑定事件</div><div class="line">        btn1.onclick = function()&#123;</div><div class="line">            if(!toggle)&#123;</div><div class="line">                toggle = true;</div><div class="line">                reset();</div><div class="line">                preOrder(wrap);</div><div class="line">                showWay();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        btn2.onclick = function()&#123;</div><div class="line">            if(!toggle)&#123;</div><div class="line">                toggle = true;</div><div class="line">                reset();</div><div class="line">                inOrder(wrap);</div><div class="line">                showWay();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        btn3.onclick = function()&#123;</div><div class="line">            if(!toggle)&#123;</div><div class="line">                toggle = true;</div><div class="line">                reset();</div><div class="line">                postOrder(wrap);</div><div class="line">                showWay();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //二叉树的遍历的三种方式</div><div class="line">        //(1)前序遍历（DLR</div><div class="line">        function preOrder(node)&#123;</div><div class="line">            if(node)&#123;</div><div class="line">                arr.push(node);</div><div class="line">                preOrder(node.firstElementChild);</div><div class="line">                preOrder(node.lastElementChild);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //(2)中序遍历（LDR）</div><div class="line">        function inOrder(node)&#123;</div><div class="line">            if(node)&#123;</div><div class="line">                inOrder(node.firstElementChild);</div><div class="line">                arr.push(node);</div><div class="line">                inOrder(node.lastElementChild);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //(3)后序遍历（LRD）</div><div class="line">        function postOrder(node)&#123;</div><div class="line">            if(node)&#123;</div><div class="line">                postOrder(node.firstElementChild);</div><div class="line">                postOrder(node.lastElementChild);</div><div class="line">                arr.push(node);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //显示遍历的过程</div><div class="line">        function showWay()&#123;</div><div class="line">            for(var i=0; i&lt;arr.length; i++)&#123;</div><div class="line">                setTimeout(function(i)&#123;</div><div class="line">                    return function()&#123;</div><div class="line">                        if(i == arr.length-1)&#123;</div><div class="line">                            toggle = false;</div><div class="line">                        &#125;</div><div class="line">                        if(last)&#123;</div><div class="line">                            last.style.background = &quot;white&quot;;</div><div class="line">                        &#125;</div><div class="line">                        arr[i].style.background = &quot;red&quot;;</div><div class="line">                        last = arr[i];</div><div class="line">                    &#125;</div><div class="line">                &#125;(i),i*1000)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //初始化</div><div class="line">        function reset()&#123;</div><div class="line">            arr = [];</div><div class="line">            if(last)&#123;</div><div class="line">                last.style.background = &quot;white&quot;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为前端开发者而言，可能不会像后端开发那样遇到很多的算法和数据结构问题，但是不论是做前端、 服务端还是客户端， 任何一个程序员都会开始面对更加复杂的问题， 这个时候算法和数据结构知识就变得不可或缺，它是编程能力中很重要的一部分。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;js排序算法&quot;&gt;&lt;a href=&quot;#js排序算法&quot; class=&quot;headerlink&quot; title=&quot;js排序算法&quot;&gt;&lt;/a&gt;js排序算法&lt;/h2&gt;&lt;h3 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插
    
    </summary>
    
    
      <category term="javascript" scheme="http://upyang.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>canvas倒计时效果</title>
    <link href="http://upyang.com/2017/08/22/canvas/"/>
    <id>http://upyang.com/2017/08/22/canvas/</id>
    <published>2017-08-22T09:49:26.000Z</published>
    <updated>2017-08-24T03:33:11.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Canvas-倒计时效果"><a href="#Canvas-倒计时效果" class="headerlink" title="Canvas-倒计时效果"></a>Canvas-倒计时效果</h2><p>👉 github：  <a href="https://github.com/Aaron0525/canvas" target="_blank" rel="external">https://github.com/Aaron0525/canvas</a></p>
<p>👉 演示地址:  <a href="http://www.upyang.com/canvas/" target="_blank" rel="external">http://www.upyang.com/canvas/</a></p>
<h2 id="Canvas概述"><a href="#Canvas概述" class="headerlink" title="Canvas概述"></a>Canvas概述</h2><p>Canvas API（画布）用于在网页实时生成图像，并且可以操作图像内容，canvas本身没有绘图能力，需要javascript脚本来执行绘图。</p>
<p>使用前，首先需要新建一个<code>&lt;canvas&gt;</code>网页元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;200&quot;&gt;</div><div class="line">  您的浏览器不支持canvas！</div><div class="line">&lt;/canvas&gt;</div></pre></td></tr></table></figure></p>
<p>上面代码中，如果浏览器不支持这个API，则就会显示<code>&lt;canvas&gt;</code>标签中间的文字——“您的浏览器不支持canvas！”。</p>
<p>每个canvas节点都有一个对应的context对象（上下文对象），Canvas API定义在这个context对象上面，所以需要获取这个对象，方法是使用getContext方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var canvas = document.getElementById(&apos;myCanvas&apos;);</div><div class="line"></div><div class="line">if (canvas.getContext) &#123;</div><div class="line">  var ctx = canvas.getContext(&apos;2d&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，getContext方法指定参数2d，表示该canvas节点用于生成2D图案（即平面图案）。如果参数是webgl，就表示用于生成3D图像（即立体图案），这部分实际上单独叫做WebGL API（本文不涉及）。</p>
<h2 id="绘图方法"><a href="#绘图方法" class="headerlink" title="绘图方法"></a>绘图方法</h2><p>canvas画布提供了一个用来作图的平面空间，该空间的每个点都有自己的坐标，x表示横坐标，y表示竖坐标。原点(0, 0)位于图像左上角，x轴的正向是原点向右，y轴的正向是原点向下。</p>
<h3 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h3><p>beginPath方法表示开始绘制路径，moveTo(x, y)方法设置线段的起点，lineTo(x, y)方法设置线段的终点，stroke方法用来给透明的线段着色。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ctx.beginPath(); // 开始路径绘制</div><div class="line">ctx.moveTo(20, 20); // 设置路径起点，坐标为(20,20)</div><div class="line">ctx.lineTo(200, 20); // 绘制一条到(200,20)的直线</div><div class="line">ctx.lineWidth = 1.0; // 设置线宽</div><div class="line">ctx.strokeStyle = &apos;#CC0000&apos;; // 设置线的颜色</div><div class="line">ctx.stroke(); // 进行线的着色，这时整条线才变得可见</div></pre></td></tr></table></figure></p>
<p>moveto和lineto方法可以多次使用。最后，还可以使用closePath方法，自动绘制一条当前点到起点的直线，形成一个封闭图形，省却使用一次lineto方法。</p>
<h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><p>fillRect(x, y, width, height)方法用来绘制矩形，它的四个参数分别为矩形左上角顶点的x坐标、y坐标，以及矩形的宽和高。fillStyle属性用来设置矩形的填充色。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ctx.fillStyle = &apos;yellow&apos;;</div><div class="line">ctx.fillRect(50, 50, 200, 100);</div></pre></td></tr></table></figure></p>
<p>strokeRect方法与fillRect类似，用来绘制空心矩形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctx.strokeRect(10,10,200,100);</div></pre></td></tr></table></figure></p>
<p>clearRect方法用来清除某个矩形区域的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctx.clearRect(100,50,50,50);</div></pre></td></tr></table></figure></p>
<h3 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h3><p>illText(string, x, y) 用来绘制文本，它的三个参数分别为文本内容、起点的x坐标、y坐标。使用之前，需用font设置字体、大小、样式（写法类似与CSS的font属性）。与此类似的还有strokeText方法，用来添加空心字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 设置字体</div><div class="line">ctx.font = &quot;Bold 20px Arial&quot;;</div><div class="line">// 设置对齐方式</div><div class="line">ctx.textAlign = &quot;left&quot;;</div><div class="line">// 设置填充颜色</div><div class="line">ctx.fillStyle = &quot;#008600&quot;;</div><div class="line">// 设置字体内容，以及在画布上的位置</div><div class="line">ctx.fillText(&quot;Hello!&quot;, 10, 50);</div><div class="line">// 绘制空心字</div><div class="line">ctx.strokeText(&quot;Hello!&quot;, 10, 100);</div></pre></td></tr></table></figure></p>
<p>fillText方法不支持文本断行，即所有文本出现在一行内。所以，如果要生成多行文本，只有调用多次fillText方法。</p>
<h3 id="绘制圆形和扇形"><a href="#绘制圆形和扇形" class="headerlink" title="绘制圆形和扇形"></a>绘制圆形和扇形</h3><p>arc方法用来绘制扇形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);</div></pre></td></tr></table></figure></p>
<p>arc方法的x和y参数是圆心坐标，radius是半径，startAngle和endAngle则是扇形的起始角度和终止角度（以弧度表示），anticlockwise表示做图时应该逆时针画（true）还是顺时针画（false）。</p>
<p>下面是如何绘制实心的圆形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ctx.beginPath();</div><div class="line">ctx.arc(60, 60, 50, 0, Math.PI*2, true);</div><div class="line">ctx.fillStyle = &quot;#000000&quot;;</div><div class="line">ctx.fill();</div></pre></td></tr></table></figure></p>
<p>绘制空心圆形的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ctx.beginPath();</div><div class="line">ctx.arc(60, 60, 50, 0, Math.PI*2, true);</div><div class="line">ctx.lineWidth = 1.0;</div><div class="line">ctx.strokeStyle = &quot;#000&quot;;</div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure></p>
<h3 id="设置渐变色"><a href="#设置渐变色" class="headerlink" title="设置渐变色"></a>设置渐变色</h3><p>createLinearGradient方法用来设置渐变色。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var myGradient = ctx.createLinearGradient(0, 0, 0, 160);</div><div class="line"></div><div class="line">myGradient.addColorStop(0, &quot;#BABABA&quot;);</div><div class="line"></div><div class="line">myGradient.addColorStop(1, &quot;#636363&quot;);</div></pre></td></tr></table></figure></p>
<p>createLinearGradient方法的参数是(x1, y1, x2, y2)，其中x1和y1是起点坐标，x2和y2是终点坐标。通过不同的坐标值，可以生成从上至下、从左到右的渐变等等。</p>
<p>使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ctx.fillStyle = myGradient;</div><div class="line">ctx.fillRect(10,10,200,100);</div></pre></td></tr></table></figure></p>
<h3 id="设置阴影"><a href="#设置阴影" class="headerlink" title="设置阴影"></a>设置阴影</h3><p>一系列与阴影相关的方法，可以用来设置阴影。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ctx.shadowOffsetX = 10; // 设置水平位移</div><div class="line">ctx.shadowOffsetY = 10; // 设置垂直位移</div><div class="line">ctx.shadowBlur = 5; // 设置模糊度</div><div class="line">ctx.shadowColor = &quot;rgba(0,0,0,0.5)&quot;; // 设置阴影颜色</div><div class="line"></div><div class="line">ctx.fillStyle = &quot;#CC0000&quot;;</div><div class="line">ctx.fillRect(10,10,200,100);</div></pre></td></tr></table></figure></p>
<h2 id="图像处理方法"><a href="#图像处理方法" class="headerlink" title="图像处理方法"></a>图像处理方法</h2><h3 id="drawImage方法"><a href="#drawImage方法" class="headerlink" title="drawImage方法"></a>drawImage方法</h3><p>Canvas API 允许将图像文件插入画布，做法是读取图片后，使用drawImage方法在画布内进行重绘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var img = new Image();</div><div class="line">img.src = &apos;image.png&apos;;</div><div class="line">ctx.drawImage(img, 0, 0); // 设置对应的图像对象，以及它在画布上的位置</div></pre></td></tr></table></figure></p>
<p>上面代码将一个PNG图像载入画布。drawImage()方法接受三个参数，第一个参数是图像文件的DOM元素（即<code>&lt;img&gt;</code>节点），第二个和第三个参数是图像左上角在画布中的坐标，上例中的(0, 0)就表示将图像左上角放置在画布的左上角。</p>
<p>由于图像的载入需要时间，drawImage方法只能在图像完全载入后才能调用，因此上面的代码需要改写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var image = new Image();</div><div class="line"></div><div class="line">image.onload = function() &#123;</div><div class="line">  var canvas = document.createElement(&apos;canvas&apos;);</div><div class="line">  canvas.width = image.width;</div><div class="line">  canvas.height = image.height;</div><div class="line">  canvas.getContext(&apos;2d&apos;).drawImage(image, 0, 0);</div><div class="line">  // 插入页面底部</div><div class="line">  document.body.appendChild(image);</div><div class="line">  return canvas;</div><div class="line">&#125;</div><div class="line"></div><div class="line">image.src = &apos;image.png&apos;;</div></pre></td></tr></table></figure></p>
<h3 id="getImageData、putImageData方法"><a href="#getImageData、putImageData方法" class="headerlink" title="getImageData、putImageData方法"></a>getImageData、putImageData方法</h3><p>getImageData方法可以用来读取Canvas的内容，返回一个对象，包含了每个像素的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var imageData = context.getImageData(0, 0, canvas.width, canvas.height);</div></pre></td></tr></table></figure></p>
<p>imageData对象有一个data属性，它的值是一个一维数组。该数组的值，依次是每个像素的红、绿、蓝、alpha通道值，因此该数组的长度等于 图像的像素宽度 x 图像的像素高度 x 4，每个值的范围是0–255。这个数组不仅可读，而且可写，因此通过操作这个数组的值，就可以达到操作图像的目的。修改这个数组以后，使用putImageData方法将数组内容重新绘制在Canvas上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">context.putImageData(imageData, 0, 0);</div></pre></td></tr></table></figure></p>
<h3 id="toDataURL方法"><a href="#toDataURL方法" class="headerlink" title="toDataURL方法"></a>toDataURL方法</h3><p>对图像数据做出修改以后，可以使用toDataURL方法，将Canvas数据重新转化成一般的图像文件形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function convertCanvasToImage(canvas) &#123;</div><div class="line">  var image = new Image();</div><div class="line">  image.src = canvas.toDataURL(&apos;image/png&apos;);</div><div class="line">  return image;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码将Canvas数据，转化成PNG data URI。</p>
<h3 id="save、restore方法"><a href="#save、restore方法" class="headerlink" title="save、restore方法"></a>save、restore方法</h3><p>save方法用于保存上下文环境，restore方法用于恢复到上一次保存的上下文环境。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ctx.save();</div><div class="line"></div><div class="line">ctx.shadowOffsetX = 10;</div><div class="line">ctx.shadowOffsetY = 10;</div><div class="line">ctx.shadowBlur = 5;</div><div class="line">ctx.shadowColor = &apos;rgba(0,0,0,0.5)&apos;;</div><div class="line"></div><div class="line">ctx.fillStyle = &apos;#CC0000&apos;;</div><div class="line">ctx.fillRect(10,10,150,100);</div><div class="line"></div><div class="line">ctx.restore();</div><div class="line"></div><div class="line">ctx.fillStyle = &apos;#000000&apos;;</div><div class="line">ctx.fillRect(180,10,150,100);</div></pre></td></tr></table></figure></p>
<p>上面代码先用save方法，保存了当前设置，然后绘制了一个有阴影的矩形。接着，使用restore方法，恢复了保存前的设置，绘制了一个没有阴影的矩形。</p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>利用JavaScript，可以在canvas元素上很容易地产生动画效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var posX = 20,</div><div class="line">    posY = 100;</div><div class="line"></div><div class="line">setInterval(function() &#123;</div><div class="line">    context.fillStyle = &quot;black&quot;;</div><div class="line">    context.fillRect(0,0,canvas.width, canvas.height);</div><div class="line"></div><div class="line">    posX += 1;</div><div class="line">    posY += 0.25;</div><div class="line"></div><div class="line">    context.beginPath();</div><div class="line">    context.fillStyle = &quot;white&quot;;</div><div class="line"></div><div class="line">    context.arc(posX, posY, 10, 0, Math.PI*2, true);</div><div class="line">    context.closePath();</div><div class="line">    context.fill();</div><div class="line">&#125;, 30);</div></pre></td></tr></table></figure></p>
<p>上面代码会产生一个小圆点，每隔30毫秒就向右下方移动的效果。setInterval函数的一开始，之所以要将画布重新渲染黑色底色，是为了抹去上一步的小圆点。</p>
<p>通过设置圆心坐标，可以产生各种运动轨迹。</p>
<p>先上升后下降。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var vx = 10,</div><div class="line">    vy = -10,</div><div class="line">    gravity = 1;</div><div class="line"></div><div class="line">setInterval(function() &#123;</div><div class="line">    posX += vx;</div><div class="line">    posY += vy;</div><div class="line">    vy += gravity;</div><div class="line">    // ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面代码中，x坐标始终增大，表示持续向右运动。y坐标先变小，然后在重力作用下，不断增大，表示先上升后下降。</p>
<p>小球不断反弹后，逐步趋于静止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var vx = 10,</div><div class="line">    vy = -10,</div><div class="line">    gravity = 1;</div><div class="line"></div><div class="line">setInterval(function() &#123;</div><div class="line">    posX += vx;</div><div class="line">    posY += vy;</div><div class="line"></div><div class="line">    if (posY &gt; canvas.height * 0.75) &#123;</div><div class="line">          vy *= -0.6;</div><div class="line">          vx *= 0.75;</div><div class="line">          posY = canvas.height * 0.75;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    vy += gravity;</div><div class="line">    // ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面代码表示，一旦小球的y坐标处于屏幕下方75%的位置，向x轴移动的速度变为原来的75%，而向y轴反弹上一次反弹高度的40%。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Canvas-倒计时效果&quot;&gt;&lt;a href=&quot;#Canvas-倒计时效果&quot; class=&quot;headerlink&quot; title=&quot;Canvas-倒计时效果&quot;&gt;&lt;/a&gt;Canvas-倒计时效果&lt;/h2&gt;&lt;p&gt;👉 github：  &lt;a href=&quot;https://g
    
    </summary>
    
    
      <category term="canvas" scheme="http://upyang.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>js数组操作</title>
    <link href="http://upyang.com/2017/08/21/js-Array/"/>
    <id>http://upyang.com/2017/08/21/js-Array/</id>
    <published>2017-08-21T14:22:37.000Z</published>
    <updated>2017-09-11T08:59:43.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h2><p>用于在单个的 版两种存储多个值。</p>
<h2 id="创建Array对象的语法"><a href="#创建Array对象的语法" class="headerlink" title="创建Array对象的语法"></a>创建Array对象的语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Array();</div><div class="line">new Array(size);</div><div class="line">new Array(element0, element1,....., elementn);</div></pre></td></tr></table></figure>
<h2 id="Array对象方法"><a href="#Array对象方法" class="headerlink" title="Array对象方法"></a>Array对象方法</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-8-22/80555687.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="操作练习"><a href="#操作练习" class="headerlink" title="操作练习"></a>操作练习</h2><ul>
<li><p>用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var Array = [];</div><div class="line">function getRandom(start,end) &#123;</div><div class="line">    var temp = end - start + 1;</div><div class="line">    return Math.floor(Math.Random()*temp + start);</div><div class="line">&#125;</div><div class="line">for(let i=0;i&lt;10;i++) &#123;</div><div class="line">    Array.push(getRandom(10,100));</div><div class="line">&#125;</div><div class="line">Array.sort(); //正序</div><div class="line">Array.sort(function(a,b) &#123;</div><div class="line">    return b-a</div><div class="line">&#125;)  //倒序，重写下sort函数</div></pre></td></tr></table></figure>
</li>
<li><p>把两个数组合并，并删除第二个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var temp1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</div><div class="line">var temp2 = [&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];</div><div class="line">var Array = temp1.concat(temp2);</div><div class="line">Array.splice(1,1);</div><div class="line">console.log(Array);</div></pre></td></tr></table></figure>
</li>
<li><p>有这样一个URL：<a href="http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:’1′" target="_blank" rel="external">http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:’1′</a>, b:’2′, c:”, d:’xxx’, e:undefined}。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function serilizeUrl(url) &#123;</div><div class="line">     var result = &#123;&#125;;</div><div class="line">     url = url.split(&quot;?&quot;)[1]; //问号处分割字符串并得到后半部分(前半部分索引为0，后半部分索引为1)</div><div class="line">     var map = url.split(&quot;&amp;&quot;); //&amp;前后分割开并返回一个数组</div><div class="line">     for(var i = 0, len = map.length; i &lt; len; i++) &#123;</div><div class="line">         result[map[i].split(&quot;=&quot;)[0]] = map[i].split(&quot;=&quot;)[1];</div><div class="line">     &#125;</div><div class="line">     return result;</div><div class="line">     console.log(result);</div><div class="line">&#125;</div><div class="line"></div><div class="line">serilizeUrl(&apos;http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var foo = &quot;get-element-by-id&quot;;</div><div class="line">var arr = foo.split(&quot;-&quot;);</div><div class="line">console.log(arr);</div><div class="line">for(let i=0;i&lt;=arr.length;i++) &#123;</div><div class="line">    arr[i] = arr[i].toString().chatAt(0).toUpppercase()+arr[i].substr(1,arr[i].length-1);</div><div class="line">&#125;</div><div class="line">var result = arr.join();</div><div class="line">console.log(result);</div></pre></td></tr></table></figure>
</li>
<li><p>JavaScript实现千位分隔符<br>实现思路：其实JS有自带的toLocaleString函数直接可以实现千位分隔符，这里要讲的是如何底层去实现，将数字转换为字符数组，再循环整个数组， 每三位添加一个分隔逗号，最后再合并成字符串。因为分隔符在顺序上是从后往前添加的：比如 1234567添加后是1,234,567 而不是 123,456,7 ，所以方便起见可以先把数组倒序，添加完之后再倒序回来，就是正常的顺序了。要注意的是如果数字带小数的话，要把小数部分分开处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function numFormat(num) &#123;</div><div class="line">    num = num.toString().split(&quot;.&quot;);  //分隔小数点</div><div class="line">    var arr = num[0].split(&quot;&quot;).reverse();  //转换成字符数组并且倒序排列</div><div class="line">    var res = [];</div><div class="line">    for(var i=0,len=arr.length;i&lt;len;i++) &#123;</div><div class="line">        if(i%3===0&amp;&amp;i!==0) &#123;</div><div class="line">            res.push(&quot;,&quot;);   //添加分隔符</div><div class="line">        &#125;</div><div class="line">        res.push(arr[i]);</div><div class="line">    &#125;</div><div class="line">    res.reverse();   //再次倒序成为正确的顺序</div><div class="line">    if(num[1]) &#123;    //如果有小数的话添加小数部分</div><div class="line">        res=res.join(&quot;&quot;).concat(&apos;.&apos;+num[1]);</div><div class="line">    &#125;else &#123;</div><div class="line">        res=res.join(&quot;&quot;);</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>写一个简单的函数（少于80个字符），要求返回一个布尔值指明字符串是否为回文结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">functionisPalindrome(str)&#123;</div><div class="line">    str = str.replace(/W/g,&apos;&apos;).toLowerCase();</div><div class="line">    return(str == str.split(&apos;&apos;).reverse().join(&apos;&apos;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>写一个 sum方法，在使用下面任一语法调用时，都可以正常工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(sum(2,3));   // 输出 5</div><div class="line">console.log(sum(2)(3));  // 输出 5</div></pre></td></tr></table></figure>
</li>
</ul>
<p>方法一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">functionsum(x)&#123;</div><div class="line">    if(arguments.length == 2) &#123;</div><div class="line">        returnarguments[0] + arguments[1];</div><div class="line">    &#125;else&#123;</div><div class="line">        returnfunction(y)&#123;return x+y;&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在JavaScript中，函数可以提供到 arguments 对象的访问，arguments 对象提供传递到函数的实际参数的访问。这使我们能够使用 length 属性来确定在运行时传递给函数的参数数量。<br>如果传递两个参数，那么只需加在一起，并返回。否则，我们假设它被以 sum(2)(3)这样的形式调用，所以我们返回一个匿名函数，这个匿名函数合并了传递到 sum()的参数和传递给匿名函数的参数。</p>
<p>方法二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">functionsum(x,y)&#123;</div><div class="line">    if(y !== undefined)&#123;</div><div class="line">        return x+y;</div><div class="line">    &#125;else&#123;</div><div class="line">        returnfunction(y)&#123;return x+y;&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>实现一个flatten函数，将一个嵌套多层的数组 array（数组） (嵌套可以是任何层数)转换为只有一层的数组，数组中元素仅基本类型的元素或数组，不存在循环引用的情况。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flatten([1,[2],[5,[6,9]]]);    //输出[1,2,5,6,9]</div></pre></td></tr></table></figure>
</li>
</ul>
<p>实现方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function flatten(arr) &#123;</div><div class="line">    var result =[];</div><div class="line">    function _change(arr) &#123;</div><div class="line">        for(var i=0;i&lt;arr.length;i++) &#123;</div><div class="line">            if(Array.isArray(arr[i])) &#123;</div><div class="line">                _change(arr[i]);</div><div class="line">            &#125; else &#123;</div><div class="line">                result.push(arr[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    _change(arr);</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Array对象&quot;&gt;&lt;a href=&quot;#Array对象&quot; class=&quot;headerlink&quot; title=&quot;Array对象&quot;&gt;&lt;/a&gt;Array对象&lt;/h2&gt;&lt;p&gt;用于在单个的 版两种存储多个值。&lt;/p&gt;
&lt;h2 id=&quot;创建Array对象的语法&quot;&gt;&lt;a href
    
    </summary>
    
    
      <category term="javascript" scheme="http://upyang.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>从原理上理解NodeJS的适用场景</title>
    <link href="http://upyang.com/2017/08/18/nodejs%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://upyang.com/2017/08/18/nodejs应用场景/</id>
    <published>2017-08-18T07:35:29.000Z</published>
    <updated>2017-08-20T13:20:40.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>NodeJS宣称其目标是“旨在提供一种简单的构建可伸缩网络程序的方法”，那么它的出现是为了解决什么问题呢，它有什么优缺点以及它适用于什么场景呢？</p>
<h2 id="NodeJS的特点"><a href="#NodeJS的特点" class="headerlink" title="NodeJS的特点"></a>NodeJS的特点</h2><pre><code>1. 它是一个Javascript运行环境

2. 依赖于Chrome V8引擎进行代码解释

3. 事件驱动

4. 非阻塞I/O

5. 轻量、可伸缩，适于实时数据交互应用

6. 单进程，单线程
</code></pre><h2 id="Apache的多线程高并发模式"><a href="#Apache的多线程高并发模式" class="headerlink" title="Apache的多线程高并发模式"></a>Apache的多线程高并发模式</h2><p>Apache是当前世界排名第一的Web服务端软件，它由于支持多线程并发而受到广大服务器技术选型者的欢迎。但发展到后来，Apache在一些WEB的大型应用中也渐渐暴露出它的缺点：阻塞。</p>
<p>那有的同学会奇怪，Apache不是多线程处理并发吗，为什么还会出现阻塞呢？</p>
<p>要明白这一点我们首先需要了解线程这个概念</p>
<p>什么是线程？</p>
<p>我们引用官方的解释：线程可以独立运行的最小的CPU单位，可以在同一个进程里并发运行，共享该进程下的内存地址空间（注意这个特点）。</p>
<p>我们可以看到同一个进程下的线程是会共享相同的文件和内存的（内存地址空间），所以大家可以想象，当不同的线程需要占用同一个变量时，根据先到先得的原则，先到的线程在运作时，后来的线程只能在旁边等待，也就是加入到了阻塞排队序列。所以这就是造成线程阻塞的原因。</p>
<p>因此，虽说进程可以支持多个线程，它们看似同时执行，但互相之间并不同步。一个进程中的多个线程共享相同的内存地址空间，这就意味着它们可以访问相同的变量和对象，而且它们从同一堆中分配对象。尽管这让线程之间共享信息变得更容易，因为程序设计者必须小心，确保它们不会妨碍同一进程里的其它线程。</p>
<p>了解了多线程并行的缺陷后，我们就可以更好地理解NodeJS的强大所在了。因为NodeJS是异步单线程的！</p>
<h2 id="NodeJS的异步I-O原理"><a href="#NodeJS的异步I-O原理" class="headerlink" title="NodeJS的异步I/O原理"></a>NodeJS的异步I/O原理</h2><p>我们先来看一段Apache请求数据库的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">res = db.query(&apos;select * from user&apos;);</div><div class="line">res.output();</div></pre></td></tr></table></figure></p>
<p>代码执行到第一行的时候线程会阻塞，等待query返回结果，然后继续处理，举个例子，银行排队办理业务时，服务端只有一个线程，用户请求到达只能处理一个，其余的要先等待。由于数据库查询、磁盘读写、网络通信等原因（所谓的I/O）阻塞时间会非常大（相对于CPU始终频率）。对于高并发的访问，一方面线程长期阻塞等待，另一方面为了应付新情求而不断添加新线程，会浪费大量系统资源，并发量高的时候，请求仍然需要等待，同时线程的增加也会也会占用大量的CPU时间来处理内存上下文切换。看看node.js怎么处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">res = db.query(&apos;select * from user&apos;,function(res) &#123;</div><div class="line">    res.output();</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>看到没，就四个字：异步回调。query的第二个参数是一个回调函数，进程执行到db.query的时候不会等待结果返回，而是直接继续执行下面的语句，直到进入事件循环。当数据库执行结果返回的时候会将事件发送到事件队列，等到线程进入事件循环后才会调用之前的回调函数。更专业的说法是异步I/O。只要单线程就可以。</p>
<p>举个例子，在像麦当劳这样的快餐店点餐，我们点完餐后拿到了一个号码，拿到号码后，我们往往会在位置上等待，而在我们后面的请求会继续得到处理，同样是拿了一个号码然后到一旁等待，接待员能一直进行处理。等到饭菜做号了，会喊号码，我们拿到了自己的饭菜，进行后续的处理（吃饭）。这个喊号码的动作在NodeJS中叫做回调（Callback），能在事件（烧菜，I/O）处理完成后继续执行后面的逻辑（吃饭），这体现了NodeJS的显著特点，异步机制、事件驱动整个过程没有阻塞新用户的连接（点餐），也不需要维护已经点餐的用户与厨师的连接。</p>
<p>那为什么NodeJS做到单线程，却可以实现异步呢？在这里我们先上一幅图，直戳图中的Event queue<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-8-18/77817316.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>NodeJS的工作原理其实就是事件循环。可以说每一条NodeJS的逻辑都是写在回调函数里面的，而回调函数都是有返回之后才异步执行的！</p>
<p>看到这里，你不禁会惊叹，NodeJS如果所有处理都异步，岂不是晓得飞了？错错错！当然不是，不要忘记，NodeJS实现这些的基础是单线程。没错，单线程！一条线程扛起所有操作！</p>
<p>你可以想象一下，NodeJS在寒风中面对着10万并发大军，OK，没问题，上来敌人一个扔到城里，上来一个又扔到城里。城里全民皆兵，可以很好地消化这些敌人。但如果上来一个类似于张飞赵云这样的人物，老Node心里一惨，和张飞大战300回合，把他打残了，再扔到城里。那后面的10万大军就得等这300回合。<br>所以这说明什么？说明NodeJS不是没有阻塞，而是阻塞不发生在后续回调的流程，而会发生在NodeJS本身对逻辑的计算和处理。我们已经知道，NodeJS的分发能力无比强大，可以循环事件进行异步回调。但如果在循环事件时遇到复杂的逻辑运算，那么单薄的单线程怎么支撑得起上百万的逻辑+并发呢？NodeJS它的所有I/O、网络通信等比较耗时的操作，都可以交给worker threads执行再回调，所以很快。但CPU的正常操作，它就只能自己抗了。</p>
<h2 id="NodeJS的应用场景"><a href="#NodeJS的应用场景" class="headerlink" title="NodeJS的应用场景"></a>NodeJS的应用场景</h2><p>既然NodeJS处理并发的能力强，但处理计算和逻辑的能力反而很弱，因此，如果我们把复杂的逻辑运算都搬到前端（客户端）完成，而NodeJS只需要提供异步I/O，这样就可以实现对高并发的高性能处理。情况就很多啦，比如：RESTFUL API、实时聊天、客户端逻辑强大的单页APP，具体的例子比如说：本地化的在线音乐应用，本地化的在线搜索应用，本地化的在线APP等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;NodeJS宣称其目标是“旨在提供一种简单的构建可伸缩网络程序的方法”，那么它的出现是为了解决什么问题呢，它有什么优缺点以及它适用于什么场景
    
    </summary>
    
    
      <category term="nodejs" scheme="http://upyang.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>js责任链</title>
    <link href="http://upyang.com/2017/08/07/js%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://upyang.com/2017/08/07/js责任链模式/</id>
    <published>2017-08-07T01:13:37.000Z</published>
    <updated>2017-08-15T12:58:00.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近同学问到了一个他实际工作中关于生产托运方面的一个问题，问题不是很大，但是觉得挺有意思，分享在此。</p>
<h2 id="实际需求"><a href="#实际需求" class="headerlink" title="实际需求"></a>实际需求</h2><p>现有A、B、C、D四个生产线，生产总量为2100，每个生产线的生产量未知且在0~2100(包括0和2100，保证总量为2100即可)，生产完毕后，6台车辆进行托运，规定每台车辆只能运350，且装满后才能够出发，装车顺序为ABCD,即上一个生产线生产的东西装完后才能够装下一个生产线的东西，要求根据每条生产线的生产量，给出每台车辆的托运安排。</p>
<p>例如： A：100 ， B：1400 ，C：500 ， D：100<br>托运安排：<br>        第一辆车： A：100 ， B：250<br>        第二辆车： A：0 ，   B：350<br>        第三辆车： A：0 ，   B：350<br>        第四辆车： A：0 ，   B：350<br>        第五辆车： A：0 ，   B：100 ，C：250<br>        第六辆车： A：0 ，   B：0 ，  C：250 ，D：100</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看了这个需求，脑袋里第一时间想到的是if判断，但是实际写代码的时候发现，条件太多了，算下来一共有81种情况了，感觉已经不适合用if了，这时查找各种资料以及请问大神后发现了责任链这种设计模式。</p>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链<br>。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。</p>
<p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<ul>
<li><p>意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
</li>
<li><p>主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
</li>
<li><p>关键代码：Handler里面聚合它自己，在HanleRequest里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p>
</li>
<li><p>应用实例： 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</p>
</li>
<li><p>优点：<br>  1、降低耦合度。它将请求的发送者和接收者解耦。<br>  2、简化了对象。使得对象不需要知道链的结构。<br>  3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。<br>  4、增加新的请求处理类很方便。</p>
</li>
<li><p>缺点：<br>  1、不能保证请求一定被接收。<br>  2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。<br>  3、可能不容易观察运行时的特征，有碍于除错。</p>
</li>
<li><p>使用场景：<br>  1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。<br>  2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。<br>  3、可动态指定一组对象处理请求。</p>
</li>
</ul>
<p>责任链的详细讲解可以参阅<a href="http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html" target="_blank" rel="external">菜鸟教程</a>中的说明。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">class WearHouse&#123;</div><div class="line">        constructor(volume,wearHouse)&#123;</div><div class="line">            this.volume=volume;</div><div class="line">            this.wearHouse=wearHouse;</div><div class="line">            this.outString=[];</div><div class="line">        &#125;</div><div class="line">        next(take)&#123;</div><div class="line">            if(this.wearHouse!=undefined)</div><div class="line">            &#123;</div><div class="line">                this.wearHouse.takeOut(take).forEach((subT) =&gt; &#123;</div><div class="line">                    this.outString.push(subT)</div><div class="line">                &#125;)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        takeOut(num)&#123;</div><div class="line">            if(num&gt;this.volume)&#123;</div><div class="line">                num-=this.volume;</div><div class="line">                var temp=this.volume;</div><div class="line">                this.volume=0;</div><div class="line">                this.outString.push(this.print(0,temp));</div><div class="line">                this.next(num);</div><div class="line">            &#125;else&#123;</div><div class="line">                this.volume-=num;</div><div class="line">                this.outString.push(this.print(this.volume,num));</div><div class="line">            &#125;</div><div class="line">            var temOut=this.outString;</div><div class="line">            this.outString=[];</div><div class="line">            return temOut;</div><div class="line">        &#125;</div><div class="line">        print(volumn,takeNum)&#123;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class WearHouseA extends WearHouse&#123;</div><div class="line">        print(volumn,takeNum)&#123;</div><div class="line">            return [&apos;A&apos;,takeNum];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class WearHouseB extends WearHouse&#123;</div><div class="line">        print(volumn,takeNum)&#123;</div><div class="line">            return [&apos;B&apos;,takeNum];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class WearHouseC extends WearHouse&#123;</div><div class="line">        print(volumn,takeNum)&#123;</div><div class="line">            return [&apos;C&apos;,takeNum];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class WearHouseD extends WearHouse&#123;</div><div class="line">        print(volumn,takeNum)&#123;</div><div class="line">            return [&apos;D&apos;,takeNum];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var D=new WearHouseD(100,undefined);</div><div class="line"></div><div class="line">    var C=new WearHouseC(500,D);</div><div class="line"></div><div class="line">    var B=new WearHouseB(1400,C);</div><div class="line"></div><div class="line">    var A=new WearHouseA(100,B);</div><div class="line"></div><div class="line">    var strSet=[];</div><div class="line"></div><div class="line">    for(var a=0;a&lt;6;a++)&#123;</div><div class="line"></div><div class="line">        strSet.push(...A.takeOut(350));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    console.log(strSet);</div></pre></td></tr></table></figure>
<p>*</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>责任链模式，对于解决按照优先级顺序依次执行的问题也挺有效的，不用写很多的判断语句。责任链模式在java中应用尤其广泛，尝试用js来实现责任链也是挺有意思的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近同学问到了一个他实际工作中关于生产托运方面的一个问题，问题不是很大，但是觉得挺有意思，分享在此。&lt;/p&gt;
&lt;h2 id=&quot;实际需求&quot;&gt;&lt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://upyang.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript面试</title>
    <link href="http://upyang.com/2017/08/04/javascript%E9%9D%A2%E8%AF%95/"/>
    <id>http://upyang.com/2017/08/04/javascript面试/</id>
    <published>2017-08-04T02:37:31.000Z</published>
    <updated>2017-08-21T14:27:11.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型、继承"><a href="#原型、继承" class="headerlink" title="原型、继承"></a>原型、继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">function Parent() &#123;</div><div class="line">    this.a = 1;</div><div class="line">    this.b = [1, 2, this.a];</div><div class="line">    this.c = &#123; demo: 5 &#125;;</div><div class="line">    this.show = function () &#123;</div><div class="line">        console.log(this.a , this.b , this.c.demo );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function Child() &#123;</div><div class="line">    this.a = 2;</div><div class="line">    this.change = function () &#123;</div><div class="line">        this.b.push(this.a);</div><div class="line">        this.a = this.b.length;</div><div class="line">        this.c.demo = this.a++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Child.prototype = new Parent();</div><div class="line">var parent = new Parent();</div><div class="line">var child1 = new Child();</div><div class="line">var child2 = new Child();</div><div class="line">child1.a = 11;</div><div class="line">child2.a = 12;</div><div class="line">parent.show();  &lt;!-- 输出 1 [1,2,1] 5 --&gt;</div><div class="line">child1.show();  &lt;!-- 输出 11 [1,2,1] 5 --&gt;</div><div class="line">child2.show();  &lt;!-- 输出 12 [1,2,1] 5 --&gt;</div><div class="line">child1.change();</div><div class="line">child2.change();</div><div class="line">parent.show();  &lt;!-- 输出  1 [1,2,1] 5 --&gt;</div><div class="line">child1.show();  &lt;!-- 输出  5 [1,2,1,11,12] 5 --&gt;</div><div class="line">child2.show();  &lt;!-- 输出  6 [1,2,1,11,12] 5 --&gt;</div></pre></td></tr></table></figure>
<ul>
<li><p>考察知识点：<br>  1，this的指向<br>  2，原型(prototype)以及原型链<br>  3，继承<br>  4，引用</p>
</li>
<li><p>要正确解出这道题，需要理解以下知识点：<br>  1，每一个构造函数，都有一个原型[[prototype]]属性 指向构造函数的原型对象。<br>  2，每一个实例生成的时候，都会在内存中产生一块新的堆内存。<br>  3，每一实例都有一个隐式原型<strong>proto</strong> 指向构造函数的原型对象。<br>  4，this的指向 取决于this调用时的位置, 在这道题中， 也可以简单理解为， 谁调用方法， this就指向哪个对象。<br>  5，数组和字面量对象 都是 引用。<br>  6，原型链的查找规则：  就近原则</p>
<ul>
<li>当实例上存在属性时， 用实例上的。</li>
<li>如果实例不存在，顺在原型链，往上查找，如果存在，就使用原型链的。</li>
<li>如果原型链都不存在，就用Object原型对象上的。</li>
<li>如果Object原型对象都不存在， 就是undefined。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原型、继承&quot;&gt;&lt;a href=&quot;#原型、继承&quot; class=&quot;headerlink&quot; title=&quot;原型、继承&quot;&gt;&lt;/a&gt;原型、继承&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
    
    </summary>
    
    
      <category term="javascript" scheme="http://upyang.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目上传github并预览</title>
    <link href="http://upyang.com/2017/07/25/Vue%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0github%E5%B9%B6%E9%A2%84%E8%A7%88/"/>
    <id>http://upyang.com/2017/07/25/Vue项目上传github并预览/</id>
    <published>2017-07-25T08:05:27.000Z</published>
    <updated>2017-07-31T04:14:11.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在初步完成自己的<a href="https://github.com/Aaron0525/Vue-juejin-App" target="_blank" rel="external">掘金移动端App</a>后，想要上传到github，并且制作一个简单的预览功能，期间遇到了一些问题，分享在此，以便查阅。</p>
<h1 id="打包Vue项目"><a href="#打包Vue项目" class="headerlink" title="打包Vue项目"></a>打包Vue项目</h1><p>当Vue项目完成后，在根目录下打开命令行，输入命令：</p>
<blockquote>
<p>npm run build</p>
</blockquote>
<p>实际上此命令就是执行build.js文件，将项目打包成静态资源。<br>此命令完成后，项目根目录下会多出一个dist文件夹，dist文件里面有：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-25/30082494.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>static文件下包括项目打包后的css、js、img、fonts(字体图标)。</p>
<h1 id="项目资源无法加载"><a href="#项目资源无法加载" class="headerlink" title="项目资源无法加载"></a>项目资源无法加载</h1><p>点击index.html,浏览器显示该页面是空白的，打开控制台看到：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-25/5971079.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>这里看到index.html文件中没有加载任何css、js文件，解决方法：</p>
<ul>
<li>打开项目根目录　config　下的　index.js　文件，进行如下修改：<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-25/15749381.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></li>
<li>将　assetsPublicPath: ‘/‘,　改为　assetsPublicPath: ‘./‘,</li>
</ul>
<p>保存后重新’npm run build’,在新生成的dist目录下点开index.html，这时页面结构正常显示出来了，但是页面字体图标和mock的数据无法正常加载。</p>
<h1 id="字体图标无法加载"><a href="#字体图标无法加载" class="headerlink" title="字体图标无法加载"></a>字体图标无法加载</h1><p>页面中用background加载的图片可以正常显示，但是所有的字体图标都不能正常显示，解决方法：打开根目录下　build　中的　utils.js　文件，在控制build样式文件代码中添加　publicPath: ‘../../‘，　如下：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-25/63452149.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>保存后，依旧重新’npm run build’,打开dist目录下的index.js可以看到字体图标正常显示了。<br>这里为什么需要这样修改，可以参考<a href="https://github.com/vuejs-templates/webpack/issues/166。" target="_blank" rel="external">https://github.com/vuejs-templates/webpack/issues/166。</a></p>
<h1 id="Mock数据无法正常加载"><a href="#Mock数据无法正常加载" class="headerlink" title="Mock数据无法正常加载"></a>Mock数据无法正常加载</h1><p>此项目的绝大部分页面内容是通过在跟目录下创建的data.json文件渲染到页面上的，是模拟从后端请求数据的，开发调试时用’npm run dev’命令，会借助node启动一个本地服务器，可以正常的渲染出相应的数据。而通过打包后的项目时属于静态资源的，点击index.html查看项目，是无法加载mock的数据的，浏览器也会报跨域的错误。若想正常的加载mock数据，最好的方式是讲打包后的资源丢到服务器中，或者使用jsonp请求线上真实数据，因为它的原理是利用script标签来获得数据，在github上是可以预览到的。</p>
<h1 id="利用git命令将项目上传到github"><a href="#利用git命令将项目上传到github" class="headerlink" title="利用git命令将项目上传到github"></a>利用git命令将项目上传到github</h1><p>首先设置SSH key,网上的教程很多，推荐一个简书里面的<a href="http://www.jianshu.com/p/c70ca3a02087" target="_blank" rel="external">两种方法上传本地文件到github</a>,完成后在github里面新建一个一个存放项目的仓库(建议勾选上初始化)，git命令：</p>
<p>1、先进入项目文件夹，通过命令 git init 把这个目录变成git可以管理的仓库</p>
<blockquote>
<p>git init</p>
</blockquote>
<p>2、把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意思为添加文件夹下的所有文件。</p>
<blockquote>
<p>git add .</p>
</blockquote>
<p>3、用命令 git commit告诉Git，把文件提交到仓库。引号内为提交说明。</p>
<blockquote>
<p>git commit -m ‘message’</p>
</blockquote>
<p>4、关联到远程库。</p>
<blockquote>
<p>git remote add origin 你的远程库地(如：<a href="https://github.com/Aaron0525/Vue-juejin-App.git" target="_blank" rel="external">https://github.com/Aaron0525/Vue-juejin-App.git</a>)</p>
</blockquote>
<p>5、将项目所有push文件到仓库中。</p>
<blockquote>
<p>git push -u origin master</p>
</blockquote>
<ul>
<li>第五步操作时，有时会失败，我的方法是将 u 改为 f 来提交，即输入命令git push -f origin master<br>回到github中该项目的仓库，项目文件就提交上去了，若失败，请仔细核对步骤。</li>
</ul>
<h1 id="制作github在线预览效果"><a href="#制作github在线预览效果" class="headerlink" title="制作github在线预览效果"></a>制作github在线预览效果</h1><p>  github制作预览是需要利用GitHub Pages的，点击项目仓库的setting,找到source,切换到master branch,点击保存。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-25/53441109.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>点击GitHub Pages下面出现的网址即为预览地址，但是此时点击进去会发现没有页面效果，没关系，下面继续：</p>
<p>我们生成githubPages的目的就是需要生成一个gh-pages分支(正常情况下只有一个master分支)。</p>
<p>生成gh-pages分支步骤：</p>
<p>1、将远程仓库克隆到本地：</p>
<blockquote>
<p>git clone <a href="https://github.com/Aaron0525/Vue-juejin-App.git(项目克隆地址" target="_blank" rel="external">https://github.com/Aaron0525/Vue-juejin-App.git(项目克隆地址</a>)</p>
</blockquote>
<p>2、生成分支gh-pages并切换到此分支</p>
<blockquote>
<p>cd flexSupplement （进入到你克隆仓库的本地文件夹）<br>  git checkout - -orphan gh-pages (创建分支并切换，两个横杆)</p>
</blockquote>
<p>3、将本地克隆文件(文件名为github仓库名)里面除.git文件以外的其他文件全部删除，再将根目录下dist文件夹里面的内容复制到克隆文件中。</p>
<blockquote>
<p>依次执行以下命令：<br>  git add . （将本地所有文件加到仓库里）<br>  git commit -m “message” （设置提交信息）<br>  git remote add origin <a href="https://github.com/Aaron0525/" target="_blank" rel="external">https://github.com/Aaron0525/</a>　Vue-juejin-App.git（本地仓库链接远程仓库）<br>  git push -u origin gh-pages （push文件到仓库中）</p>
</blockquote>
<p>完成以上步骤后，回到github里面，点击上面说到的GitHub Pages下面的地址，既能预览效果，注意耐心等待一小会，跟新同步还是需要一个过程的，同样这里面还是无法显示mock的数据。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>   github，这个星球上最流行的开源托管服务的分布式网站，作为程序员，掌握基本的github使用方法，无论是对于分享、托管自己的项目，还是查阅其他优秀的开源项目，都是十分有帮助的。<br>   以下是我的一些项目演示：</p>
<p>   <a href="https://github.com/Aaron0525/Vue-music" target="_blank" rel="external">Vue2.0移动端以音乐播放器</a><br>   <a href="https://github.com/Aaron0525/Vue-juejin-App" target="_blank" rel="external">Vue2.0模仿掘金App</a><br>   <a href="https://github.com/Aaron0525/Responsive-website" target="_blank" rel="external">响应式网站</a></p>
<p>   觉得有用的，可以给个start哦！ 感谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在初步完成自己的&lt;a href=&quot;https://github.com/Aaron0525/Vue-juejin-App&quot; target
    
    </summary>
    
    
      <category term="Vue2.0" scheme="http://upyang.com/tags/Vue2-0/"/>
    
      <category term="github" scheme="http://upyang.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.0仿掘金App(总结)</title>
    <link href="http://upyang.com/2017/07/21/Vue%E5%AD%A6%E4%B9%A0/"/>
    <id>http://upyang.com/2017/07/21/Vue学习/</id>
    <published>2017-07-21T15:28:51.000Z</published>
    <updated>2017-08-07T02:55:46.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　最近一段时间一直在学习Vue2.0的相关知识，之前只是看过相关的视频教学，但是一直没有动手去实践自己的项目，这次决定用Vue2.0去模仿一个移动端App,看了很多自己用过的App,最后决定模仿做掘金移动端App,恰好这款App也是用Vue做的。写下这篇博客，记录实践中的心得体会。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>首先直观的看下掘金App的基本页面构成：</p>
<p><img src="http://oszamq4pp.bkt.clouddn.com/17-7-22/81795026.jpg" width="300" height="500" style="float:left;margin-right: 30px;margin-bottom: 20px;border: 1px solid #E8E1E1;"><img src="http://oszamq4pp.bkt.clouddn.com/17-7-23/6318549.jpg" width="300" height="500" style="float:left;margin-right: 30px; margin-bottom: 20px;border: 1px solid #E8E1E1;"><img src="http://oszamq4pp.bkt.clouddn.com/17-7-23/79170730.jpg" width="300" height="500" style="float: left;margin-right: 30px;border: 1px solid #E8E1E1;"><img src="http://oszamq4pp.bkt.clouddn.com/17-7-23/46672523.jpg" width="300" height="500" style="margin-right: 30px;border: 1px solid #E8E1E1;"></p>
<p> 通过观察分析，总结出以下几点：</p>
<ul>
<li>首页，底部和顶部分别有tab切换，在Vue中可以通过配置嵌套路由来实现。</li>
<li>发现页，顶部有一个轮播图，数据要求实时跟新。因为之前有在做<a href="http://localhost:4000/categories/" target="_blank" rel="external">Vue-music</a>时有做过一个数据实时跟新的轮播图,这里直接引用过来，后面也会具体去讲怎么实现。沸点栏，有一个左右可以滑动的新闻栏。</li>
<li>消息、我的信息页面基本上都是数据交互，其中我的信息里面会包含一个h5调用摄像头、相册的功能。</li>
<li>项目中用到的字体图标采用阿里的iconfont,一些无法搜索到的图片，用firework切图工具切出来。</li>
</ul>
<h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><p>这里基本的node、git的安装就不一一介绍了，网上有很多相关的教程。选用webpack、vue-cli脚手架来快速搭建我们的项目骨架。</p>
<ul>
<li>Vue创建项目命令：<blockquote>
<p>Vue init webpack juejin</p>
</blockquote>
</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-23/77103498.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>根据提示完成相应的项目基本信息，个人意愿选择是否使用ESlint、单元测试、端到端测试等等,建议新手不使用ESlint做代码格式检查，不然可能在写的过程中遇到非常多代码格式错误，当然选择使用的话也有好处，能很好的规范自己的代码风格。</p>
<ul>
<li>完成项目构建后，对目录进行修改，修改完成后如下：<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-23/4776956.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3></li>
<li>api: 存放jsonp请求轮播图数据的js文件</li>
<li>base: 存放项目的基础组件，例如：轮播图组件(slider)、新闻列表组件(newslist)、新闻详情listdetail)、搜索组件(search)、修改个人信息组件(modify)等.</li>
<li>common: 存放fonts、image、js、stylus文件。</li>
<li>components: 存放项目的主要组件</li>
<li>router: 路由配置</li>
<li>需要注意的是，因为想要模拟从后端获取数据并绑定到组件上，而不是把数据写死在结构上，所以这里在根目录新建了一个data.json的文件，里面写好了项目需要用到的数据。<h3 id="package-json配置依赖"><a href="#package-json配置依赖" class="headerlink" title="package.json配置依赖"></a>package.json配置依赖</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-23/33192057.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>npm install</p>
</blockquote>
</li>
</ul>
<p>node_modules文件目录下查看到以上的依赖包，说明安装成功了。注意：因为项目用到的reset重置样式文件(copy来的)是stylus格式，所以还需要在devDependencies中配置stylus和stylus-loader依赖。</p>
<h3 id="文件路径配置"><a href="#文件路径配置" class="headerlink" title="文件路径配置"></a>文件路径配置</h3><p>项目中会经常引入各种文件，为了引用方便会进行以下配置，觉得没必要的可以忽略。</p>
<ul>
<li>打开build目录下的webpack.base.conf.js文件，在resolve下进行以下配置<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-23/82258197.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></li>
<li>这样的好处是引用某个文件的时候不用每次都带上一堆的前缀。<h3 id="引入字体图标"><a href="#引入字体图标" class="headerlink" title="引入字体图标"></a>引入字体图标</h3>前面说到本项目用的是阿里iconfont字体图标库，选择好所要用到的图标之后下载到本地，将其中除了3个html演示文件以外的其他7个文件拷贝到common/fonts目录下，然后将iconfont.css文件里的内容拷贝到common/stylus/icon.styl中,首先要修改的是引用路径，其他根据需要自行修改字体图标的基本样式。<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-23/43259474.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-23/23822432.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></li>
<li>测试字体图标是否引用成功：根目录main.js下 import ‘./common/stylus/icon.styl’，然后在组件中引用一个字体图标，用浏览器查看是否引用成功。<h3 id="Express获取data-json数据的路由配置"><a href="#Express获取data-json数据的路由配置" class="headerlink" title="Express获取data.json数据的路由配置"></a>Express获取data.json数据的路由配置</h3>data.json文件数据结构如下：<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-23/59387298.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
接下来配置Express路由，本项目只涉及到get数据，所以只进行了简单的路由配置，Express的详细使用可以查看<a href="http://www.expressjs.com.cn/" target="_blank" rel="external">Express官网</a>,打开build.js文件下的dev-server.js文件，进行以下配置：<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-23/82175984.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
npm run dev重启服务器，浏览器访问<code>localhost:8080/api/infor</code>,若能看到如data.json/infor里面的数据说明已经配置成功了。</li>
</ul>
<h2 id="页面嵌套路由配置"><a href="#页面嵌套路由配置" class="headerlink" title="页面嵌套路由配置"></a>页面嵌套路由配置</h2><p>前面讲到本项目需要配置嵌套路由，首先看一下路由组件的目录结构：components目录下除了四个主要页面组件，还需要在home目录下新建五个子路由对应的组件。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-23/38824633.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>打开router下的index文件进行如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">import Vue from &apos;vue&apos;</div><div class="line">import Router from &apos;vue-router&apos;</div><div class="line">import Home from &apos;../components/home/home&apos;</div><div class="line">import Find from &apos;../components/find/find&apos;</div><div class="line">import Infor from &apos;../components/infor/infor&apos;</div><div class="line">import My from &apos;../components/my/my&apos;</div><div class="line">import Homepage from &apos;../components/home/homepage/homepage&apos;</div><div class="line">import Frontend from &apos;../components/home/frontend/frontend&apos;</div><div class="line">import Product from &apos;../components/home/product/product&apos;</div><div class="line">import Design from &apos;../components/home/design/design&apos;</div><div class="line">import Afterend from &apos;../components/home/afterend/afterend&apos;</div><div class="line"></div><div class="line">Vue.use(Router)</div><div class="line"></div><div class="line">export default new Router(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123;</div><div class="line">      path: &apos;/&apos;,</div><div class="line">      redirect: &apos;./home&apos;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      path: &apos;/home&apos;,</div><div class="line">      component: Home,</div><div class="line">      children: [</div><div class="line">        &#123;</div><div class="line">          path: &apos;/&apos;,</div><div class="line">          redirect: &apos;./homepage&apos;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          path: &apos;/home/homepage&apos;,</div><div class="line">          component: Homepage</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          path: &apos;/home/frontend&apos;,</div><div class="line">          component: Frontend</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          path: &apos;/home/product&apos;,</div><div class="line">          component: Product</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          path: &apos;/home/design&apos;,</div><div class="line">          component: Design</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          path: &apos;/home/afterend&apos;,</div><div class="line">          component: Afterend</div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      path: &apos;/find&apos;,</div><div class="line">      component: Find</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      path: &apos;/infor&apos;,</div><div class="line">      component: Infor</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      path: &apos;/my&apos;,</div><div class="line">      component: My</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p> <code>redirect: &#39;./home&#39;</code>，redirect重定向是规定运行项目后首次显示的页面，这里定向到home首页，子路由中同样需要重定向<code>redirect: &#39;./homepage&#39;</code>。观察可以发现主路由首次显示的页面内容是和子路由首次显示的页面内容是一样的，那么，我们是否可以用同一个组件呢?百般尝试后没有成功，因为主路由home页面渲染出来后，内容上是包含顶部的tab切换的(也就是子路由)，所以前面说到的内容一样其实是个伪命题，那么子路由的重定向不能是home而是homepage，公用的页面内容写在homepage里面。</p>
<p> 接下来编写主路由和子路由的tab组件<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"> &lt;!-- 底部tab，顶部同理  --&gt;</div><div class="line">&lt;template&gt;</div><div class="line">  &lt;div class=&quot;tab&quot;&gt;</div><div class="line">    &lt;router-link tag=&quot;div&quot; class=&quot;tab-item&quot; to=&quot;/home&quot;&gt;</div><div class="line">      &lt;div class=&quot;tab-link&quot;&gt;</div><div class="line">        &lt;div class=&quot;ic_container&quot;&gt;&lt;i class=&quot;iconfont ic home&quot;&gt;&amp;#xe6a6;&lt;/i&gt;&lt;/div&gt;</div><div class="line">        &lt;span&gt;首页&lt;/span&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &lt;/router-link&gt;</div><div class="line">    &lt;router-link tag=&quot;div&quot; class=&quot;tab-item&quot; to=&quot;/find&quot;&gt;</div><div class="line">      &lt;div class=&quot;tab-link&quot;&gt;</div><div class="line">        &lt;div class=&quot;ic_container&quot;&gt;&lt;i class=&quot;iconfont ic find&quot;&gt;&amp;#xe669;&lt;/i&gt;&lt;/div&gt;</div><div class="line">        &lt;span&gt;发现&lt;/span&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &lt;/router-link&gt;</div><div class="line">    &lt;router-link tag=&quot;div&quot; class=&quot;tab-item&quot; to=&quot;/infor&quot;&gt;</div><div class="line">      &lt;div class=&quot;tab-link&quot;&gt;</div><div class="line">        &lt;div class=&quot;ic_container&quot;&gt;&lt;i class=&quot;iconfont ic message&quot;&gt;&amp;#xe62d;&lt;/i&gt;&lt;/div&gt;</div><div class="line">        &lt;span&gt;消息&lt;/span&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &lt;/router-link&gt;</div><div class="line">    &lt;router-link tag=&quot;div&quot; class=&quot;tab-item&quot; to=&quot;/my&quot;&gt;</div><div class="line">      &lt;div class=&quot;tab-link&quot;&gt;</div><div class="line">        &lt;div class=&quot;ic_container&quot;&gt;&lt;i class=&quot;iconfont ic my&quot;&gt;&amp;#xe705;&lt;/i&gt;&lt;/div&gt;</div><div class="line">        &lt;span&gt;我的&lt;/span&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &lt;/router-link&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：检查路由是否配置成功不仅仅要看是否能正常切换，还需要观察地址栏路径变化，是否符合逻辑。<br>底部点击切换时，<a href="http://localhost:8080/#/[home,find,infor,my]四个地址之间切换。" target="_blank" rel="external">http://localhost:8080/#/[home,find,infor,my]四个地址之间切换。</a><br>点击顶部路由时，<a href="http://localhost:8080/#/home/[homepage,frontend,product,design,afterend]五个地址之间切换。" target="_blank" rel="external">http://localhost:8080/#/home/[homepage,frontend,product,design,afterend]五个地址之间切换。</a></p>
</blockquote>
<h2 id="发现页轮播图"><a href="#发现页轮播图" class="headerlink" title="发现页轮播图"></a>发现页轮播图</h2><p>轮播图对于前端工程师来说十分常见，以往的轮播图数据都是写死的，不能变化，这次希望模仿出来的掘金App更加真实，所以做了一个数据可变的的轮播图。很遗憾，掘金App上的轮播图数据暂时没有想到好的办法去拿到，chrome网页版掘金切换到手机模式依旧没有轮播图数据。这里选用的是QQ音乐首页轮播图数据，究竟怎么拿到数据并显示呢？</p>
<h3 id="jsonp封装"><a href="#jsonp封装" class="headerlink" title="jsonp封装"></a>jsonp封装</h3><p>安装好jsonp依赖后，详见<a href="https://github.com/webmodules/jsonp" target="_blank" rel="external">webmodules / jsonp</a>，然后对对原始jsonp进行简单的封装:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import originJsonp from &apos;jsonp&apos;</div><div class="line"></div><div class="line">//对外暴露一个方法也叫jsonp,参数url是干净的数据地址，参数data选择我们想要的数据并拼接url上</div><div class="line">export default function jsonp(url, data, option) &#123;</div><div class="line">  url += (url.indexOf(&apos;?&apos;) &lt; 0 ? &apos;?&apos; : &apos;&amp;&apos;) + param(data)</div><div class="line"></div><div class="line">  return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">    originJsonp(url, option, (err, data) =&gt; &#123;</div><div class="line">      if (!err) &#123;</div><div class="line">        resolve(data)</div><div class="line">      &#125; else &#123;</div><div class="line">        reject(err)</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">export function param(data) &#123;</div><div class="line">  let url = &apos;&apos;</div><div class="line">  for (var k in data) &#123;</div><div class="line">    let value = data[k] !== undefined ? data[k] : &apos;&apos;</div><div class="line">    url += &apos;&amp;&apos; + k + &apos;=&apos; + encodeURIComponent(value)</div><div class="line">  &#125;</div><div class="line">  return url ? url.substring(1) : &apos;&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>获取数据后渲染到组件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;recommend&quot;&gt;</div><div class="line">    &lt;div class=&quot;recommend-content&quot;&gt;</div><div class="line">        &lt;div v-if=&quot;recommends.length&quot; class=&quot;slider-wrapper&quot;&gt;</div><div class="line">            &lt;slider&gt;</div><div class="line">                &lt;div v-for=&quot;item in recommends&quot;&gt;</div><div class="line">                    &lt;a :href=&quot;item.linkUrl&quot;&gt;</div><div class="line">                        &lt;img :src=&quot;item.picUrl&quot;&gt;</div><div class="line">                    &lt;/a&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">            &lt;/slider&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h3 id="better-scroll"><a href="#better-scroll" class="headerlink" title="better-scroll"></a>better-scroll</h3><ul>
<li>滚动区域的子元素高度大于父元素时才会滚动，通常需要给滚动区域加上一层定高度的盒子。如果列表是数据渲染来的，初始化better-scroll的时机要在获取数据函数执行时就初始化better-scroll，保证能正确就计算出子元素的高度，子、父元素高度差即为可滚动的高度。</li>
</ul>
<h2 id="父组件与子组件数据通信"><a href="#父组件与子组件数据通信" class="headerlink" title="父组件与子组件数据通信"></a>父组件与子组件数据通信</h2><ul>
<li>在点击新闻列表后,会出现新闻详情页面，新闻详情页面是一个单独的子组件模板,里面的作者、图像、文章banner图、文章标题等一系列数据是需要在点击新闻列表后将数据传递过来并绑定在组件结构上的。</li>
</ul>
<!-- <img src="http://oszamq4pp.bkt.clouddn.com/17-7-22/81795026.jpg" width = "300" height = "500" style="float:left;margin-right: 30px;margin-bottom: 20px;border: 1px solid #E8E1E1;"/><img src="http://oszamq4pp.bkt.clouddn.com/17-7-23/62531253.jpg" width = "300" height = "500" style="float:left;margin-right: 30px; margin-bottom: 20px;border: 1px solid #E8E1E1;"/> -->
<h3 id="定义子组件："><a href="#定义子组件：" class="headerlink" title="定义子组件："></a>定义子组件：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;transition name=&quot;move&quot;&gt;</div><div class="line">    &lt;div v-show=&quot;showFlag&quot; class=&quot;listdetail&quot;&gt;</div><div class="line">      &lt;div class=&quot;foot&quot;&gt;</div><div class="line">        &lt;div class=&quot;like-num&quot;&gt;喜欢 &#123;&#123;list.like&#125;&#125;&lt;/div&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/transition&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script type=&quot;text/ecmascript-6&quot;&gt;</div><div class="line">  export default &#123;</div><div class="line">    data() &#123;</div><div class="line">      return &#123;</div><div class="line">        showFlag: false</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    props: &#123;</div><div class="line">      list: &#123;</div><div class="line">        type: Object</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    methods: &#123;</div><div class="line">      show() &#123;</div><div class="line">        this.showFlag = true;</div><div class="line">      &#125;,</div><div class="line">      hide() &#123;</div><div class="line">        this.showFlag = false;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>在props中定义一个变量list来接受父组件传过来的数据</p>
</blockquote>
<h3 id="父组件：引入子组件listdetail并注册"><a href="#父组件：引入子组件listdetail并注册" class="headerlink" title="父组件：引入子组件listdetail并注册"></a>父组件：引入子组件listdetail并注册</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-23/44625871.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>父组件中新闻列表是通过v-for在li标签上渲染出来的，点击某新闻列表传给子组件的数据也必须是对应的，添加click事件@selectlist(item)，并传入一个参数item,这个item就是该新闻列表所对应的相关数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;!-- ref 被用来给元素或子组件注册引用信息，直接指向组件实例。 list接受数据。--&gt;</div><div class="line">&lt;listdetail :list=&quot;selectedlist&quot; ref=&quot;listdetail&quot;&gt;&lt;/listdetail&gt;</div><div class="line"></div><div class="line">&lt;!--data里面定义一个中间变量selectedlist,缓存item的数据(数据为某个新闻列表而非所有数据)并将其绑定在&lt;listdetail&gt;标签上--&gt;</div><div class="line">data: &#123;</div><div class="line">  return &#123;</div><div class="line">    selectedlist: &#123;&#125;,</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&lt;!--定义selectlist函数，将数据赋值给中间变量selectedlist,并在点击时触发子组件的show()方法 --&gt;</div><div class="line">methods: &#123;</div><div class="line">  selectlist(item) &#123;</div><div class="line">      this.selectedlist = item;</div><div class="line">      this.$refs.listdetail.show();</div><div class="line">  &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>子组件在props中创建一个属性，用来接受父组件传过来的数据。</li>
<li>父组件中注册和引用子组件。</li>
<li>在子组件变迁中添加子组件props中创建的属性。</li>
<li>点击事件触发子组件show()方法时将数据一并赋值给改属性。</li>
<li>父组件可以调用子组件中的方法。</li>
</ul>
<h2 id="Vue中transition过渡动画"><a href="#Vue中transition过渡动画" class="headerlink" title="Vue中transition过渡动画"></a>Vue中transition过渡动画</h2><p>App很多地方会有点击后出现一个新的页面的操作，如果不做动画看起来会感觉差点什么，Vue中也提供了了过渡动画的API，官网教程：<a href="https://cn.vuejs.org/v2/guide/transitions.html。" target="_blank" rel="external">https://cn.vuejs.org/v2/guide/transitions.html。</a></p>
<p>在点击新闻列表后，会从右至左出来新闻详情页面，实现也十分简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;transition name=&quot;move&quot;&gt;</div><div class="line">    &lt;div v-show=&quot;showFlag&quot; class=&quot;listdetail&quot;&gt;</div><div class="line">        &lt;!-- 组件内容--&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/transition&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;style&gt;</div><div class="line">  .move-enter-active, .move-leave-active &#123;</div><div class="line">      transition: all 0.2s linear;</div><div class="line">  &#125;</div><div class="line">  .move-enter, .move-leave-active &#123;</div><div class="line">    transform: translate3d(100%, 0, 0);</div><div class="line">  &#125;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure></p>
<h2 id="h5调用摄像头"><a href="#h5调用摄像头" class="headerlink" title="h5调用摄像头"></a>h5调用摄像头</h2><p>  h5调用摄像头在IOS设备和安卓设备上存在很大的兼容性问题，目前也只是实现了能打开摄像头和相册，对图片进行编辑和上传功能还没有实现(正在研究中)。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-23/857737.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<blockquote>
<input id="fileBtn" class="fileBtn" type="file" accept="image/*" capture="camera">

</blockquote>
<ul>
<li>移动端实现图片上传并预览，需要用到h5标签input的file属性及filereader对象；<br>accept=”image/*” 表示接受的是图片(不限制格式），若想限制格式需要这样写<br>capture=”camera” 直接打开摄像头，若不加会出现选择打开相机或打开相册<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>模仿掘金App是对Vue2.0知识的一种实践，整个做完还是很有收获的，巩固了自己的CSS布局方面的基本功，也对Vue2.0语法的具体应用场景更加清晰。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　最近一段时间一直在学习Vue2.0的相关知识，之前只是看过相关的视频教学，但是一直没有动手去实践自己的项目，这次决定用Vue2.0去模仿
    
    </summary>
    
    
      <category term="Vue2.0" scheme="http://upyang.com/tags/Vue2-0/"/>
    
      <category term="ES6" scheme="http://upyang.com/tags/ES6/"/>
    
      <category term="jsonp" scheme="http://upyang.com/tags/jsonp/"/>
    
      <category term="webpack" scheme="http://upyang.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.0掘金App</title>
    <link href="http://upyang.com/2017/07/21/Vue-juejin-App/"/>
    <id>http://upyang.com/2017/07/21/Vue-juejin-App/</id>
    <published>2017-07-21T09:56:15.000Z</published>
    <updated>2017-08-02T02:43:02.984Z</updated>
    
    <content type="html"><![CDATA[<div><br>    <div style="color: #061CC9;font-size: 30px;text-align: center;">掘金移动端APP</div><br>    <div style="background: #FFFFFF;font-size: 17px;box-shadow: 0 15px 20px rgba(0,0,0,0.1);padding-left: 20px;padding-right: 20px;"><br>    👉 github：  <a href="https://github.com/Aaron0525/Vue-juejin-App" target="_blank" rel="external">https://github.com/Aaron0525/Vue-juejin-App</a><br><br>    👉 演示地址:  <a href="http://www.upyang.com/Vue-juejin-App/#/home/homepage" target="_blank" rel="external">http://www.upyang.com/Vue-juejin-App/#/home/homepage</a><br><br>    <font color="#0D3EA8"><strong>项目介绍</strong></font>：<p>&emsp;&emsp;这是一个用Vue2.0模仿的掘金App,使用了Vue2.0+ES6+webpack等前端热门技术。</p><font color="#0D3EA8"><strong>技术栈</strong></font>：<p>&emsp;&emsp;Vue.js: MVVM轻量组件化的热门前端框架。</p><p>&emsp;&emsp;Vuex：状态管理。 采用集中式存储管理应用的所有组件的状态。</p><p>&emsp;&emsp;Vue Router：前端路由，它是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。</p><p>&emsp;&emsp;better-scroll：页面滚动插件，实现了页面无滚动条形式的滚动，且在此基础上实现了首页的轮播图。</p><p>&emsp;&emsp;axios、jsonp：抓取掘金PC端线上新闻列表数据并渲染到组建中。</p><p>&emsp;&emsp;Vue-lazyload：图片懒加载。 </p><p>&emsp;&emsp;构建工具： webpack</p><br>    </div><br></div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;&lt;br&gt;    &lt;div style=&quot;color: #061CC9;font-size: 30px;text-align: center;&quot;&gt;掘金移动端APP&lt;/div&gt;&lt;br&gt;    &lt;div style=&quot;background: #FFFFFF;font-size
    
    </summary>
    
    
      <category term="Vue2.0" scheme="http://upyang.com/tags/Vue2-0/"/>
    
      <category term="ES6" scheme="http://upyang.com/tags/ES6/"/>
    
      <category term="jsonp" scheme="http://upyang.com/tags/jsonp/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.0移动端音乐App</title>
    <link href="http://upyang.com/2017/07/18/Vue-music/"/>
    <id>http://upyang.com/2017/07/18/Vue-music/</id>
    <published>2017-07-18T11:02:20.000Z</published>
    <updated>2017-07-28T03:09:06.931Z</updated>
    
    <content type="html"><![CDATA[<div><br>    <div style="color: #061CC9;font-size: 30px;text-align: center;">Vue2.0搭建移动端音乐APP</div><br>    <div style="background: #FFFFFF;font-size: 17px;box-shadow: 0 15px 20px rgba(0,0,0,0.1);padding-left: 20px;padding-right: 20px;"><br>    👉 github: <a href="https://github.com/Aaron0525/Vue-music" target="_blank" rel="external">https://github.com/Aaron0525/Vue-music</a><br><br>    👉 演示地址: <a href="http://www.upyang.com/Vue-music/index.html#/recommend" target="_blank" rel="external">http://www.upyang.com/Vue-music/index.html#/recommend</a><br><br>    <font color="#0D3EA8"><strong>项目介绍</strong></font>：<p>&emsp;&emsp;这是一个用Vue.js写的移动端音乐App(SPA),使用了Vue2.0+ES6+webpack等前端热门技术。核心功能热门歌曲推荐、音乐播放、歌曲歌手搜索等。</p><font color="#0D3EA8"><strong>技术栈</strong></font>：<p>&emsp;&emsp;MVVM框架：Vue.js（版本2.0）轻量组件化的热门前端框架。</p><p>&emsp;&emsp;状态管理：Vuex。 采用集中式存储管理应用的所有组件的状态。</p><p>&emsp;&emsp;前端路由：Vue Router。它是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。</p><p>&emsp;&emsp;滚动插件：better-scroll。实现了页面无滚动条形式的滚动，且在此基础上实现了首页的轮播图。</p><p>&emsp;&emsp;构建工具： webpack</p><p>&emsp;&emsp;服务端通信：axios、jsonp。从QQ音乐抓取数据显示到页面。</p><p>&emsp;&emsp;构建工具： webpack</p><br>    </div><br></div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;&lt;br&gt;    &lt;div style=&quot;color: #061CC9;font-size: 30px;text-align: center;&quot;&gt;Vue2.0搭建移动端音乐APP&lt;/div&gt;&lt;br&gt;    &lt;div style=&quot;background: #FFFFFF;f
    
    </summary>
    
    
      <category term="Vue2.0" scheme="http://upyang.com/tags/Vue2-0/"/>
    
      <category term="ES6" scheme="http://upyang.com/tags/ES6/"/>
    
      <category term="jsonp" scheme="http://upyang.com/tags/jsonp/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化之雅虎军规</title>
    <link href="http://upyang.com/2017/07/15/%E9%9B%85%E8%99%8E%E5%86%9B%E8%A7%84/"/>
    <id>http://upyang.com/2017/07/15/雅虎军规/</id>
    <published>2017-07-15T08:08:55.000Z</published>
    <updated>2017-08-03T15:28:23.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="尽量减少HTTP请求数"><a href="#尽量减少HTTP请求数" class="headerlink" title="尽量减少HTTP请求数"></a>尽量减少HTTP请求数</h2><p>　　80%的终端用户响应时间都花在了前端上，其中大部分时间都在下载页面上的各种组件：图片，样式表，脚本，Flash等等。减少组件数必然能够减少页面提交的HTTP请求数。这是让页面更快的关键。</p>
<p>　　减少页面组件数的一种方式是简化页面设计。但有没有一种方法可以在构建复杂的页面同时加快响应时间呢？嗯，确实有鱼和熊掌兼得的办法。</p>
<p>　　合并文件是通过把所有脚本放在一个文件中的方式来减少请求数的，当然，也可以合并所有的CSS。如果各个页面的脚本和样式不一样的话，合并文件就是一项比较麻烦的工作了，但把这个作为站点发布过程的一部分确实可以提高响应时间。</p>
<p>　　CSS Sprites是减少图片请求数量的首选方式。把背景图片都整合到一张图片中，然后用CSS的background-image和background-position属性来定位要显示的部分。</p>
<p>　　图像映射可以把多张图片合并成单张图片，总大小是一样的，但减少了请求数并加速了页面加载。图片映射只有在图像在页面中连续的时候才有用，比如导航条。给image map设置坐标的过程既无聊又容易出错，用image map来做导航也不容易，所以不推荐用这种方式。</p>
<p>　　行内图片（Base64编码）用data: URL模式来把图片嵌入页面。这样会增加HTML文件的大小，把行内图片放在（缓存的）样式表中是个好办法，而且成功避免了页面变“重”。但目前主流浏览器并不能很好地支持行内图片。</p>
<p>　　减少页面的HTTP请求数是个起点，这是提升站点首次访问速度的重要指导原则。</p>
<h2 id="减少DNS查找"><a href="#减少DNS查找" class="headerlink" title="减少DNS查找"></a>减少DNS查找</h2><p>　域名系统建立了主机名和IP地址间的映射，就像电话簿上人名和号码的映射一样。当你在浏览器输入www.yahoo.com的时候，浏览器就会联系DNS解析器返回服务器的IP地址。DNS是有成本的，它需要20到120毫秒去查找给定主机名的IP地址。在DNS查找完成之前，浏览器无法从主机名下载任何东西。</p>
<p>　　DNS查找被缓存起来更高效，由用户的ISP（网络服务提供商）或者本地网络存在一个特殊的缓存服务器上，但还可以缓存在个人用户的计算机上。DNS信息被保存在操作系统的DNS cache(微软Windows上的”DNS客户端服务”)里。大多数浏览器有独立于操作系统的自己的cache。只要浏览器在自己的cache里还保留着这条记录，它就不会向操作系统查询DNS。</p>
<p>　　IE默认缓存DNS查找30分钟，写在DnsCacheTimeout注册表设置中。Firefox缓存1分钟，可以用network.dnsCacheExpiration配置项设置。(Fasterfox把缓存时间改成了1小时 P.S. Fasterfox是FF的一个提速插件)</p>
<p>　　如果客户端的DNS cache是空的（包括浏览器的和操作系统的），DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本文件，样式表，Flash对象等等组件中的主机名，减少不同的主机名就可以减少DNS查找。</p>
<p>　　减少不同主机名的数量同时也减少了页面能够并行下载的组件数量，避免DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散在2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。</p>
<h2 id="避免重定向"><a href="#避免重定向" class="headerlink" title="避免重定向"></a>避免重定向</h2><p>重定向用301和302状态码，下面是一个有301状态码的HTTP头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 301 Moved Permanently</div><div class="line">      Location: http://example.com/newuri</div><div class="line">      Content-Type: text/html</div></pre></td></tr></table></figure>
<p>　浏览器会自动跳转到Location域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其实额外的HTTP头，比如Expires和Cache-Control也表示重定向。除此之外还有别的跳转方式：refresh元标签和JavaScript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。</p>
<p>　　牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。</p>
<p>　　有一种常见的极其浪费资源的重定向，而且web开发人员一般都意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到<a href="http://astrology.yahoo.com/astrology会返回一个重定向到http://astrology.yahoo.com/astrology/的301响应（注意添在尾部的斜线）。在Apache中可以用Alias，mod_rewrite或者DirectorySlash指令来取消不必要的重定向。" target="_blank" rel="external">http://astrology.yahoo.com/astrology会返回一个重定向到http://astrology.yahoo.com/astrology/的301响应（注意添在尾部的斜线）。在Apache中可以用Alias，mod_rewrite或者DirectorySlash指令来取消不必要的重定向。</a></p>
<p>　　重定向最常见的用途是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用Alias和mod_rewrite，前提是两个代码路径都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合Alias或者mod_rewrite指令。</p>
<h2 id="让Ajax可缓存"><a href="#让Ajax可缓存" class="headerlink" title="让Ajax可缓存"></a>让Ajax可缓存</h2><p>Ajax的一个好处是可以给用户提供即时反馈，因为它能够从后台服务器异步请求信息。然而，用了Ajax就无法保证用户在等待异步JavaScript和XML响应返回期间不会非常无聊。在很多应用程序中，用户能够一直等待取决于如何使用Ajax。例如，在基于web的电子邮件客户端中，用户为了寻找符合他们搜索标准的邮件消息，将会保持对Ajax请求返回结果的关注。重要的是，要记得“异步”并不意味着“即时”。要提高性能，优化这些Ajax响应至关重要。最重要的提高Ajax性能的方法就是让响应变得可缓存，就像在添上Expires或者Cache-Control HTTP头中讨论的一样。下面适用于Ajax的其它规则：</p>
<p>Gzip组件</p>
<p>减少DNS查找</p>
<p>压缩JavaScript</p>
<p>避免重定向</p>
<p>配置ETags</p>
<p>  我们一起看看例子，一个Web2.0的电子邮件客户端用了Ajax来下载用户的通讯录，以便实现自动完成功能。如果用户从上一次使用之后再没有修改过她的通讯录，而且Ajax响应是可缓存的，有尚未过期的Expires或者Cache-Control HTTP头，那么之前的通讯录就可以从缓存中读出。必须通知浏览器，应该继续使用之前缓存的通讯录响应，还是去请求一个新的。可以通过给通讯录的Ajax URL里添加一个表明用户通讯录最后修改时间的时间戳来实现，例如&amp;t=1190241612。如果通讯录从上一次下载之后再没有被修改过，时间戳不变，通讯录就将从浏览器缓存中直接读出，从而避免一次额外的HTTP往返消耗。如果用户已经修改了通讯录，时间戳也可以确保新的URL不会匹配缓存的响应，浏览器将请求新的通讯录条目。</p>
<p>　　即使Ajax响应是动态创建的，而且可能只适用于单用户，它们也可以被缓存，而这样会让你的Web 2.0应用更快。</p>
<h2 id="延迟加载组件"><a href="#延迟加载组件" class="headerlink" title="延迟加载组件"></a>延迟加载组件</h2><p>可以凑近看看页面并问自己：什么才是一开始渲染页面所必须的？其余内容都可以等会儿。</p>
<p>　　JavaScript是分隔onload事件之前和之后的一个理想选择。例如，如果有JavaScript代码和支持拖放以及动画的库，这些都可以先等会儿，因为拖放元素是在页面最初渲染之后的。其它可以延迟加载的部分包括隐藏内容（在某个交互动作之后才出现的内容）和折叠的图片。</p>
<p>　　工具可帮你减轻工作量：YUI Image Loader可以延迟加载折叠的图片，还有YUI Get utility是一种引入JS和CSS的简单方法。Yahoo!主页就是一个例子，可以打开Firebug的网络面板仔细看看。</p>
<p>　　最好让性能目标符合其它web开发最佳实践，比如“渐进增强”。如果客户端支持JavaScript，可以提高用户体验，但必须确保页面在不支持JavaScript时也能正常工作。所以，在确定页面运行正常之后，可以用一些延迟加载脚本增强它，以支持一些拖放和动画之类的华丽效果。
　　</p>
<h2 id="预加载组件"><a href="#预加载组件" class="headerlink" title="预加载组件　　"></a>预加载组件　　</h2><p>预加载可能看起来和延迟加载是相反的，但它其实有不同的目标。通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。用户访问下一页的时候，大部分组件都已经在缓存里了，所以在用户看来页面会加载得更快。</p>
<p>实际应用中有以下几种预加载的类型：</p>
<p>无条件预加载——尽快开始加载，获取一些额外的组件。google.com就是一个sprite图片预加载的好例子，这个sprite图片并不是google.com主页需要的，而是搜索结果页面上的内容。<br>条件性预加载——根据用户操作猜测用户将要跳转到哪里并据此预加载。在search.yahoo.com的输入框里键入内容后，可以看到那些额外组件是怎样请求加载的。<br>提前预加载——在推出新设计之前预加载。经常在重新设计之后会听到：“这个新网站不错，但比以前更慢了”，一部分原因是用户访问先前的页面都是有旧缓存的，但新的却是一种空缓存状态下的体验。可以通过在将要推出新设计之前预加载一些组件来减轻这种负面影响，老站可以利用浏览器空闲的时间来请求那些新站需要的图片和脚本。
　　</p>
<h2 id="减少DOM元素的数量"><a href="#减少DOM元素的数量" class="headerlink" title="减少DOM元素的数量"></a>减少DOM元素的数量</h2><p>　一个复杂的页面意味着要下载更多的字节，而且用JavaScript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素和5000个DOM元素是有区别的。</p>
<p>　　大量的DOM元素是一种征兆——页面上有些内容无关的标记需要清理。正在用嵌套表格来布局吗？还是为了修复布局问题而添了一堆的<div>s？或许应该用更好的语义化标记。</div></p>
<p>YUI CSS utilities对布局有很大帮助：grids.css针对整体布局，fonts.css和reset.css可以用来去除浏览器的默认格式。这是个开始清理和思考标记的好机会，例如只在语义上有意义的时候使用<div>，而不是因为它能够渲染一个新行。</div></p>
<p>　　DOM元素的数量很容易测试，只需要在Firebug的控制台里输入：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.getElementsByTagName(&apos;*&apos;).length</div></pre></td></tr></table></figure></p>
<p>　那么多少DOM元素才算是太多呢？可以参考其它类似的标记良好的页面，例如Yahoo!主页是一个相当繁忙的页面，但只有不到700个元素（HTML标签）。
　　</p>
<h2 id="跨域分离组件"><a href="#跨域分离组件" class="headerlink" title="跨域分离组件"></a>跨域分离组件</h2><p>　分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。例如，可以把HTML和动态内容部署在www.example.org，而把静态组件分离到static1.example.org和static2.example.org。</p>
<h2 id="尽量少用iframe"><a href="#尽量少用iframe" class="headerlink" title="尽量少用iframe"></a>尽量少用iframe</h2><p>　用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。</p>
<p><code>&lt;iframe&gt;</code>的优点：</p>
<p>引入缓慢的第三方内容，比如标志和广告<br>安全沙箱<br>并行下载脚本<br><code>&lt;iframe&gt;</code>的缺点：</p>
<p>代价高昂，即使是空白的iframe<br>阻塞页面加载<br>非语义</p>
<h2 id="杜绝404"><a href="#杜绝404" class="headerlink" title="杜绝404"></a>杜绝404</h2><p>　HTTP请求代价高昂，完全没有必要用一个HTTP请求去获取一个无用的响应（比如404 Not Found），只会拖慢用户体验而没有任何好处。</p>
<p>　　有些站点用的是有帮助的404——“你的意思是xxx？”，这样做有利于用户体验，，但也浪费了服务器资源（比如数据库等等）。最糟糕的是链接到的外部JavaScript有错误而且结果是404。首先，这种下载将阻塞并行下载。其次，浏览器会试图解析404响应体，因为它是JavaScript代码，需要找出其中可用的部分。</p>
<h2 id="避免使用CSS表达式"><a href="#避免使用CSS表达式" class="headerlink" title="避免使用CSS表达式"></a>避免使用CSS表达式</h2><p>用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但从IE8起就不推荐使用了。例如，可以用CSS表达式把背景颜色设置成按小时交替的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">background-color: expression( (new Date()).getHours()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; );</div></pre></td></tr></table></figure>
<h2 id="选择舍弃-import"><a href="#选择舍弃-import" class="headerlink" title="选择舍弃@import"></a>选择<link>舍弃@import</h2><p>前面提到了一个最佳实践：为了实现逐步渲染，CSS应该放在顶部。</p>
<p>  在IE中用@import与在底部用<link>效果一样，所以最好不要用它。</p>
<h2 id="避免使用滤镜"><a href="#避免使用滤镜" class="headerlink" title="避免使用滤镜"></a>避免使用滤镜</h2><p>　　IE专有的AlphaImageLoader滤镜可以用来修复IE7之前的版本中半透明PNG图片的问题。在图片加载过程中，这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗而且是被应用到每个元素的，而不是每个图片，所以会存在一大堆问题。</p>
<p>最好的方法是干脆不要用AlphaImageLoader，而优雅地降级到用在IE中支持性很好的PNG8图片来代替。如果非要用AlphaImageLoader，应该用下划线hack：_filter来避免影响IE7及更高版本的用户。</p>
<h2 id="把样式表放在顶部"><a href="#把样式表放在顶部" class="headerlink" title="把样式表放在顶部"></a>把样式表放在顶部</h2><p>　　在Yahoo!研究性能的时候，我们发现把样式表放到文档的HEAD部分能让页面看起来加载地更快。这是因为把样式表放在head里能让页面逐步渲染。</p>
<p>　　关注性能的前端工程师想让页面逐步渲染。也就是说，我们想让浏览器尽快显示已有内容，这在页面上有一大堆内容或者用户网速很慢时显得尤为重要。给用户显示反馈（比如进度指标）的重要性已经被广泛研究过，并且被记录下来了。在我们的例子中，HTML页面就是进度指标！当浏览器逐渐加载页面头部，导航条，顶部logo等等内容的时候，这些都被正在等待页面加载的用户当作反馈，能够提高整体用户体验。</p>
<h2 id="去除重复脚本"><a href="#去除重复脚本" class="headerlink" title="去除重复脚本"></a>去除重复脚本</h2><p>　　页面含有重复的脚本文件会影响性能，这可能和你想象的不一样。在对美国前10大web站点的评审中，发现只有2个站点含有重复脚本。两个主要原因增加了在单一页面中出现重复脚本的几率：团队大小和脚本数量。在这种情况下，重复脚本会创建不必要的HTTP请求，执行无用的JavaScript代码，而影响页面性能。</p>
<p>　　IE会产生不必要的HTTP请求，而Firefox不会。在IE中，如果一个不可缓存的外部脚本被页面引入了两次，它会在页面加载时产生两个HTTP请求。即使脚本是可缓存的，在用户重新加载页面时也会产生额外的HTTP请求。</p>
<p>　　除了产生没有意义的HTTP请求之外，多次对脚本求值也会浪费时间。因为无论脚本是否可缓存，在Firefox和IE中都会执行冗余的JavaScript代码。</p>
<p>　　避免不小心把相同脚本引入两次的一种方法就是在模版系统中实现脚本管理模块。典型的脚本引入方法就是在HTML页面中用SCRIPT标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;menu_1.0.17.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h2 id="尽量减少DOM访问"><a href="#尽量减少DOM访问" class="headerlink" title="尽量减少DOM访问"></a>尽量减少DOM访问</h2><p>用JavaScript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该：</p>
<p>缓存已访问过的元素的索引<br>先“离线”更新节点，再把它们添到DOM树上<br>避免用JavaScript修复布局问题</p>
<h2 id="用智能的事件处理器"><a href="#用智能的事件处理器" class="headerlink" title="用智能的事件处理器"></a>用智能的事件处理器</h2><p>　　有时候感觉页面反映不够灵敏，是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上，这就是推荐使用事件委托的原因。如果一个div里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮都添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。</p>
<h2 id="把脚本放在底部"><a href="#把脚本放在底部" class="headerlink" title="把脚本放在底部"></a>把脚本放在底部</h2><p>　　脚本会阻塞并行下载，HTTP/1.1官方文档建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个主机名，并行下载的数量就可以超过两个。如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同主机名下的。</p>
<p>　　有时候，并不容易把脚本移动到底部。举个例子，如果脚本是用document.write插入到页面内容中的，就没办法再往下移了。还可能存在作用域问题，在多数情况下，这些问题都是可以解决的。</p>
<p>　　一个常见的建议是用推迟（deferred）脚本，有DEFER属性的脚本意味着不能含有document.write，并且提示浏览器告诉他们可以继续渲染。不幸的是，Firefox不支持DEFER属性。在IE中，脚本可能被推迟，但不尽如人意。如果脚本可以推迟，我们就可以把它放到页面底部，页面就可以更快地载入。</p>
<h2 id="把JavaScript和CSS放到外面"><a href="#把JavaScript和CSS放到外面" class="headerlink" title="把JavaScript和CSS放到外面"></a>把JavaScript和CSS放到外面</h2><p>　　很多性能原则都是关于如何管理外部组件的，然而，在这些顾虑出现之前你应该问一个更基础的问题：应该把JavaScript和CSS放到外部文件中还是直接写在页面里？</p>
<p>实际上，用外部文件可以让页面更快，因为JavaScript和CSS文件会被缓存在浏览器。HTML文档中的行内JavaScript和CSS在每次请求该HTML文档的时候都会重新下载。这样做减少了所需的HTTP请求数，但增加了HTML文档的大小。另一方面，如果JavaScript和CSS在外部文件中，并且已经被浏览器缓存起来了，那么我们就成功地把HTML文档变小了，而且还没有增加HTTP请求数。</p>
<p>　　</p>
<h2 id="压缩JavaScript和CSS"><a href="#压缩JavaScript和CSS" class="headerlink" title="压缩JavaScript和CSS"></a>压缩JavaScript和CSS</h2><p>　　压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行和tab）。在JavaScript中这样做能够提高响应性能，因为要下载的文件变小了。两个最常用的JavaScript代码压缩工具是JSMin和YUI Compressor，YUI compressor还可以压缩CSS。</p>
<p>　　混淆是一种可选的源码优化措施，要比压缩更复杂，所以混淆过程也更容易产生bug。在对美国前十的网站调查中，压缩可以缩小21%，而混淆能缩小25%。虽然混淆的缩小程度更高，但比压缩风险更大。</p>
<p>　　除了压缩外部脚本和样式，行内的<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>块也可以压缩。即使启用了gzip模块，先进行压缩也能够缩小5%或者更多的大小。JavaScript和CSS的用处越来越多，所以压缩代码会有不错的效果。</p>
<h2 id="优化图片"><a href="#优化图片" class="headerlink" title="优化图片"></a>优化图片</h2><p>尝试把GIF格式转换成PNG格式，看看是否节省空间。在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）</p>
<h2 id="优化CSS-Sprite"><a href="#优化CSS-Sprite" class="headerlink" title="优化CSS Sprite"></a>优化CSS Sprite</h2><p>在Sprite图片中横向排列一般都比纵向排列的最终文件小<br>组合Sprite图片中的相似颜色可以保持低色数，最理想的是256色以下PNG8格式<br>“对移动端友好”，不要在Sprite图片中留下太大的空隙。虽然不会在很大程度上影响图片文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100×100的图片是1万个像素，而1000×1000的图片就是100万个像素了。</p>
<h2 id="不要用HTML缩放图片"><a href="#不要用HTML缩放图片" class="headerlink" title="不要用HTML缩放图片"></a>不要用HTML缩放图片</h2><p>　不要因为在HTML中可以设置宽高而使用本不需要的大图。如果需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>　那么图片本身（mycat.jpg）应该是100x100px的，而不是去缩小500x500px的图片。</p>
<h2 id="用小的可缓存的favicon-ico（P-S-收藏夹图标）"><a href="#用小的可缓存的favicon-ico（P-S-收藏夹图标）" class="headerlink" title="用小的可缓存的favicon.ico（P.S. 收藏夹图标）"></a>用小的可缓存的favicon.ico（P.S. 收藏夹图标）</h2><p>　　favicon.ico是放在服务器根目录的图片，它会带来一堆麻烦，因为即便你不管它，浏览器也会自动请求它，所以最好不要给一个404 Not Found响应。而且只要在同一个服务器上，每次请求它时都会发送cookie，此外这个图片还会干扰下载顺序，例如在IE中，当你在onload中请求额外组件时，将会先下载favicon。</p>
<p>所以为了缓解favicon.ico的缺点，应该确保：</p>
<p>足够小，最好在1K以下<br>设置合适的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为几个月后一般比较安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。</p>
<h2 id="给Cookie减肥"><a href="#给Cookie减肥" class="headerlink" title="给Cookie减肥"></a>给Cookie减肥</h2><p>　　使用cookie的原因有很多，比如授权和个性化。HTTP头中cookie信息在web服务器和浏览器之间交换。重要的是保证cookie尽可能的小，以最小化对用户响应时间的影响。</p>
<p>清除不必要的cookie<br>保证cookie尽可能小，以最小化对用户响应时间的影响<br>注意给cookie设置合适的域级别，以免影响其它子域<br>设置合适的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间</p>
<h2 id="把组件放在不含cookie的域下"><a href="#把组件放在不含cookie的域下" class="headerlink" title="把组件放在不含cookie的域下"></a>把组件放在不含cookie的域下</h2><p>　　当浏览器发送对静态图像的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。所以它们只会造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署在那儿。</p>
<p>　　如果域名是www.example.org，可以把静态组件部署到static.example.org。然而，如果已经在顶级域example.org或者www.example.org设置了cookie，那么所有对static.example.org的请求都会含有这些cookie。这时候可以再买一个新域名，把所有的静态组件部署上去，并保持这个新域名不含cookie。Yahoo!用的是yimg.com，YouTube是ytimg.com，Amazon是images-amazon.com等等。</p>
<p>　　把静态组件部署在不含cookie的域下还有一个好处是有些代理可能会拒绝缓存带cookie的组件。有一点需要注意：如果不知道应该用example.org还是www.example.org作为主页，可以考虑一下cookie的影响。省略www的话，就只能把cookie写到*.example.org，所以因为性能原因最好用www子域，并且把cookie写到这个子域下。</p>
<h2 id="保证所有组件都小于25K"><a href="#保证所有组件都小于25K" class="headerlink" title="保证所有组件都小于25K"></a>保证所有组件都小于25K</h2><p>　　这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。</p>
<h2 id="把组件打包到一个复合文档里"><a href="#把组件打包到一个复合文档里" class="headerlink" title="把组件打包到一个复合文档里"></a>把组件打包到一个复合文档里</h2><p>　　把各个组件打包成一个像有附件的电子邮件一样的复合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。</p>
<h2 id="Gzip组件"><a href="#Gzip组件" class="headerlink" title="Gzip组件"></a>Gzip组件</h2><p>　　前端工程师可以想办法明显地缩短通过网络传输HTTP请求和响应的时间。毫无疑问，终端用户的带宽速度，网络服务商，对等交换点的距离等等，都是开发团队所无法控制的。但还有别的能够影响响应时间的因素，压缩可以通过减少HTTP响应的大小来缩短响应时间。</p>
<p>从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Accept-Encoding: gzip, deflate</div></pre></td></tr></table></figure>
<p>如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding相应头来通知客户端。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Content-Encoding: gzip</div></pre></td></tr></table></figure></p>
<p>　　尽可能多地用gzip压缩能够给页面减肥，这也是提升用户体验最简单的方法。</p>
<h2 id="避免图片src属性为空"><a href="#避免图片src属性为空" class="headerlink" title="避免图片src属性为空"></a>避免图片src属性为空</h2><p>Image with empty string src属性是空字符串的图片很常见，主要以两种形式出现：<br>straight HTML<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=””&gt;</div></pre></td></tr></table></figure></p>
<p>JavaScript</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var img = new Image();</div><div class="line">img.src = “”;</div></pre></td></tr></table></figure>
<h2 id="配置ETags"><a href="#配置ETags" class="headerlink" title="配置ETags"></a>配置ETags</h2><p>　实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器中的组件是否匹配的一种机制（“实体”也就是组件：图片，脚本，样式表等等）。添加ETags可以提供一种实体验证机制，比最后修改日期更加灵活。一个ETag是一个字符串，作为一个组件某一具体版本的唯一标识符。唯一的格式约束是字符串必须用引号括起来，源服务器用相应头中的ETag来指定组件的ETag：</p>
<h2 id="对Ajax用GET请求"><a href="#对Ajax用GET请求" class="headerlink" title="对Ajax用GET请求"></a>对Ajax用GET请求</h2><p>Yahoo!邮箱团队发现使用XMLHttpRequest时，浏览器的POST请求是通过一个两步的过程来实现的：先发送HTTP头，在发送数据。所以最好用GET请求，它只需要发送一个TCP报文（除非cookie特别多）。IE的URL长度最大值是2K，所以如果要发送的数据超过2K就无法使用GET了。</p>
<p>POST请求的一个有趣的副作用是实际上没有发送任何数据，就像GET请求一样。正如HTTP说明文档中描述的，GET请求是用来检索信息的。所以它的语义只是用GET请求来请求数据，而不是用来发送需要存储到服务器的数据。</p>
<h2 id="尽早清空缓冲区"><a href="#尽早清空缓冲区" class="headerlink" title="尽早清空缓冲区"></a>尽早清空缓冲区</h2><p>当用户请求一个页面时，服务器需要用大约200到500毫秒来组装HTML页面，在这期间，浏览器闲等着数据到达。PHP中有一个flush()函数，允许给浏览器发送一部分已经准备完毕的HTML响应，以便浏览器可以在后台准备剩余部分的同时开始获取组件，好处主要体现在很忙的后台或者很“轻”的前端页面上（P.S. 也就是说，响应时耗主要在后台方面时最能体现优势）。</p>
<p>　　较理想的清空缓冲区的位置是HEAD后面，因为HTML的HEAD部分通常更容易生成，并且允许引入任何CSS和JavaScript文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取组件。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">... &lt;!-- css, js --&gt;</div><div class="line">   &lt;/head&gt;</div><div class="line">   &lt;?php flush(); ?&gt;</div><div class="line">   &lt;body&gt;</div><div class="line">     ... &lt;!-- content --&gt;</div></pre></td></tr></table></figure>
<h2 id="使用CDN（内容分发网络）"><a href="#使用CDN（内容分发网络）" class="headerlink" title="使用CDN（内容分发网络）"></a>使用CDN（内容分发网络）</h2><p>　用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。但具体要怎么做呢？</p>
<p>　　实现内容在地理位置上分散的第一步是：不要尝试去重新设计你的web应用程序来适应分布式结构。这取决于应用程序，改变结构可能包括一些让人望而生畏的任务，比如同步会话状态和跨服务器复制数据库事务（翻译可能不准确）。缩短用户和内容之间距离的提议可能被推迟，或者根本不可能通过，就是因为这个难题。</p>
<p>　　记住终端用户80%到90%的响应时间都花在下载页面组件上了：图片，样式，脚本，Flash等等，这是业绩黄金法则。最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。</p>
<p>　　内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。
　　</p>
<h2 id="添上Expires或者Cache-Control-HTTP头"><a href="#添上Expires或者Cache-Control-HTTP头" class="headerlink" title="添上Expires或者Cache-Control HTTP头"></a>添上Expires或者Cache-Control HTTP头</h2><p>这条规则有两个方面：</p>
<p>对于静态组件：通过设置一个遥远的将来时间作为Expires来实现永不失效<br>多余动态组件：用合适的Cache-ControlHTTP头来让浏览器进行条件性的请求<br>　　网页设计越来越丰富，这意味着页面里有更多的脚本，图片和Flash。站点的新访客可能还是不得不提交几个HTTP请求，但通过使用有效期能让组件变得可缓存，这避免了在接下来的浏览过程中不必要的HTTP请求。有效期HTTP头通常被用在图片上，但它们应该用在所有组件上，包括脚本、样式和Flash组件。</p>
<p>　　浏览器（和代理）用缓存来减少HTTP请求的数目和大小，让页面能够更快加载。web服务器通过有效期HTTP响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在2010年4月15日前不会改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Expires: Thu, 15 Apr 2010 20:00:00 GMT</div></pre></td></tr></table></figure>
<p>如果你用的是Apache服务器，用ExpiresDefault指令来设置相对于当前日期的有效期。下面的例子设置了从请求时间起10年的有效期：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExpiresDefault &quot;access plus 10 years&quot;</div></pre></td></tr></table></figure></p>
<p>　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;尽量减少HTTP请求数&quot;&gt;&lt;a href=&quot;#尽量减少HTTP请求数&quot; class=&quot;headerlink&quot; title=&quot;尽量减少HTTP请求数&quot;&gt;&lt;/a&gt;尽量减少HTTP请求数&lt;/h2&gt;&lt;p&gt;　　80%的终端用户响应时间都花在了前端上，其中大部分时间都在下载页
    
    </summary>
    
    
      <category term="性能优化" scheme="http://upyang.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="SEO" scheme="http://upyang.com/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>原生js实现Ajax实例讲解(二)</title>
    <link href="http://upyang.com/2017/07/12/ajax2/"/>
    <id>http://upyang.com/2017/07/12/ajax2/</id>
    <published>2017-07-12T14:30:38.000Z</published>
    <updated>2017-07-16T14:43:11.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>Ajax的核心技术是XMLHttpRequest对象,它可以在不向服务器提交整个页面的情况下，实现局部更新网页。通过这个对象，Ajax可以像桌面应用程序那样只与服务器进行数据层的交换，而不必每次都刷新界面，也不必每次将数据处理的工作都交给服务器来做。这样既减轻了服务器负担又提高了响应速度，还缩短了用户的等待时间。通常一个Ajax的实现过程有五步，下面我们以<a href="http://www.upyang.com/2017/07/12/ajax/" target="_blank" rel="external">上篇博客中的小实例</a>为例来逐步学习。</p>
<h2 id="XMLHttpRequest对象的五步使用法"><a href="#XMLHttpRequest对象的五步使用法" class="headerlink" title="XMLHttpRequest对象的五步使用法"></a>XMLHttpRequest对象的五步使用法</h2><h3 id="创建XMLHttpRequest对象。"><a href="#创建XMLHttpRequest对象。" class="headerlink" title="创建XMLHttpRequest对象。"></a>创建XMLHttpRequest对象。</h3><p>IE浏览器将XMLHttpRequest实现为一个ActiveX对象，其他浏览器如Firefox，Opera，Netscape等将其实现为一个本地JavaScript对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function CreatXHR()</div><div class="line">    &#123;</div><div class="line">        //判断浏览器是否支持ActiveX控件，针对IE6及之前版本</div><div class="line">        if (window.ActiveXObject)</div><div class="line">        &#123;</div><div class="line">            //将所有可能出现的ActiveXObject版本都放在一个数组中</div><div class="line">            var arrXHR = [&apos;Microsoft.XMLHTTP&apos;, &apos;MSXML2.XMLHTTP.6.0&apos;, &apos;MSXML2.XMLHTTP.5.0&apos;, &apos;MSXML2.XMLHTTP.4.0&apos;, &apos;MSXML2.XMLHTTP.3.0&apos;, &apos;MSXML2.XMLHTTP&apos;];</div><div class="line">            //通过循环创建XMLHttpRequest对象</div><div class="line">            var temp = arrXHR.length;</div><div class="line">            for (var i=0;i&lt;temp;i++)</div><div class="line">            &#123;</div><div class="line">                try</div><div class="line">                &#123;</div><div class="line">                    //创建XMLHttpRequest对象</div><div class="line">                    xhr = new ActiveXObject(arrXHR[i]);</div><div class="line">                    //如果创建XMLHttpRequest对象成功，则跳出循环</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                catch(ex)</div><div class="line">                &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //判断浏览器是否将XMLHttpRequest作为本地对象实现，针对IE7，Firefox，Opera等浏览器</div><div class="line">        else if(window.XMLHttpRequest)</div><div class="line">        &#123;</div><div class="line">            xhr = new XMLHttpRequest();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//创建XMLHttpRequest对象，调用前面定义好的函数</div><div class="line">    creatXMLHTTP();</div><div class="line">    if (xhr!=null)</div><div class="line">    &#123;</div><div class="line">        //创建响应XMLHttpRequest对象状态变化的函数</div><div class="line"></div><div class="line">        //创建http请求</div><div class="line"></div><div class="line">        //发送http请求</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        alert(&quot;您的浏览器不支持XMLHTTP&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="注册回调函数"><a href="#注册回调函数" class="headerlink" title="注册回调函数"></a>注册回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//创建响应XMLHttpRequest对象状态变化的函数</div><div class="line">    xhr.onreadystatechange = httpStateChange;</div></pre></td></tr></table></figure>
<p>在异步调用时，XMLHttpRequest对象有几个不同的状态，这些状态表示了异步调用的过程。<br>　　0：未初始化状态，刚创建完一个XMLHttpRequest对象；<br>　　1：初始化状态，即XMLHttpRequest对象已经获得了要将数据发送到哪个服务器上、以什么方式发送等信息；<br>　　2：发送状态，XMLHttpRequest开始发送数据；<br>　　3：数据传送状态，此时XMLHttpRequest正在接受从服务器端返回的数据，但是数据还没有传送完毕；<br>　　4：完成状态：此时XMLHttpRequest对象已经将从服务器端返回的数据接受完毕。<br>使用XMLHttpRequest对象的onreadystatechange属性，可以设置响应XMLHttpRequest对象状态变化的函数。设置回调函数时，不要在函数名后而加括号。加括号表示将回调函数的返回值注册给onreadystatechange属性。</p>
<h3 id="open方法设置和服务器端交互的信息"><a href="#open方法设置和服务器端交互的信息" class="headerlink" title="open方法设置和服务器端交互的信息"></a>open方法设置和服务器端交互的信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//创建http请求</div><div class="line">    xhr.open(&quot;get&quot;,&quot;Readme.txt&quot;, true);</div></pre></td></tr></table></figure>
<blockquote>
<p>请求根目录下存储用户名为Readme的txt文件,稍后利用它进行用户名的验证。</p>
</blockquote>
<p>XMLHttpRequest的open(method,URL,flag,name,password)方法用来初始化对象，前两个参数必选，后三个参数是可选。<br>method：指定用什么方式向服务器发送http请求，参数值可以是get，post，head，put和delete五种。<br>URL：指定服务器的URL，也就是用户处理和返回数据的程序的URL。该URL可以是绝对地址，也可以是相对地址。<br>flag：指定提交http请求的方式，true指异步方式，为默认值；false指同步方式。<br>name和password：如果服务器需要验证，这两个参数用来提交用户名和密码。</p>
<h3 id="设置发送的数据与服务器端开始交互。"><a href="#设置发送的数据与服务器端开始交互。" class="headerlink" title="设置发送的数据与服务器端开始交互。"></a>设置发送的数据与服务器端开始交互。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//发送http请求</div><div class="line">    xhr.send(null);</div></pre></td></tr></table></figure>
<p>发送http请求使用XMLHttpRequest的send(data)方法，data参数就是传递给open()方法中URL参数所指定的文件的参数。若果要传递多个参数，用”&amp;”来分隔，不需要传递参数写”null”。</p>
<h3 id="回调函数中判断交互是否结束"><a href="#回调函数中判断交互是否结束" class="headerlink" title="回调函数中判断交互是否结束"></a>回调函数中判断交互是否结束</h3><h4 id="判断异步调用是否成功："><a href="#判断异步调用是否成功：" class="headerlink" title="判断异步调用是否成功："></a>判断异步调用是否成功：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (xhr.readyState==4)//异步调用完毕</div><div class="line">&#123;</div><div class="line">    if (xhr.status==200 || xhr.status==0)&#123;&#125;//异步调用成功||在本机上调试</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>readyState属性值为4，说明异步调用完成，但并不代表异步调用执行成功。XMLHttpRequest的status属性可以获得从服务器返回的状态码。0代表不能理解的http状态，通常只有在本地计算机打开文件时才会返回。比较常用的http状态码有以下三个：<br>200：服务器成功返回网页。<br>404：客户端请求的网页不存在。<br>503：服务器响应超时。</p>
<h4 id="获得服务器返回的数据"><a href="#获得服务器返回的数据" class="headerlink" title="获得服务器返回的数据"></a>获得服务器返回的数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (xhr.readyState==4)</div><div class="line">&#123;</div><div class="line">    if (xhr.status==200 || xhr.status==0)&#123;</div><div class="line">        var Names = xhr.responseText;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>异步调用的最终目的是接收从服务器返回的数据，并根据该数据决定如何显示在客户端网页中。异步调用成功后，XMLHttpRequest对象通过使用以下4个属性来获得服务器返回的数据。<br>responseText：表示将服务器返回的数据以字符串形式返回。<br>responseXML：表示以XML的形式返回。<br>responseBody：表示以unsigned byte数组的形式返回。<br>responseStream：表示以IStream对象的形式返回。</p>
<h4 id="局部更新"><a href="#局部更新" class="headerlink" title="局部更新"></a>局部更新</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var OWarn = document.getElementById(&quot;Warn&quot;);</div><div class="line">if (Flag)</div><div class="line">&#123;</div><div class="line">    OWarn.innerHTML = &quot;您输入的用户名已存在，请重新输入！&quot;;</div><div class="line">    Form.Btn.disabled = true;//提交按钮不可用</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">    OWarn.innerHTML = &quot;合法用户名&quot;;</div><div class="line">    Form.Btn.disabled = false;//提交按钮可用</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取服务器返回的数据之后就要显示出来。Ajax通过DOM来完成局部更新数据。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p> 在ajax的编程中是必须对XMLHttpRequest进行上述的5步操作的，封装成一个具有复用性效果的方法，对我们的日常使用是非常来说是非常方便的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h2&gt;&lt;p&gt;Ajax的核心技术是XMLHttpRequest对象,它可以在不向服务器提交整个页面的情况下，实现局部更新网页。通过这个对象，Ajax可以像
    
    </summary>
    
    
      <category term="jsonp" scheme="http://upyang.com/tags/jsonp/"/>
    
      <category term="ajax" scheme="http://upyang.com/tags/ajax/"/>
    
      <category term="XMLHttpRequest" scheme="http://upyang.com/tags/XMLHttpRequest/"/>
    
  </entry>
  
  <entry>
    <title>原生js实现Ajax实例讲解(一)</title>
    <link href="http://upyang.com/2017/07/12/ajax/"/>
    <id>http://upyang.com/2017/07/12/ajax/</id>
    <published>2017-07-12T02:02:20.000Z</published>
    <updated>2017-07-16T14:44:18.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ajax简介"><a href="#Ajax简介" class="headerlink" title="Ajax简介"></a>Ajax简介</h2><ul>
<li>ajax = 异步 JavaScript 和 XML。</li>
<li>ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。我们知道，传统的网页（不使用ajax）如果需要更新内容，必须重新加载整个网页。Ajax的出现，使得使网可以实现异步更新，这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</li>
<li>注意：ajax本身不支持跨域请求，需要在服务器端处理。</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ul>
<li>ajax的技术核心是 XMLHttpRequest 对象。</li>
<li>ajax请求过程：创建XMLHttpRequest、连接服务器、发送请求、服务器做出响应、接收响应数据</li>
<li>图示：</li>
</ul>
<p><img src="http://www.runoob.com/images/ajax.gif"></p>
<h2 id="ajax与jsonp"><a href="#ajax与jsonp" class="headerlink" title="ajax与jsonp"></a>ajax与jsonp</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>从实现方式上来讲，ajax是通过创建XMLHttpRequest来获取<a href="http://www.upyang.com/2017/07/08/jsonp%E8%B7%A8%E5%9F%9F%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">同源</a>的数据。而jsonp是通过<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。</p>
<h3 id="jsonp产生原因"><a href="#jsonp产生原因" class="headerlink" title="jsonp产生原因"></a>jsonp产生原因</h3><p>　1. Ajax直接请求普通文件存在跨域无权限访问的问题（静态页、动态页、web服务、wcf只要是跨域请求一律不准）<br>　2. web的页面上调用js文件是不受跨域的影响（凡拥有src属性的标签都拥有跨域能力script img iframe）<br>　3. 可以判断 现在想通过纯web端(ActiveX控件、服务端代理、H5之Websocket等方式不算)跨域访问数据就只有一种可能，就是在远程服务器上设法把数据装进js格式的文件里，供客户度调用和进一步处理；<br>　4. json的纯字符数格式可以简洁的描述复杂数据还被js原生支持<br>　5. web客户端通过与调用脚本一样的方式来调用跨域服务器上动态生成的js格式文件(后缀.json)，服务器之所以要动态生成json文件目的把客户端需要的数据装入进去<br>　6. 客户端在对json文件调用成功后获得自己所需的数据剩下的就按照自己需求进行处理和展现，这种获取远程数据的方式非常像ajax其实并一样<br>　7. 为了方便客户端使用数据逐渐形成非正式传输协议jsonp</p>
<ul>
<li><p>其实，说到ajax就会面临两个不可避免的问题，<i style="color:red">一是以何种格式来减缓数据；二是如何解决跨域问题。</i>目前来说，所被推崇的方案是JSON作数据交换，JSONP来解决跨域问题。</p>
</li>
<li><p>JSON与JSONP虽然看上去只有一字之差，但是实际上根本不是一回事。JSON是一种key/value形式的数据格式，二JSONP则是一种跨域数据交互协议。</p>
</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li>题目：注册时，会要求输入用户名和密码，同时要验证用户名是否合法。</li>
<li>实现功能，用户在输入用户名后，需要给出提醒该名称是否已经存在。<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-12/37926292.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
</li>
</ul>
<h3 id="html文档结构"><a href="#html文档结构" class="headerlink" title="html文档结构"></a>html文档结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE HTML&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;title&gt;Ajax实例详解&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div class=&quot;reg&quot; style=&quot;margin-top: 50px;margin-left:100px;&quot;&gt;</div><div class="line">      &lt;p&gt;注册页(ajax检测用户名是否合法)&lt;/p&gt;</div><div class="line">      &lt;form name=&quot;Form&quot;&gt;</div><div class="line">      用户名: &lt;input type=&quot;text&quot; name=&quot;Name&quot; onblur=&quot;check()&quot;&gt;</div><div class="line">      &lt;span id=&quot;myDiv&quot;&gt;&lt;/span&gt;&lt;br&gt;</div><div class="line">      密　码: &lt;input type=&quot;text&quot; name=&quot;Password&quot;&gt;&lt;br&gt;</div><div class="line">      &lt;input type=&quot;button&quot; value=&quot; 提交&quot; name=&quot;Btn&quot; disabled=&quot;false&quot;&gt;</div><div class="line">    &lt;/form&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h3 id="JavaScript代码"><a href="#JavaScript代码" class="headerlink" title="JavaScript代码"></a>JavaScript代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    //初始化一个存储XMLHttpRequest对象的变量</div><div class="line">    var xhr = null;</div><div class="line">    //定义一个函数用来创建XMLHttpRequest对象,兼容各个版本</div><div class="line">    function CreatXHR()</div><div class="line">    &#123;</div><div class="line">        //判断浏览器是否支持ActiveX控件，针对IE6及之前版本</div><div class="line">        if (window.ActiveXObject)</div><div class="line">        &#123;</div><div class="line">            //将所有可能出现的ActiveXObject版本都放在一个数组中</div><div class="line">            var arrXHR = [&apos;Microsoft.XMLHTTP&apos;, &apos;MSXML2.XMLHTTP.6.0&apos;, &apos;MSXML2.XMLHTTP.5.0&apos;, &apos;MSXML2.XMLHTTP.4.0&apos;, &apos;MSXML2.XMLHTTP.3.0&apos;, &apos;MSXML2.XMLHTTP&apos;];</div><div class="line">            //通过循环创建XMLHttpRequest对象</div><div class="line">            var temp = arrXHR.length;</div><div class="line">            for (var i=0;i&lt;temp;i++)</div><div class="line">            &#123;</div><div class="line">                try</div><div class="line">                &#123;</div><div class="line">                    //创建XMLHttpRequest对象</div><div class="line">                    xhr = new ActiveXObject(arrXHR[i]);</div><div class="line">                    //如果创建XMLHttpRequest对象成功，则跳出循环</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                catch(ex)</div><div class="line">                &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //判断浏览器是否将XMLHttpRequest作为本地对象实现，针对IE7，Firefox，Opera等浏览器</div><div class="line">        else if(window.XMLHttpRequest)</div><div class="line">        &#123;</div><div class="line">            xhr = new XMLHttpRequest();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //响应XMLHttpRequest对象状态变化的函数</div><div class="line">    function httpStateChange()</div><div class="line">    &#123;</div><div class="line">        if (xhr.readyState==4)//异步调用完毕</div><div class="line">        &#123;</div><div class="line">            if (xhr.status==200 || xhr.status==0)//异步调用成功，在本机上调试</div><div class="line">            &#123;</div><div class="line">                //获得服务器返回的数据</div><div class="line">                var Names = xhr.responseText;</div><div class="line">                var arrName = Names.split(&quot;;&quot;);//把获取到的一个字符串分割成字符串数组。</div><div class="line"></div><div class="line">                //定义一个变量，用于判断用户名是否已经存在</div><div class="line">                var Flag = false;</div><div class="line"></div><div class="line">                for(i=0;i&lt;arrName.length;i++)</div><div class="line">                &#123;</div><div class="line">                    if (arrName[i]== Form.Name.value)</div><div class="line">                    &#123;</div><div class="line">                        Flag = true;//用户名存在</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                //合法性验证提醒</div><div class="line">                var OWarn = document.getElementById(&quot;Warn&quot;);</div><div class="line">                if (Flag)</div><div class="line">                &#123;</div><div class="line">                    OWarn.innerHTML = &quot;您输入的用户名已存在，请重新输入！&quot;;</div><div class="line">                    Form.Btn.disabled = true;//提交按钮不可用</div><div class="line">                &#125;</div><div class="line">                else</div><div class="line">                &#123;</div><div class="line">                    OWarn.innerHTML = &quot;合法用户名&quot;;</div><div class="line">                    Form.Btn.disabled = false;//提交按钮可用</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //校验用户名是否有效</div><div class="line">    function check()</div><div class="line">    &#123;</div><div class="line">        //创建XMLHttpRequest对象，调用前面定义好的函数</div><div class="line">        CreatXHR();</div><div class="line"></div><div class="line">        if (xhr!=null)</div><div class="line">        &#123;</div><div class="line">            //创建响应XMLHttpRequest对象状态变化的函数</div><div class="line">            xhr.onreadystatechange = httpStateChange;</div><div class="line">            //创建http请求</div><div class="line">            xhr.open(&quot;get&quot;,&quot;Readme.txt&quot;, true);</div><div class="line">            //发送http请求</div><div class="line">            xhr.send(null);</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            alert(&quot;您的浏览器不支持XMLHTTP&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p> 注意：需要在html同级目录下创建一个Reademe.txt文件来存储已经存在的用户名，多个用户名之间用分好隔开。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-12/4894833.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-12/22625927.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-12/1123101.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>可以复制代码亲自试看下效果哦！(建议Firefox下调试)<br>详细代码讲解请看下一章<a href="http://www.upyang.com/2017/07/12/ajax/" target="_blank" rel="external">通俗易懂Ajax实例讲解(二)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Ajax简介&quot;&gt;&lt;a href=&quot;#Ajax简介&quot; class=&quot;headerlink&quot; title=&quot;Ajax简介&quot;&gt;&lt;/a&gt;Ajax简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ajax = 异步 JavaScript 和 XML。&lt;/li&gt;
&lt;li&gt;ajax是一种在无需重
    
    </summary>
    
    
      <category term="jsonp" scheme="http://upyang.com/tags/jsonp/"/>
    
      <category term="ajax" scheme="http://upyang.com/tags/ajax/"/>
    
      <category term="XMLHttpRequest" scheme="http://upyang.com/tags/XMLHttpRequest/"/>
    
  </entry>
  
  <entry>
    <title>响应式网站设计</title>
    <link href="http://upyang.com/2017/07/09/Responsive-website/"/>
    <id>http://upyang.com/2017/07/09/Responsive-website/</id>
    <published>2017-07-09T06:35:42.000Z</published>
    <updated>2017-07-28T03:01:53.577Z</updated>
    
    <content type="html"><![CDATA[<div><br>    <div style="color: #061CC9;font-size: 30px;text-align: center;">响应式网站</div><br>    <div style="background: #FFFFFF;font-size: 17px;box-shadow: 0 15px 20px rgba(0,0,0,0.1);padding-left: 20px;padding-right: 20px;"><br>    👉 github: <a href="https://github.com/Aaron0525/Responsive-website" target="_blank" rel="external">https://github.com/Aaron0525/Responsive-website</a><br><br>    👉 演示地址: <a href="http://www.upyang.com/Responsive-website/" target="_blank" rel="external">http://www.upyang.com/Responsive-website/</a><br><br>    <font color="#0D3EA8"><strong>项目介绍</strong></font>：<p>&emsp;&emsp;响应式网站设计(Responsive Web design)的理念是：集中创建页面的图片排版大小，可以智能地根据用户行为以及使用的设备环境（系统平台、屏幕尺寸、屏幕定向等）进行相对应的布局。</p><font color="#0D3EA8"><strong>响应式布局要点</strong></font>：<br>    <p>&emsp;&emsp;一、媒体查询（media query）。媒体查询是响应式网页的核心，它能检测当前设备的宽度来选用不同的CSS样式文件。在写CSS样式时，从最小的设备开始写为好。</p><p>&emsp;&emsp;二、流式布局。它的特点就是百分比布局，相比采用具体尺寸的布局，百分比布局在用户缩放浏览器窗口时，不会出现内容被隐藏和出现横向滚动条。</p><p>&emsp;&emsp;三、弹性图片。　要让图片自适应缩放，一般使用css将图片的宽度设置成100%，这样就能使图片在布局中保持特定的比例。但随着浏览器的缩放，当图片的实际大小超过图片本身的大小时，图片就会变的模糊。有效的解决方案，就是及时替换成一张尺寸更大的图片。</p><font color="#0D3EA8"><strong>响应式布局优缺点</strong></font>：<br>    <p>&emsp;&emsp;优点：在不同终端、不同分辨率下有很强的适配性；只需一套代码，一定程度上节省了开发和维护的成本。缺点：兼容各种设备工作量大，效率低下；代码累赘，会出现隐藏无用的元素，加载时间加长。</p><p>&emsp;&emsp;所以响应式布局不适合数据量大，操作复杂的网站，适用于博客、中小型企业网站等。</p><br>    </div><br></div>
]]></content>
    
    <summary type="html">
    
      &lt;div&gt;&lt;br&gt;    &lt;div style=&quot;color: #061CC9;font-size: 30px;text-align: center;&quot;&gt;响应式网站&lt;/div&gt;&lt;br&gt;    &lt;div style=&quot;background: #FFFFFF;font-size: 1
    
    </summary>
    
    
      <category term="HTML5" scheme="http://upyang.com/tags/HTML5/"/>
    
      <category term="CSS3" scheme="http://upyang.com/tags/CSS3/"/>
    
      <category term="media" scheme="http://upyang.com/tags/media/"/>
    
  </entry>
  
  <entry>
    <title>jsonp跨域实现</title>
    <link href="http://upyang.com/2017/07/08/jsonp%E8%B7%A8%E5%9F%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://upyang.com/2017/07/08/jsonp跨域实现/</id>
    <published>2017-07-08T10:57:30.000Z</published>
    <updated>2017-07-09T15:25:11.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于JavaScript代码能够访问的页面内容做了很重要的限制，即JavaScript只能访问与包含它的文档在同一域下的内容。（图片来自MDN）</p>
<p><img src="http://img.blog.csdn.net/20170507170944865?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上用标签引入<code>&lt;script&gt;</code>不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。</p>
<li>jsonp的客户端实现</li>

<p>tocat服务器上有个remote.js（这里用tocat，web项目演示）</p>
<p><img src="http://img.blog.csdn.net/20170507182922130?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p><code>alert(&quot;跨域成功&quot;);</code><br>　　<li>本地index.html文件</li></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;title&gt;跨域资源&lt;/title&gt;</div><div class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;</div><div class="line">/* 完成跨域 */</div><div class="line">&lt;script src=&quot;http://localhost:8080/web/js/remote.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20170507182807316?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p>　　很明显，显示跨域成功</p>
<li>接下来我们在本地index.html定义callback函数 ，然后远程tomcat.js传入回调数据</li>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;跨域资源&lt;/title&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;</div><div class="line">    /* 完成跨域 */</div><div class="line">     &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">         window.onload = function() &#123;</div><div class="line">         var callback = function(data) &#123;</div><div class="line">            alert(&quot;跨域调用远程tomcat.js成功: &quot; + data.name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">    &lt;script src=&quot;http://localhost:8080/web/js/tomcat.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>远程服务器：</p>
<p>tomcat.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">callback(&#123;&quot;name&quot;:&quot;kk&quot;&#125;);</div></pre></td></tr></table></figure>
<p>到此，跨域基本实现，但是这里有个问题，<i style="color:red">远程站点怎么知道要调用哪个callback呢？</i></p>
<p>所以就有了jsonp的核心：服务端提供的callback是动态生成的， 本地只要动态传一个callback给服务端，服务端就知道该调用哪个了</p>
<p>像这样：<br>客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;跨域资源&lt;/title&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    window.onload = function() &#123;</div><div class="line">        var callback = function(data) &#123;</div><div class="line">            alert(&quot;跨域调用远程成功: &quot; + data.name);</div><div class="line">        &#125;</div><div class="line">        var url = &quot;http://localhost:8080/web/js/helloServlet?userid=1&amp;callback=callback&quot;;</div><div class="line">        // 创建script标签，设置其属性</div><div class="line">        var script = document.createElement(&apos;script&apos;);</div><div class="line">        script.setAttribute(&apos;src&apos;, url);</div><div class="line">        // 把script标签加入head，此时调用开始</div><div class="line">        document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);</div><div class="line">    &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>服务端：（这里选用java解释）<br>// 从客户端获取参数userid和callback<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PrintWriter out =response.getWriter();</div></pre></td></tr></table></figure></p>
<p>// 根据userid查找到的数据存储为json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">out.println(callback+&quot;(&quot;+json+&quot;)&quot;);</div></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20170507191945153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p>jsonp的执行全过程就是这么回事了（个人理解）</p>
<li>现在再来看JQuery中的实现，我们最经常用的$.ajax，似乎通透了不少，也就是这么回事<br></li>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$(function() &#123;</div><div class="line">        $.ajax(&#123;</div><div class="line">            async: false,</div><div class="line">            url: http, //跨域url地址</div><div class="line">            type: &quot;GET&quot;,</div><div class="line">            dataType: &apos;jsonp&apos;,</div><div class="line">            jsonp: &apos;jsoncallback&apos;,</div><div class="line">            data: &#123;</div><div class="line">                &quot;userid&quot;: &quot;1&quot;</div><div class="line">            &#125;,</div><div class="line">            timeout: 5000,</div><div class="line">            beforeSend: function() &#123;</div><div class="line">                //jsonp 方式此方法不被触发.原因可能是dataType如果指定为jsonp的话,就已经不是ajax事件了</div><div class="line">            &#125;,</div><div class="line">            success: function(json) &#123; //客户端jquery预先定义好的callback函数,成功获取跨域服务器上的json数据后,会动态执行这个callback函数</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            error: function(xhr) &#123;</div><div class="line">                //jsonp 方式此方法不被触发.原因是:dataType如果指定为jsonp的话,就已经不是ajax事件了</div><div class="line">                //请求出错处理</div><div class="line">                alert(&quot;请求出错(请检查相关度网络状况.)&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>这里发现，$.ajax和ajax并不是一回事啊,ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。</p>
<h1 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h1><p>注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。<br>实例：<br>假设有三个页面：<br><a href="http://a.com/a.html" target="_blank" rel="external">http://a.com/a.html</a>  //渴望获得数据的页面<br><a href="http://a.com/b.html" target="_blank" rel="external">http://a.com/b.html</a>  //a的兄弟页面，充当中间人角色<br><a href="http://b.com/data.html" target="_blank" rel="external">http://b.com/data.html</a> //不同源的数据页</p>
<li><a href="http://a.com/a.html,监听iframe的onload事件，在此事件中设置这个iframe的src指向本地域的代理页面http://a.com/b.html（代理文件和应用页面在同一域下，所以可以相互通信）" target="_blank" rel="external">http://a.com/a.html,监听iframe的onload事件，在此事件中设置这个iframe的src指向本地域的代理页面http://a.com/b.html（代理文件和应用页面在同一域下，所以可以相互通信）</a><br>动态创建iframe</li>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line"></div><div class="line">var state = 0,</div><div class="line">    iframe = document.createElement(&apos;iframe&apos;);</div><div class="line"></div><div class="line">// 通过iframe的src与data.html通信</div><div class="line">iframe.src = &apos;http://b.com/data.html&apos;;</div><div class="line"></div><div class="line">//监听onload</div><div class="line">if (iframe.attachEvent) &#123;</div><div class="line">    iframe.attachEvent(&apos;onload&apos;, loadfn);</div><div class="line">&#125; else &#123;</div><div class="line">    iframe.onload = loadfn;</div><div class="line"></div><div class="line">var loadfn = function() &#123;</div><div class="line">        if (state === 0) &#123;</div><div class="line">            state = 1;</div><div class="line">            iframe.contentWindow.location = &quot;http://a.com/b.html&quot;; // 设置的代理页面</div><div class="line">        &#125;</div><div class="line">        else if (state === 1) &#123;</div><div class="line">            var data = iframe.contentWindow.name; // 读取数据</div><div class="line">            alert(data); //弹出&apos;data.html!&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&lt;/script&gt;</div><div class="line">  ● http://b.com/data.html</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    window.name = &apos;data.html&apos;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这样就可以成功解决了，理一下思路，应该是这样:<br>充当中间人的iframe想要获取到data.html的通过window.name设置的数据，只需要把这个iframe的src设为www.cnblogs.com/data.html就行了。然后a.html想要得到iframe所获取到的数据，也就是想要得到iframe的window.name的值，还必须把这个iframe的src设成跟a.html页面同一个域才行</p>
<p>图示：<br><img src="http://img.blog.csdn.net/20170507203413041?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h1 id="HTML5中新引进的window-postMessage方法"><a href="#HTML5中新引进的window-postMessage方法" class="headerlink" title="HTML5中新引进的window.postMessage方法"></a>HTML5中新引进的window.postMessage方法</h1><p>在HTML5中新增了postMessage方法，postMessage可以实现跨文档消息传输（Cross Document Messaging），Internet Explorer 8, Firefox 3, Opera 9, Chrome 3和 Safari 4都支持postMessage。<br>实现：<br>发送信息的页面<a href="http://a.com/a.html" target="_blank" rel="external">http://a.com/a.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line"></div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;客户端&lt;/title&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    window.onload = function() &#123;</div><div class="line">        window.frames[0].postMessage(&apos;data&apos;, &apos;http://b.com/data.html&apos;);</div><div class="line">        //postMessage接收两个参数，第一个数据，第二个字符串参数，指明目标窗口的源，具体看MDN</div><div class="line">    &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">    &lt;iframe id=&quot;child&quot; src=&quot;http://b.com/data.html&quot;&gt;&lt;/iframe&gt;</div><div class="line">&lt;/body&gt;</div><div class="line"></div><div class="line">&lt;/html&gt;</div><div class="line">接收信息的页面http://b.com/data.html</div><div class="line">// 通过监听message事件获取数据</div><div class="line">window.addEventListener(&apos;message&apos;,function(e)&#123;</div><div class="line">                var e =e||event;</div><div class="line">                alert(e.data);</div><div class="line">            &#125;,false);</div></pre></td></tr></table></figure></p>
<p>图示：<br><img src="http://img.blog.csdn.net/20170507211511202?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h1 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h1><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>　　整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。<br>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。具体原理参见MDN</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h1&gt;&lt;p&gt;在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于
    
    </summary>
    
    
      <category term="HTML5" scheme="http://upyang.com/tags/HTML5/"/>
    
      <category term="JavaScript" scheme="http://upyang.com/tags/JavaScript/"/>
    
      <category term="Jsonp" scheme="http://upyang.com/tags/Jsonp/"/>
    
      <category term="CORS" scheme="http://upyang.com/tags/CORS/"/>
    
  </entry>
  
</feed>
