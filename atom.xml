<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>途中人的博客</title>
  <subtitle>IT技术分享！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-09T15:25:11.436Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>途中人</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jsonp跨域实现</title>
    <link href="http://yoursite.com/2017/07/08/jsonp%E8%B7%A8%E5%9F%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2017/07/08/jsonp跨域实现/</id>
    <published>2017-07-08T10:57:30.000Z</published>
    <updated>2017-07-09T15:25:11.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于JavaScript代码能够访问的页面内容做了很重要的限制，即JavaScript只能访问与包含它的文档在同一域下的内容。（图片来自MDN）</p>
<p><img src="http://img.blog.csdn.net/20170507170944865?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上用标签引入<code>&lt;script&gt;</code>不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。</p>
<li>jsonp的客户端实现</li>

<p>tocat服务器上有个remote.js（这里用tocat，web项目演示）</p>
<p><img src="http://img.blog.csdn.net/20170507182922130?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p><code>alert(&quot;跨域成功&quot;);</code><br>　　<li>本地index.html文件</li></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;title&gt;跨域资源&lt;/title&gt;</div><div class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;</div><div class="line">/* 完成跨域 */</div><div class="line">&lt;script src=&quot;http://localhost:8080/web/js/remote.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20170507182807316?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p>　　很明显，显示跨域成功</p>
<li>接下来我们在本地index.html定义callback函数 ，然后远程tomcat.js传入回调数据</li>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;跨域资源&lt;/title&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;</div><div class="line">    /* 完成跨域 */</div><div class="line">     &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">         window.onload = function() &#123;</div><div class="line">         var callback = function(data) &#123;</div><div class="line">            alert(&quot;跨域调用远程tomcat.js成功: &quot; + data.name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">    &lt;script src=&quot;http://localhost:8080/web/js/tomcat.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>远程服务器：</p>
<p>tomcat.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">callback(&#123;&quot;name&quot;:&quot;kk&quot;&#125;);</div></pre></td></tr></table></figure>
<p>到此，跨域基本实现，但是这里有个问题，<i style="color:red">远程站点怎么知道要调用哪个callback呢？</i></p>
<p>所以就有了jsonp的核心：服务端提供的callback是动态生成的， 本地只要动态传一个callback给服务端，服务端就知道该调用哪个了</p>
<p>像这样：<br>客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;跨域资源&lt;/title&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    window.onload = function() &#123;</div><div class="line">        var callback = function(data) &#123;</div><div class="line">            alert(&quot;跨域调用远程成功: &quot; + data.name);</div><div class="line">        &#125;</div><div class="line">        var url = &quot;http://localhost:8080/web/js/helloServlet?userid=1&amp;callback=callback&quot;;</div><div class="line">        // 创建script标签，设置其属性</div><div class="line">        var script = document.createElement(&apos;script&apos;);</div><div class="line">        script.setAttribute(&apos;src&apos;, url);</div><div class="line">        // 把script标签加入head，此时调用开始</div><div class="line">        document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);</div><div class="line">    &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>服务端：（这里选用java解释）<br>// 从客户端获取参数userid和callback<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PrintWriter out =response.getWriter();</div></pre></td></tr></table></figure></p>
<p>// 根据userid查找到的数据存储为json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">out.println(callback+&quot;(&quot;+json+&quot;)&quot;);</div></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20170507191945153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p>jsonp的执行全过程就是这么回事了（个人理解）</p>
<li>现在再来看JQuery中的实现，我们最经常用的$.ajax，似乎通透了不少，也就是这么回事<br></li>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$(function() &#123;</div><div class="line">        $.ajax(&#123;</div><div class="line">            async: false,</div><div class="line">            url: http, //跨域url地址</div><div class="line">            type: &quot;GET&quot;,</div><div class="line">            dataType: &apos;jsonp&apos;,</div><div class="line">            jsonp: &apos;jsoncallback&apos;,</div><div class="line">            data: &#123;</div><div class="line">                &quot;userid&quot;: &quot;1&quot;</div><div class="line">            &#125;,</div><div class="line">            timeout: 5000,</div><div class="line">            beforeSend: function() &#123;</div><div class="line">                //jsonp 方式此方法不被触发.原因可能是dataType如果指定为jsonp的话,就已经不是ajax事件了</div><div class="line">            &#125;,</div><div class="line">            success: function(json) &#123; //客户端jquery预先定义好的callback函数,成功获取跨域服务器上的json数据后,会动态执行这个callback函数</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            error: function(xhr) &#123;</div><div class="line">                //jsonp 方式此方法不被触发.原因是:dataType如果指定为jsonp的话,就已经不是ajax事件了</div><div class="line">                //请求出错处理</div><div class="line">                alert(&quot;请求出错(请检查相关度网络状况.)&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>这里发现，$.ajax和ajax并不是一回事啊,ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。</p>
<h1 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h1><p>注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。<br>实例：<br>假设有三个页面：<br><a href="http://a.com/a.html" target="_blank" rel="external">http://a.com/a.html</a>  //渴望获得数据的页面<br><a href="http://a.com/b.html" target="_blank" rel="external">http://a.com/b.html</a>  //a的兄弟页面，充当中间人角色<br><a href="http://b.com/data.html" target="_blank" rel="external">http://b.com/data.html</a> //不同源的数据页</p>
<li><a href="http://a.com/a.html,监听iframe的onload事件，在此事件中设置这个iframe的src指向本地域的代理页面http://a.com/b.html（代理文件和应用页面在同一域下，所以可以相互通信）" target="_blank" rel="external">http://a.com/a.html,监听iframe的onload事件，在此事件中设置这个iframe的src指向本地域的代理页面http://a.com/b.html（代理文件和应用页面在同一域下，所以可以相互通信）</a><br>动态创建iframe</li>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line"></div><div class="line">var state = 0,</div><div class="line">    iframe = document.createElement(&apos;iframe&apos;);</div><div class="line"></div><div class="line">// 通过iframe的src与data.html通信</div><div class="line">iframe.src = &apos;http://b.com/data.html&apos;;</div><div class="line"></div><div class="line">//监听onload</div><div class="line">if (iframe.attachEvent) &#123;</div><div class="line">    iframe.attachEvent(&apos;onload&apos;, loadfn);</div><div class="line">&#125; else &#123;</div><div class="line">    iframe.onload = loadfn;</div><div class="line"></div><div class="line">var loadfn = function() &#123;</div><div class="line">        if (state === 0) &#123;</div><div class="line">            state = 1;</div><div class="line">            iframe.contentWindow.location = &quot;http://a.com/b.html&quot;; // 设置的代理页面</div><div class="line">        &#125;</div><div class="line">        else if (state === 1) &#123;</div><div class="line">            var data = iframe.contentWindow.name; // 读取数据</div><div class="line">            alert(data); //弹出&apos;data.html!&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&lt;/script&gt;</div><div class="line">  ● http://b.com/data.html</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    window.name = &apos;data.html&apos;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这样就可以成功解决了，理一下思路，应该是这样:<br>充当中间人的iframe想要获取到data.html的通过window.name设置的数据，只需要把这个iframe的src设为www.cnblogs.com/data.html就行了。然后a.html想要得到iframe所获取到的数据，也就是想要得到iframe的window.name的值，还必须把这个iframe的src设成跟a.html页面同一个域才行</p>
<p>图示：<br><img src="http://img.blog.csdn.net/20170507203413041?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h1 id="HTML5中新引进的window-postMessage方法"><a href="#HTML5中新引进的window-postMessage方法" class="headerlink" title="HTML5中新引进的window.postMessage方法"></a>HTML5中新引进的window.postMessage方法</h1><p>在HTML5中新增了postMessage方法，postMessage可以实现跨文档消息传输（Cross Document Messaging），Internet Explorer 8, Firefox 3, Opera 9, Chrome 3和 Safari 4都支持postMessage。<br>实现：<br>发送信息的页面<a href="http://a.com/a.html" target="_blank" rel="external">http://a.com/a.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line"></div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;客户端&lt;/title&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    window.onload = function() &#123;</div><div class="line">        window.frames[0].postMessage(&apos;data&apos;, &apos;http://b.com/data.html&apos;);</div><div class="line">        //postMessage接收两个参数，第一个数据，第二个字符串参数，指明目标窗口的源，具体看MDN</div><div class="line">    &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">    &lt;iframe id=&quot;child&quot; src=&quot;http://b.com/data.html&quot;&gt;&lt;/iframe&gt;</div><div class="line">&lt;/body&gt;</div><div class="line"></div><div class="line">&lt;/html&gt;</div><div class="line">接收信息的页面http://b.com/data.html</div><div class="line">// 通过监听message事件获取数据</div><div class="line">window.addEventListener(&apos;message&apos;,function(e)&#123;</div><div class="line">                var e =e||event;</div><div class="line">                alert(e.data);</div><div class="line">            &#125;,false);</div></pre></td></tr></table></figure></p>
<p>图示：<br><img src="http://img.blog.csdn.net/20170507211511202?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h1 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h1><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>　　整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。<br>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。具体原理参见MDN</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h1&gt;&lt;p&gt;在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="Jsonp" scheme="http://yoursite.com/tags/Jsonp/"/>
    
      <category term="HTML5" scheme="http://yoursite.com/tags/HTML5/"/>
    
      <category term="CORS" scheme="http://yoursite.com/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/07/07/hello-world/"/>
    <id>http://yoursite.com/2017/07/07/hello-world/</id>
    <published>2017-07-07T08:00:29.363Z</published>
    <updated>2017-07-07T08:00:29.363Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
