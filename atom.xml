<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>途中人的博客</title>
  <subtitle>IT技术分享！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://upyang.com/"/>
  <updated>2017-07-22T14:14:23.836Z</updated>
  <id>http://upyang.com/</id>
  
  <author>
    <name>途中人</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue学习</title>
    <link href="http://upyang.com/2017/07/21/Vue%E5%AD%A6%E4%B9%A0/"/>
    <id>http://upyang.com/2017/07/21/Vue学习/</id>
    <published>2017-07-21T15:28:51.000Z</published>
    <updated>2017-07-22T14:14:23.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　最近一段时间一直在学习Vue2.0的相关知识，之前只是看过相关的视频教学，但是一直没有动手去实践自己的项目，这次决定用Vue2.0去模仿一个移动端App,看了很多自己用过的App,最后决定模仿做掘金移动端App,恰好这款App也是用Vue做的。写下这篇博客，记录实践中的新的体会。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>首先直观的看下掘金App的基本页面构成：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-22/81795026.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>可以看到掘金App主要分为四个大页面，</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　最近一段时间一直在学习Vue2.0的相关知识，之前只是看过相关的视频教学，但是一直没有动手去实践自己的项目，这次决定用Vue2.0去模仿
    
    </summary>
    
    
      <category term="Vue2.0" scheme="http://upyang.com/tags/Vue2-0/"/>
    
      <category term="ES6" scheme="http://upyang.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>原生js实现Ajax实例讲解(二)</title>
    <link href="http://upyang.com/2017/07/12/ajax2/"/>
    <id>http://upyang.com/2017/07/12/ajax2/</id>
    <published>2017-07-12T14:30:38.000Z</published>
    <updated>2017-07-16T14:43:11.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>Ajax的核心技术是XMLHttpRequest对象,它可以在不向服务器提交整个页面的情况下，实现局部更新网页。通过这个对象，Ajax可以像桌面应用程序那样只与服务器进行数据层的交换，而不必每次都刷新界面，也不必每次将数据处理的工作都交给服务器来做。这样既减轻了服务器负担又提高了响应速度，还缩短了用户的等待时间。通常一个Ajax的实现过程有五步，下面我们以<a href="http://www.upyang.com/2017/07/12/ajax/" target="_blank" rel="external">上篇博客中的小实例</a>为例来逐步学习。</p>
<h2 id="XMLHttpRequest对象的五步使用法"><a href="#XMLHttpRequest对象的五步使用法" class="headerlink" title="XMLHttpRequest对象的五步使用法"></a>XMLHttpRequest对象的五步使用法</h2><h3 id="创建XMLHttpRequest对象。"><a href="#创建XMLHttpRequest对象。" class="headerlink" title="创建XMLHttpRequest对象。"></a>创建XMLHttpRequest对象。</h3><p>IE浏览器将XMLHttpRequest实现为一个ActiveX对象，其他浏览器如Firefox，Opera，Netscape等将其实现为一个本地JavaScript对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function CreatXHR()</div><div class="line">    &#123;</div><div class="line">        //判断浏览器是否支持ActiveX控件，针对IE6及之前版本</div><div class="line">        if (window.ActiveXObject)</div><div class="line">        &#123;</div><div class="line">            //将所有可能出现的ActiveXObject版本都放在一个数组中</div><div class="line">            var arrXHR = [&apos;Microsoft.XMLHTTP&apos;, &apos;MSXML2.XMLHTTP.6.0&apos;, &apos;MSXML2.XMLHTTP.5.0&apos;, &apos;MSXML2.XMLHTTP.4.0&apos;, &apos;MSXML2.XMLHTTP.3.0&apos;, &apos;MSXML2.XMLHTTP&apos;];</div><div class="line">            //通过循环创建XMLHttpRequest对象</div><div class="line">            var temp = arrXHR.length;</div><div class="line">            for (var i=0;i&lt;temp;i++)</div><div class="line">            &#123;</div><div class="line">                try</div><div class="line">                &#123;</div><div class="line">                    //创建XMLHttpRequest对象</div><div class="line">                    xhr = new ActiveXObject(arrXHR[i]);</div><div class="line">                    //如果创建XMLHttpRequest对象成功，则跳出循环</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                catch(ex)</div><div class="line">                &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //判断浏览器是否将XMLHttpRequest作为本地对象实现，针对IE7，Firefox，Opera等浏览器</div><div class="line">        else if(window.XMLHttpRequest)</div><div class="line">        &#123;</div><div class="line">            xhr = new XMLHttpRequest();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//创建XMLHttpRequest对象，调用前面定义好的函数</div><div class="line">    creatXMLHTTP();</div><div class="line">    if (xhr!=null)</div><div class="line">    &#123;</div><div class="line">        //创建响应XMLHttpRequest对象状态变化的函数</div><div class="line"></div><div class="line">        //创建http请求</div><div class="line"></div><div class="line">        //发送http请求</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        alert(&quot;您的浏览器不支持XMLHTTP&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="注册回调函数"><a href="#注册回调函数" class="headerlink" title="注册回调函数"></a>注册回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//创建响应XMLHttpRequest对象状态变化的函数</div><div class="line">    xhr.onreadystatechange = httpStateChange;</div></pre></td></tr></table></figure>
<p>在异步调用时，XMLHttpRequest对象有几个不同的状态，这些状态表示了异步调用的过程。<br>　　0：未初始化状态，刚创建完一个XMLHttpRequest对象；<br>　　1：初始化状态，即XMLHttpRequest对象已经获得了要将数据发送到哪个服务器上、以什么方式发送等信息；<br>　　2：发送状态，XMLHttpRequest开始发送数据；<br>　　3：数据传送状态，此时XMLHttpRequest正在接受从服务器端返回的数据，但是数据还没有传送完毕；<br>　　4：完成状态：此时XMLHttpRequest对象已经将从服务器端返回的数据接受完毕。<br>使用XMLHttpRequest对象的onreadystatechange属性，可以设置响应XMLHttpRequest对象状态变化的函数。设置回调函数时，不要在函数名后而加括号。加括号表示将回调函数的返回值注册给onreadystatechange属性。</p>
<h3 id="open方法设置和服务器端交互的信息"><a href="#open方法设置和服务器端交互的信息" class="headerlink" title="open方法设置和服务器端交互的信息"></a>open方法设置和服务器端交互的信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//创建http请求</div><div class="line">    xhr.open(&quot;get&quot;,&quot;Readme.txt&quot;, true);</div></pre></td></tr></table></figure>
<blockquote>
<p>请求根目录下存储用户名为Readme的txt文件,稍后利用它进行用户名的验证。</p>
</blockquote>
<p>XMLHttpRequest的open(method,URL,flag,name,password)方法用来初始化对象，前两个参数必选，后三个参数是可选。<br>method：指定用什么方式向服务器发送http请求，参数值可以是get，post，head，put和delete五种。<br>URL：指定服务器的URL，也就是用户处理和返回数据的程序的URL。该URL可以是绝对地址，也可以是相对地址。<br>flag：指定提交http请求的方式，true指异步方式，为默认值；false指同步方式。<br>name和password：如果服务器需要验证，这两个参数用来提交用户名和密码。</p>
<h3 id="设置发送的数据与服务器端开始交互。"><a href="#设置发送的数据与服务器端开始交互。" class="headerlink" title="设置发送的数据与服务器端开始交互。"></a>设置发送的数据与服务器端开始交互。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//发送http请求</div><div class="line">    xhr.send(null);</div></pre></td></tr></table></figure>
<p>发送http请求使用XMLHttpRequest的send(data)方法，data参数就是传递给open()方法中URL参数所指定的文件的参数。若果要传递多个参数，用”&amp;”来分隔，不需要传递参数写”null”。</p>
<h3 id="回调函数中判断交互是否结束"><a href="#回调函数中判断交互是否结束" class="headerlink" title="回调函数中判断交互是否结束"></a>回调函数中判断交互是否结束</h3><h4 id="判断异步调用是否成功："><a href="#判断异步调用是否成功：" class="headerlink" title="判断异步调用是否成功："></a>判断异步调用是否成功：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (xhr.readyState==4)//异步调用完毕</div><div class="line">&#123;</div><div class="line">    if (xhr.status==200 || xhr.status==0)&#123;&#125;//异步调用成功||在本机上调试</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>readyState属性值为4，说明异步调用完成，但并不代表异步调用执行成功。XMLHttpRequest的status属性可以获得从服务器返回的状态码。0代表不能理解的http状态，通常只有在本地计算机打开文件时才会返回。比较常用的http状态码有以下三个：<br>200：服务器成功返回网页。<br>404：客户端请求的网页不存在。<br>503：服务器响应超时。</p>
<h4 id="获得服务器返回的数据"><a href="#获得服务器返回的数据" class="headerlink" title="获得服务器返回的数据"></a>获得服务器返回的数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (xhr.readyState==4)</div><div class="line">&#123;</div><div class="line">    if (xhr.status==200 || xhr.status==0)&#123;</div><div class="line">        var Names = xhr.responseText;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>异步调用的最终目的是接收从服务器返回的数据，并根据该数据决定如何显示在客户端网页中。异步调用成功后，XMLHttpRequest对象通过使用以下4个属性来获得服务器返回的数据。<br>responseText：表示将服务器返回的数据以字符串形式返回。<br>responseXML：表示以XML的形式返回。<br>responseBody：表示以unsigned byte数组的形式返回。<br>responseStream：表示以IStream对象的形式返回。</p>
<h4 id="局部更新"><a href="#局部更新" class="headerlink" title="局部更新"></a>局部更新</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var OWarn = document.getElementById(&quot;Warn&quot;);</div><div class="line">if (Flag)</div><div class="line">&#123;</div><div class="line">    OWarn.innerHTML = &quot;您输入的用户名已存在，请重新输入！&quot;;</div><div class="line">    Form.Btn.disabled = true;//提交按钮不可用</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">    OWarn.innerHTML = &quot;合法用户名&quot;;</div><div class="line">    Form.Btn.disabled = false;//提交按钮可用</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取服务器返回的数据之后就要显示出来。Ajax通过DOM来完成局部更新数据。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p> 在ajax的编程中是必须对XMLHttpRequest进行上述的5步操作的，封装成一个具有复用性效果的方法，对我们的日常使用是非常来说是非常方便的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h2&gt;&lt;p&gt;Ajax的核心技术是XMLHttpRequest对象,它可以在不向服务器提交整个页面的情况下，实现局部更新网页。通过这个对象，Ajax可以像
    
    </summary>
    
    
      <category term="ajax" scheme="http://upyang.com/tags/ajax/"/>
    
      <category term="XMLHttpRequest" scheme="http://upyang.com/tags/XMLHttpRequest/"/>
    
      <category term="jsonp" scheme="http://upyang.com/tags/jsonp/"/>
    
  </entry>
  
  <entry>
    <title>原生js实现Ajax实例讲解(一)</title>
    <link href="http://upyang.com/2017/07/12/ajax/"/>
    <id>http://upyang.com/2017/07/12/ajax/</id>
    <published>2017-07-12T02:02:20.000Z</published>
    <updated>2017-07-16T14:44:18.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ajax简介"><a href="#Ajax简介" class="headerlink" title="Ajax简介"></a>Ajax简介</h2><ul>
<li>ajax = 异步 JavaScript 和 XML。</li>
<li>ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。我们知道，传统的网页（不使用ajax）如果需要更新内容，必须重新加载整个网页。Ajax的出现，使得使网可以实现异步更新，这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</li>
<li>注意：ajax本身不支持跨域请求，需要在服务器端处理。</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ul>
<li>ajax的技术核心是 XMLHttpRequest 对象。</li>
<li>ajax请求过程：创建XMLHttpRequest、连接服务器、发送请求、服务器做出响应、接收响应数据</li>
<li>图示：</li>
</ul>
<p><img src="http://www.runoob.com/images/ajax.gif"></p>
<h2 id="ajax与jsonp"><a href="#ajax与jsonp" class="headerlink" title="ajax与jsonp"></a>ajax与jsonp</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>从实现方式上来讲，ajax是通过创建XMLHttpRequest来获取<a href="http://www.upyang.com/2017/07/08/jsonp%E8%B7%A8%E5%9F%9F%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">同源</a>的数据。而jsonp是通过<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。</p>
<h3 id="jsonp产生原因"><a href="#jsonp产生原因" class="headerlink" title="jsonp产生原因"></a>jsonp产生原因</h3><p>　1. Ajax直接请求普通文件存在跨域无权限访问的问题（静态页、动态页、web服务、wcf只要是跨域请求一律不准）<br>　2. web的页面上调用js文件是不受跨域的影响（凡拥有src属性的标签都拥有跨域能力script img iframe）<br>　3. 可以判断 现在想通过纯web端(ActiveX控件、服务端代理、H5之Websocket等方式不算)跨域访问数据就只有一种可能，就是在远程服务器上设法把数据装进js格式的文件里，供客户度调用和进一步处理；<br>　4. json的纯字符数格式可以简洁的描述复杂数据还被js原生支持<br>　5. web客户端通过与调用脚本一样的方式来调用跨域服务器上动态生成的js格式文件(后缀.json)，服务器之所以要动态生成json文件目的把客户端需要的数据装入进去<br>　6. 客户端在对json文件调用成功后获得自己所需的数据剩下的就按照自己需求进行处理和展现，这种获取远程数据的方式非常像ajax其实并一样<br>　7. 为了方便客户端使用数据逐渐形成非正式传输协议jsonp</p>
<ul>
<li><p>其实，说到ajax就会面临两个不可避免的问题，<i style="color:red">一是以何种格式来减缓数据；二是如何解决跨域问题。</i>目前来说，所被推崇的方案是JSON作数据交换，JSONP来解决跨域问题。</p>
</li>
<li><p>JSON与JSONP虽然看上去只有一字之差，但是实际上根本不是一回事。JSON是一种key/value形式的数据格式，二JSONP则是一种跨域数据交互协议。</p>
</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li>题目：注册时，会要求输入用户名和密码，同时要验证用户名是否合法。</li>
<li>实现功能，用户在输入用户名后，需要给出提醒该名称是否已经存在。<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-12/37926292.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
</li>
</ul>
<h3 id="html文档结构"><a href="#html文档结构" class="headerlink" title="html文档结构"></a>html文档结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE HTML&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;title&gt;Ajax实例详解&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div class=&quot;reg&quot; style=&quot;margin-top: 50px;margin-left:100px;&quot;&gt;</div><div class="line">      &lt;p&gt;注册页(ajax检测用户名是否合法)&lt;/p&gt;</div><div class="line">      &lt;form name=&quot;Form&quot;&gt;</div><div class="line">      用户名: &lt;input type=&quot;text&quot; name=&quot;Name&quot; onblur=&quot;check()&quot;&gt;</div><div class="line">      &lt;span id=&quot;myDiv&quot;&gt;&lt;/span&gt;&lt;br&gt;</div><div class="line">      密　码: &lt;input type=&quot;text&quot; name=&quot;Password&quot;&gt;&lt;br&gt;</div><div class="line">      &lt;input type=&quot;button&quot; value=&quot; 提交&quot; name=&quot;Btn&quot; disabled=&quot;false&quot;&gt;</div><div class="line">    &lt;/form&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h3 id="JavaScript代码"><a href="#JavaScript代码" class="headerlink" title="JavaScript代码"></a>JavaScript代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    //初始化一个存储XMLHttpRequest对象的变量</div><div class="line">    var xhr = null;</div><div class="line">    //定义一个函数用来创建XMLHttpRequest对象,兼容各个版本</div><div class="line">    function CreatXHR()</div><div class="line">    &#123;</div><div class="line">        //判断浏览器是否支持ActiveX控件，针对IE6及之前版本</div><div class="line">        if (window.ActiveXObject)</div><div class="line">        &#123;</div><div class="line">            //将所有可能出现的ActiveXObject版本都放在一个数组中</div><div class="line">            var arrXHR = [&apos;Microsoft.XMLHTTP&apos;, &apos;MSXML2.XMLHTTP.6.0&apos;, &apos;MSXML2.XMLHTTP.5.0&apos;, &apos;MSXML2.XMLHTTP.4.0&apos;, &apos;MSXML2.XMLHTTP.3.0&apos;, &apos;MSXML2.XMLHTTP&apos;];</div><div class="line">            //通过循环创建XMLHttpRequest对象</div><div class="line">            var temp = arrXHR.length;</div><div class="line">            for (var i=0;i&lt;temp;i++)</div><div class="line">            &#123;</div><div class="line">                try</div><div class="line">                &#123;</div><div class="line">                    //创建XMLHttpRequest对象</div><div class="line">                    xhr = new ActiveXObject(arrXHR[i]);</div><div class="line">                    //如果创建XMLHttpRequest对象成功，则跳出循环</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                catch(ex)</div><div class="line">                &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //判断浏览器是否将XMLHttpRequest作为本地对象实现，针对IE7，Firefox，Opera等浏览器</div><div class="line">        else if(window.XMLHttpRequest)</div><div class="line">        &#123;</div><div class="line">            xhr = new XMLHttpRequest();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //响应XMLHttpRequest对象状态变化的函数</div><div class="line">    function httpStateChange()</div><div class="line">    &#123;</div><div class="line">        if (xhr.readyState==4)//异步调用完毕</div><div class="line">        &#123;</div><div class="line">            if (xhr.status==200 || xhr.status==0)//异步调用成功，在本机上调试</div><div class="line">            &#123;</div><div class="line">                //获得服务器返回的数据</div><div class="line">                var Names = xhr.responseText;</div><div class="line">                var arrName = Names.split(&quot;;&quot;);//把获取到的一个字符串分割成字符串数组。</div><div class="line"></div><div class="line">                //定义一个变量，用于判断用户名是否已经存在</div><div class="line">                var Flag = false;</div><div class="line"></div><div class="line">                for(i=0;i&lt;arrName.length;i++)</div><div class="line">                &#123;</div><div class="line">                    if (arrName[i]== Form.Name.value)</div><div class="line">                    &#123;</div><div class="line">                        Flag = true;//用户名存在</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                //合法性验证提醒</div><div class="line">                var OWarn = document.getElementById(&quot;Warn&quot;);</div><div class="line">                if (Flag)</div><div class="line">                &#123;</div><div class="line">                    OWarn.innerHTML = &quot;您输入的用户名已存在，请重新输入！&quot;;</div><div class="line">                    Form.Btn.disabled = true;//提交按钮不可用</div><div class="line">                &#125;</div><div class="line">                else</div><div class="line">                &#123;</div><div class="line">                    OWarn.innerHTML = &quot;合法用户名&quot;;</div><div class="line">                    Form.Btn.disabled = false;//提交按钮可用</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //校验用户名是否有效</div><div class="line">    function check()</div><div class="line">    &#123;</div><div class="line">        //创建XMLHttpRequest对象，调用前面定义好的函数</div><div class="line">        CreatXHR();</div><div class="line"></div><div class="line">        if (xhr!=null)</div><div class="line">        &#123;</div><div class="line">            //创建响应XMLHttpRequest对象状态变化的函数</div><div class="line">            xhr.onreadystatechange = httpStateChange;</div><div class="line">            //创建http请求</div><div class="line">            xhr.open(&quot;get&quot;,&quot;Readme.txt&quot;, true);</div><div class="line">            //发送http请求</div><div class="line">            xhr.send(null);</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            alert(&quot;您的浏览器不支持XMLHTTP&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p> 注意：需要在html同级目录下创建一个Reademe.txt文件来存储已经存在的用户名，多个用户名之间用分好隔开。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-12/4894833.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-12/22625927.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oszamq4pp.bkt.clouddn.com/17-7-12/1123101.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>可以复制代码亲自试看下效果哦！(建议Firefox下调试)<br>详细代码讲解请看下一章<a href="http://www.upyang.com/2017/07/12/ajax/" target="_blank" rel="external">通俗易懂Ajax实例讲解(二)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Ajax简介&quot;&gt;&lt;a href=&quot;#Ajax简介&quot; class=&quot;headerlink&quot; title=&quot;Ajax简介&quot;&gt;&lt;/a&gt;Ajax简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ajax = 异步 JavaScript 和 XML。&lt;/li&gt;
&lt;li&gt;ajax是一种在无需重
    
    </summary>
    
    
      <category term="ajax" scheme="http://upyang.com/tags/ajax/"/>
    
      <category term="XMLHttpRequest" scheme="http://upyang.com/tags/XMLHttpRequest/"/>
    
      <category term="jsonp" scheme="http://upyang.com/tags/jsonp/"/>
    
  </entry>
  
  <entry>
    <title>jsonp跨域实现</title>
    <link href="http://upyang.com/2017/07/08/jsonp%E8%B7%A8%E5%9F%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://upyang.com/2017/07/08/jsonp跨域实现/</id>
    <published>2017-07-08T10:57:30.000Z</published>
    <updated>2017-07-09T15:25:11.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于JavaScript代码能够访问的页面内容做了很重要的限制，即JavaScript只能访问与包含它的文档在同一域下的内容。（图片来自MDN）</p>
<p><img src="http://img.blog.csdn.net/20170507170944865?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上用标签引入<code>&lt;script&gt;</code>不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。</p>
<li>jsonp的客户端实现</li>

<p>tocat服务器上有个remote.js（这里用tocat，web项目演示）</p>
<p><img src="http://img.blog.csdn.net/20170507182922130?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p><code>alert(&quot;跨域成功&quot;);</code><br>　　<li>本地index.html文件</li></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;title&gt;跨域资源&lt;/title&gt;</div><div class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;</div><div class="line">/* 完成跨域 */</div><div class="line">&lt;script src=&quot;http://localhost:8080/web/js/remote.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20170507182807316?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p>　　很明显，显示跨域成功</p>
<li>接下来我们在本地index.html定义callback函数 ，然后远程tomcat.js传入回调数据</li>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;跨域资源&lt;/title&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;</div><div class="line">    /* 完成跨域 */</div><div class="line">     &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">         window.onload = function() &#123;</div><div class="line">         var callback = function(data) &#123;</div><div class="line">            alert(&quot;跨域调用远程tomcat.js成功: &quot; + data.name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">    &lt;script src=&quot;http://localhost:8080/web/js/tomcat.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>远程服务器：</p>
<p>tomcat.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">callback(&#123;&quot;name&quot;:&quot;kk&quot;&#125;);</div></pre></td></tr></table></figure>
<p>到此，跨域基本实现，但是这里有个问题，<i style="color:red">远程站点怎么知道要调用哪个callback呢？</i></p>
<p>所以就有了jsonp的核心：服务端提供的callback是动态生成的， 本地只要动态传一个callback给服务端，服务端就知道该调用哪个了</p>
<p>像这样：<br>客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;跨域资源&lt;/title&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    window.onload = function() &#123;</div><div class="line">        var callback = function(data) &#123;</div><div class="line">            alert(&quot;跨域调用远程成功: &quot; + data.name);</div><div class="line">        &#125;</div><div class="line">        var url = &quot;http://localhost:8080/web/js/helloServlet?userid=1&amp;callback=callback&quot;;</div><div class="line">        // 创建script标签，设置其属性</div><div class="line">        var script = document.createElement(&apos;script&apos;);</div><div class="line">        script.setAttribute(&apos;src&apos;, url);</div><div class="line">        // 把script标签加入head，此时调用开始</div><div class="line">        document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);</div><div class="line">    &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>服务端：（这里选用java解释）<br>// 从客户端获取参数userid和callback<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PrintWriter out =response.getWriter();</div></pre></td></tr></table></figure></p>
<p>// 根据userid查找到的数据存储为json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">out.println(callback+&quot;(&quot;+json+&quot;)&quot;);</div></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20170507191945153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p>jsonp的执行全过程就是这么回事了（个人理解）</p>
<li>现在再来看JQuery中的实现，我们最经常用的$.ajax，似乎通透了不少，也就是这么回事<br></li>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$(function() &#123;</div><div class="line">        $.ajax(&#123;</div><div class="line">            async: false,</div><div class="line">            url: http, //跨域url地址</div><div class="line">            type: &quot;GET&quot;,</div><div class="line">            dataType: &apos;jsonp&apos;,</div><div class="line">            jsonp: &apos;jsoncallback&apos;,</div><div class="line">            data: &#123;</div><div class="line">                &quot;userid&quot;: &quot;1&quot;</div><div class="line">            &#125;,</div><div class="line">            timeout: 5000,</div><div class="line">            beforeSend: function() &#123;</div><div class="line">                //jsonp 方式此方法不被触发.原因可能是dataType如果指定为jsonp的话,就已经不是ajax事件了</div><div class="line">            &#125;,</div><div class="line">            success: function(json) &#123; //客户端jquery预先定义好的callback函数,成功获取跨域服务器上的json数据后,会动态执行这个callback函数</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            error: function(xhr) &#123;</div><div class="line">                //jsonp 方式此方法不被触发.原因是:dataType如果指定为jsonp的话,就已经不是ajax事件了</div><div class="line">                //请求出错处理</div><div class="line">                alert(&quot;请求出错(请检查相关度网络状况.)&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>这里发现，$.ajax和ajax并不是一回事啊,ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。</p>
<h1 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h1><p>注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。<br>实例：<br>假设有三个页面：<br><a href="http://a.com/a.html" target="_blank" rel="external">http://a.com/a.html</a>  //渴望获得数据的页面<br><a href="http://a.com/b.html" target="_blank" rel="external">http://a.com/b.html</a>  //a的兄弟页面，充当中间人角色<br><a href="http://b.com/data.html" target="_blank" rel="external">http://b.com/data.html</a> //不同源的数据页</p>
<li><a href="http://a.com/a.html,监听iframe的onload事件，在此事件中设置这个iframe的src指向本地域的代理页面http://a.com/b.html（代理文件和应用页面在同一域下，所以可以相互通信）" target="_blank" rel="external">http://a.com/a.html,监听iframe的onload事件，在此事件中设置这个iframe的src指向本地域的代理页面http://a.com/b.html（代理文件和应用页面在同一域下，所以可以相互通信）</a><br>动态创建iframe</li>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line"></div><div class="line">var state = 0,</div><div class="line">    iframe = document.createElement(&apos;iframe&apos;);</div><div class="line"></div><div class="line">// 通过iframe的src与data.html通信</div><div class="line">iframe.src = &apos;http://b.com/data.html&apos;;</div><div class="line"></div><div class="line">//监听onload</div><div class="line">if (iframe.attachEvent) &#123;</div><div class="line">    iframe.attachEvent(&apos;onload&apos;, loadfn);</div><div class="line">&#125; else &#123;</div><div class="line">    iframe.onload = loadfn;</div><div class="line"></div><div class="line">var loadfn = function() &#123;</div><div class="line">        if (state === 0) &#123;</div><div class="line">            state = 1;</div><div class="line">            iframe.contentWindow.location = &quot;http://a.com/b.html&quot;; // 设置的代理页面</div><div class="line">        &#125;</div><div class="line">        else if (state === 1) &#123;</div><div class="line">            var data = iframe.contentWindow.name; // 读取数据</div><div class="line">            alert(data); //弹出&apos;data.html!&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&lt;/script&gt;</div><div class="line">  ● http://b.com/data.html</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    window.name = &apos;data.html&apos;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这样就可以成功解决了，理一下思路，应该是这样:<br>充当中间人的iframe想要获取到data.html的通过window.name设置的数据，只需要把这个iframe的src设为www.cnblogs.com/data.html就行了。然后a.html想要得到iframe所获取到的数据，也就是想要得到iframe的window.name的值，还必须把这个iframe的src设成跟a.html页面同一个域才行</p>
<p>图示：<br><img src="http://img.blog.csdn.net/20170507203413041?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h1 id="HTML5中新引进的window-postMessage方法"><a href="#HTML5中新引进的window-postMessage方法" class="headerlink" title="HTML5中新引进的window.postMessage方法"></a>HTML5中新引进的window.postMessage方法</h1><p>在HTML5中新增了postMessage方法，postMessage可以实现跨文档消息传输（Cross Document Messaging），Internet Explorer 8, Firefox 3, Opera 9, Chrome 3和 Safari 4都支持postMessage。<br>实现：<br>发送信息的页面<a href="http://a.com/a.html" target="_blank" rel="external">http://a.com/a.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line"></div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;客户端&lt;/title&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    window.onload = function() &#123;</div><div class="line">        window.frames[0].postMessage(&apos;data&apos;, &apos;http://b.com/data.html&apos;);</div><div class="line">        //postMessage接收两个参数，第一个数据，第二个字符串参数，指明目标窗口的源，具体看MDN</div><div class="line">    &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">    &lt;iframe id=&quot;child&quot; src=&quot;http://b.com/data.html&quot;&gt;&lt;/iframe&gt;</div><div class="line">&lt;/body&gt;</div><div class="line"></div><div class="line">&lt;/html&gt;</div><div class="line">接收信息的页面http://b.com/data.html</div><div class="line">// 通过监听message事件获取数据</div><div class="line">window.addEventListener(&apos;message&apos;,function(e)&#123;</div><div class="line">                var e =e||event;</div><div class="line">                alert(e.data);</div><div class="line">            &#125;,false);</div></pre></td></tr></table></figure></p>
<p>图示：<br><img src="http://img.blog.csdn.net/20170507211511202?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9wZV9JdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h1 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h1><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>　　整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。<br>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。具体原理参见MDN</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h1&gt;&lt;p&gt;在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://upyang.com/tags/JavaScript/"/>
    
      <category term="Jsonp" scheme="http://upyang.com/tags/Jsonp/"/>
    
      <category term="HTML5" scheme="http://upyang.com/tags/HTML5/"/>
    
      <category term="CORS" scheme="http://upyang.com/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://upyang.com/2017/07/07/hello-world/"/>
    <id>http://upyang.com/2017/07/07/hello-world/</id>
    <published>2017-07-07T08:00:29.363Z</published>
    <updated>2017-07-07T08:00:29.363Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
