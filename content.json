{"meta":{"title":"途中人的博客","subtitle":"IT技术分享！","description":null,"author":"途中人","url":"http://upyang.com"},"pages":[{"title":"关于我","date":"2017-07-08T14:18:02.000Z","updated":"2017-07-17T15:01:25.520Z","comments":true,"path":"about/index.html","permalink":"http://upyang.com/about/index.html","excerpt":"","text":"HTML个人简历 PDF个人简历 姓名： 杨钊 学历： 长江大学 本科 软件工程 Q Q： 1067896503 邮箱： 1067896503@qq.com github： https://github.com/Aaron0525 个人简介： 大四学生，求实习工作! 目前技术栈： 前端：HTML/HTML5、CSS/CSS3、JavaScript、jQuery、bootstrap、微信小程序 框架：Vue.js 后端：Java、Node.js 数据库：MySQL、mongodb、SqlServer 自动化构建工具： webpack、gulp"},{"title":"我的作品","date":"2017-08-22T09:47:36.644Z","updated":"2017-08-22T09:47:36.644Z","comments":false,"path":"categories/index.html","permalink":"http://upyang.com/categories/index.html","excerpt":"","text":"@timeline{ 详情索引@item{ 2016.10响应式网站利用媒体查询写的响应式网站 } @item{ 2016.12倒计时效果Canvas制作的倒计时效果 } @item{ 2017.4移动端音乐AppVue2.0知识构建的移动端音乐App } @item{ 2017.7Vue2.0掘金AppVue2.0知识模仿掘金移动端App } }"},{"title":"tags","date":"2017-07-07T10:02:16.000Z","updated":"2017-07-08T10:32:52.698Z","comments":false,"path":"tags/index.html","permalink":"http://upyang.com/tags/index.html","excerpt":"","text":"你好！"}],"posts":[{"title":"canvas倒计时效果","slug":"canvas","date":"2017-08-22T09:49:26.000Z","updated":"2017-08-22T15:12:09.477Z","comments":true,"path":"2017/08/22/canvas/","link":"","permalink":"http://upyang.com/2017/08/22/canvas/","excerpt":"","text":"Canvas-倒计时效果👉 github： https://github.com/Aaron0525/canvas 👉 演示地址: http://www.upyang.com/canvas/ Canvas概述Canvas API（画布）用于在网页实时生成图像，并且可以操作图像内容，基本上它是一个可以用JavaScript操作的位图。 使用前，首先需要新建一个&lt;canvas&gt;网页元素。123&lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;200&quot;&gt; 您的浏览器不支持canvas！&lt;/canvas&gt; 上面代码中，如果浏览器不支持这个API，则就会显示&lt;canvas&gt;标签中间的文字——“您的浏览器不支持canvas！”。 每个canvas节点都有一个对应的context对象（上下文对象），Canvas API定义在这个context对象上面，所以需要获取这个对象，方法是使用getContext方法。12345var canvas = document.getElementById(&apos;myCanvas&apos;);if (canvas.getContext) &#123; var ctx = canvas.getContext(&apos;2d&apos;);&#125; 上面代码中，getContext方法指定参数2d，表示该canvas节点用于生成2D图案（即平面图案）。如果参数是webgl，就表示用于生成3D图像（即立体图案），这部分实际上单独叫做WebGL API（本文不涉及）。 绘图方法","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://upyang.com/tags/canvas/"}]},{"title":"js数组操作","slug":"js-Array","date":"2017-08-21T14:22:37.000Z","updated":"2017-08-22T01:38:16.223Z","comments":true,"path":"2017/08/21/js-Array/","link":"","permalink":"http://upyang.com/2017/08/21/js-Array/","excerpt":"","text":"Array对象用于在单个的 版两种存储多个值。 创建Array对象的语法123new Array();new Array(size);new Array(element0, element1,....., elementn); Array对象方法 操作练习 用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。 123456789101112var Array = [];function getRandom(start,end) &#123; var temp = end - start + 1; return Math.floor(Math.Random()*temp + start);&#125;for(let i=0;i&lt;10;i++) &#123; Array.push(getRandom(10,100));&#125;Array.sort(); //正序Array.sort(function(a,b) &#123; return b-a&#125;) //倒序，重写下sort函数 把两个数组合并，并删除第二个元素。 12345var temp1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var temp2 = [&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];var Array = temp1.concat(temp2);Array.splice(1,1);console.log(Array); 有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:’1′, b:’2′, c:”, d:’xxx’, e:undefined}。 123456789101112function serilizeUrl(url) &#123; var result = &#123;&#125;; url = url.split(&quot;?&quot;)[1]; //问号处分割字符串并得到后半部分(前半部分索引为0，后半部分索引为1) var map = url.split(&quot;&amp;&quot;); //&amp;前后分割开并返回一个数组 for(var i = 0, len = map.length; i &lt; len; i++) &#123; result[map[i].split(&quot;=&quot;)[0]] = map[i].split(&quot;=&quot;)[1]; &#125; return result; console.log(result);&#125;serilizeUrl(&apos;http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e&apos;); 已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。 12345678var foo = &quot;get-element-by-id&quot;;var arr = foo.split(&quot;-&quot;);console.log(arr);for(let i=0;i&lt;=arr.length;i++) &#123; arr[i] = arr[i].toString().chatAt(0).toUpppercase()+arr[i].substr(1,arr[i].length-1);&#125;var result = arr.join();console.log(result);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://upyang.com/tags/javascript/"}]},{"title":"从原理上理解NodeJS的适用场景","slug":"nodejs应用场景","date":"2017-08-18T07:35:29.000Z","updated":"2017-08-20T13:20:40.801Z","comments":true,"path":"2017/08/18/nodejs应用场景/","link":"","permalink":"http://upyang.com/2017/08/18/nodejs应用场景/","excerpt":"","text":"概述NodeJS宣称其目标是“旨在提供一种简单的构建可伸缩网络程序的方法”，那么它的出现是为了解决什么问题呢，它有什么优缺点以及它适用于什么场景呢？ NodeJS的特点1. 它是一个Javascript运行环境 2. 依赖于Chrome V8引擎进行代码解释 3. 事件驱动 4. 非阻塞I/O 5. 轻量、可伸缩，适于实时数据交互应用 6. 单进程，单线程 Apache的多线程高并发模式Apache是当前世界排名第一的Web服务端软件，它由于支持多线程并发而受到广大服务器技术选型者的欢迎。但发展到后来，Apache在一些WEB的大型应用中也渐渐暴露出它的缺点：阻塞。 那有的同学会奇怪，Apache不是多线程处理并发吗，为什么还会出现阻塞呢？ 要明白这一点我们首先需要了解线程这个概念 什么是线程？ 我们引用官方的解释：线程可以独立运行的最小的CPU单位，可以在同一个进程里并发运行，共享该进程下的内存地址空间（注意这个特点）。 我们可以看到同一个进程下的线程是会共享相同的文件和内存的（内存地址空间），所以大家可以想象，当不同的线程需要占用同一个变量时，根据先到先得的原则，先到的线程在运作时，后来的线程只能在旁边等待，也就是加入到了阻塞排队序列。所以这就是造成线程阻塞的原因。 因此，虽说进程可以支持多个线程，它们看似同时执行，但互相之间并不同步。一个进程中的多个线程共享相同的内存地址空间，这就意味着它们可以访问相同的变量和对象，而且它们从同一堆中分配对象。尽管这让线程之间共享信息变得更容易，因为程序设计者必须小心，确保它们不会妨碍同一进程里的其它线程。 了解了多线程并行的缺陷后，我们就可以更好地理解NodeJS的强大所在了。因为NodeJS是异步单线程的！ NodeJS的异步I/O原理我们先来看一段Apache请求数据库的代码：12res = db.query(&apos;select * from user&apos;);res.output(); 代码执行到第一行的时候线程会阻塞，等待query返回结果，然后继续处理，举个例子，银行排队办理业务时，服务端只有一个线程，用户请求到达只能处理一个，其余的要先等待。由于数据库查询、磁盘读写、网络通信等原因（所谓的I/O）阻塞时间会非常大（相对于CPU始终频率）。对于高并发的访问，一方面线程长期阻塞等待，另一方面为了应付新情求而不断添加新线程，会浪费大量系统资源，并发量高的时候，请求仍然需要等待，同时线程的增加也会也会占用大量的CPU时间来处理内存上下文切换。看看node.js怎么处理。123res = db.query(&apos;select * from user&apos;,function(res) &#123; res.output();&#125;) 看到没，就四个字：异步回调。query的第二个参数是一个回调函数，进程执行到db.query的时候不会等待结果返回，而是直接继续执行下面的语句，直到进入事件循环。当数据库执行结果返回的时候会将事件发送到事件队列，等到线程进入事件循环后才会调用之前的回调函数。更专业的说法是异步I/O。只要单线程就可以。 举个例子，在像麦当劳这样的快餐店点餐，我们点完餐后拿到了一个号码，拿到号码后，我们往往会在位置上等待，而在我们后面的请求会继续得到处理，同样是拿了一个号码然后到一旁等待，接待员能一直进行处理。等到饭菜做号了，会喊号码，我们拿到了自己的饭菜，进行后续的处理（吃饭）。这个喊号码的动作在NodeJS中叫做回调（Callback），能在事件（烧菜，I/O）处理完成后继续执行后面的逻辑（吃饭），这体现了NodeJS的显著特点，异步机制、事件驱动整个过程没有阻塞新用户的连接（点餐），也不需要维护已经点餐的用户与厨师的连接。 那为什么NodeJS做到单线程，却可以实现异步呢？在这里我们先上一幅图，直戳图中的Event queue NodeJS的工作原理其实就是事件循环。可以说每一条NodeJS的逻辑都是写在回调函数里面的，而回调函数都是有返回之后才异步执行的！ 看到这里，你不禁会惊叹，NodeJS如果所有处理都异步，岂不是晓得飞了？错错错！当然不是，不要忘记，NodeJS实现这些的基础是单线程。没错，单线程！一条线程扛起所有操作！ 你可以想象一下，NodeJS在寒风中面对着10万并发大军，OK，没问题，上来敌人一个扔到城里，上来一个又扔到城里。城里全民皆兵，可以很好地消化这些敌人。但如果上来一个类似于张飞赵云这样的人物，老Node心里一惨，和张飞大战300回合，把他打残了，再扔到城里。那后面的10万大军就得等这300回合。所以这说明什么？说明NodeJS不是没有阻塞，而是阻塞不发生在后续回调的流程，而会发生在NodeJS本身对逻辑的计算和处理。我们已经知道，NodeJS的分发能力无比强大，可以循环事件进行异步回调。但如果在循环事件时遇到复杂的逻辑运算，那么单薄的单线程怎么支撑得起上百万的逻辑+并发呢？NodeJS它的所有I/O、网络通信等比较耗时的操作，都可以交给worker threads执行再回调，所以很快。但CPU的正常操作，它就只能自己抗了。 NodeJS的应用场景既然NodeJS处理并发的能力强，但处理计算和逻辑的能力反而很弱，因此，如果我们把复杂的逻辑运算都搬到前端（客户端）完成，而NodeJS只需要提供异步I/O，这样就可以实现对高并发的高性能处理。情况就很多啦，比如：RESTFUL API、实时聊天、客户端逻辑强大的单页APP，具体的例子比如说：本地化的在线音乐应用，本地化的在线搜索应用，本地化的在线APP等。","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://upyang.com/tags/nodejs/"}]},{"title":"js责任链","slug":"js责任链模式","date":"2017-08-07T01:13:37.000Z","updated":"2017-08-15T12:58:00.279Z","comments":true,"path":"2017/08/07/js责任链模式/","link":"","permalink":"http://upyang.com/2017/08/07/js责任链模式/","excerpt":"","text":"前言最近同学问到了一个他实际工作中关于生产托运方面的一个问题，问题不是很大，但是觉得挺有意思，分享在此。 实际需求现有A、B、C、D四个生产线，生产总量为2100，每个生产线的生产量未知且在0~2100(包括0和2100，保证总量为2100即可)，生产完毕后，6台车辆进行托运，规定每台车辆只能运350，且装满后才能够出发，装车顺序为ABCD,即上一个生产线生产的东西装完后才能够装下一个生产线的东西，要求根据每条生产线的生产量，给出每台车辆的托运安排。 例如： A：100 ， B：1400 ，C：500 ， D：100托运安排： 第一辆车： A：100 ， B：250 第二辆车： A：0 ， B：350 第三辆车： A：0 ， B：350 第四辆车： A：0 ， B：350 第五辆车： A：0 ， B：100 ，C：250 第六辆车： A：0 ， B：0 ， C：250 ，D：100 分析看了这个需求，脑袋里第一时间想到的是if判断，但是实际写代码的时候发现，条件太多了，算下来一共有81种情况了，感觉已经不适合用if了，这时查找各种资料以及请问大神后发现了责任链这种设计模式。 责任链模式顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。 在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 关键代码：Handler里面聚合它自己，在HanleRequest里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。 应用实例： 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。 优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。 缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。 使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。 责任链的详细讲解可以参阅菜鸟教程中的说明。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class WearHouse&#123; constructor(volume,wearHouse)&#123; this.volume=volume; this.wearHouse=wearHouse; this.outString=[]; &#125; next(take)&#123; if(this.wearHouse!=undefined) &#123; this.wearHouse.takeOut(take).forEach((subT) =&gt; &#123; this.outString.push(subT) &#125;) &#125; &#125; takeOut(num)&#123; if(num&gt;this.volume)&#123; num-=this.volume; var temp=this.volume; this.volume=0; this.outString.push(this.print(0,temp)); this.next(num); &#125;else&#123; this.volume-=num; this.outString.push(this.print(this.volume,num)); &#125; var temOut=this.outString; this.outString=[]; return temOut; &#125; print(volumn,takeNum)&#123;&#125; &#125; class WearHouseA extends WearHouse&#123; print(volumn,takeNum)&#123; return [&apos;A&apos;,takeNum]; &#125; &#125; class WearHouseB extends WearHouse&#123; print(volumn,takeNum)&#123; return [&apos;B&apos;,takeNum]; &#125; &#125; class WearHouseC extends WearHouse&#123; print(volumn,takeNum)&#123; return [&apos;C&apos;,takeNum]; &#125; &#125; class WearHouseD extends WearHouse&#123; print(volumn,takeNum)&#123; return [&apos;D&apos;,takeNum]; &#125; &#125; var D=new WearHouseD(100,undefined); var C=new WearHouseC(500,D); var B=new WearHouseB(1400,C); var A=new WearHouseA(100,B); var strSet=[]; for(var a=0;a&lt;6;a++)&#123; strSet.push(...A.takeOut(350)); &#125; console.log(strSet); * 总结责任链模式，对于解决按照优先级顺序依次执行的问题也挺有效的，不用写很多的判断语句。责任链模式在java中应用尤其广泛，尝试用js来实现责任链也是挺有意思的。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://upyang.com/tags/javascript/"}]},{"title":"javascript面试","slug":"javascript面试","date":"2017-08-04T02:37:31.000Z","updated":"2017-08-21T14:27:11.546Z","comments":true,"path":"2017/08/04/javascript面试/","link":"","permalink":"http://upyang.com/2017/08/04/javascript面试/","excerpt":"","text":"原型、继承123456789101112131415161718192021222324252627282930function Parent() &#123; this.a = 1; this.b = [1, 2, this.a]; this.c = &#123; demo: 5 &#125;; this.show = function () &#123; console.log(this.a , this.b , this.c.demo ); &#125;&#125;function Child() &#123; this.a = 2; this.change = function () &#123; this.b.push(this.a); this.a = this.b.length; this.c.demo = this.a++; &#125;&#125;Child.prototype = new Parent();var parent = new Parent();var child1 = new Child();var child2 = new Child();child1.a = 11;child2.a = 12;parent.show(); &lt;!-- 输出 1 [1,2,1] 5 --&gt;child1.show(); &lt;!-- 输出 11 [1,2,1] 5 --&gt;child2.show(); &lt;!-- 输出 12 [1,2,1] 5 --&gt;child1.change();child2.change();parent.show(); &lt;!-- 输出 1 [1,2,1] 5 --&gt;child1.show(); &lt;!-- 输出 5 [1,2,1,11,12] 5 --&gt;child2.show(); &lt;!-- 输出 6 [1,2,1,11,12] 5 --&gt; 考察知识点： 1，this的指向 2，原型(prototype)以及原型链 3，继承 4，引用 要正确解出这道题，需要理解以下知识点： 1，每一个构造函数，都有一个原型[[prototype]]属性 指向构造函数的原型对象。 2，每一个实例生成的时候，都会在内存中产生一块新的堆内存。 3，每一实例都有一个隐式原型proto 指向构造函数的原型对象。 4，this的指向 取决于this调用时的位置, 在这道题中， 也可以简单理解为， 谁调用方法， this就指向哪个对象。 5，数组和字面量对象 都是 引用。 6，原型链的查找规则： 就近原则 当实例上存在属性时， 用实例上的。 如果实例不存在，顺在原型链，往上查找，如果存在，就使用原型链的。 如果原型链都不存在，就用Object原型对象上的。 如果Object原型对象都不存在， 就是undefined。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://upyang.com/tags/javascript/"}]},{"title":"Vue项目上传github并预览","slug":"Vue项目上传github并预览","date":"2017-07-25T08:05:27.000Z","updated":"2017-07-31T04:14:11.453Z","comments":true,"path":"2017/07/25/Vue项目上传github并预览/","link":"","permalink":"http://upyang.com/2017/07/25/Vue项目上传github并预览/","excerpt":"","text":"前言最近在初步完成自己的掘金移动端App后，想要上传到github，并且制作一个简单的预览功能，期间遇到了一些问题，分享在此，以便查阅。 打包Vue项目当Vue项目完成后，在根目录下打开命令行，输入命令： npm run build 实际上此命令就是执行build.js文件，将项目打包成静态资源。此命令完成后，项目根目录下会多出一个dist文件夹，dist文件里面有： static文件下包括项目打包后的css、js、img、fonts(字体图标)。 项目资源无法加载点击index.html,浏览器显示该页面是空白的，打开控制台看到： 这里看到index.html文件中没有加载任何css、js文件，解决方法： 打开项目根目录 config 下的 index.js 文件，进行如下修改： 将 assetsPublicPath: ‘/‘, 改为 assetsPublicPath: ‘./‘, 保存后重新’npm run build’,在新生成的dist目录下点开index.html，这时页面结构正常显示出来了，但是页面字体图标和mock的数据无法正常加载。 字体图标无法加载页面中用background加载的图片可以正常显示，但是所有的字体图标都不能正常显示，解决方法：打开根目录下 build 中的 utils.js 文件，在控制build样式文件代码中添加 publicPath: ‘../../‘， 如下： 保存后，依旧重新’npm run build’,打开dist目录下的index.js可以看到字体图标正常显示了。这里为什么需要这样修改，可以参考https://github.com/vuejs-templates/webpack/issues/166。 Mock数据无法正常加载此项目的绝大部分页面内容是通过在跟目录下创建的data.json文件渲染到页面上的，是模拟从后端请求数据的，开发调试时用’npm run dev’命令，会借助node启动一个本地服务器，可以正常的渲染出相应的数据。而通过打包后的项目时属于静态资源的，点击index.html查看项目，是无法加载mock的数据的，浏览器也会报跨域的错误。若想正常的加载mock数据，最好的方式是讲打包后的资源丢到服务器中，或者使用jsonp请求线上真实数据，因为它的原理是利用script标签来获得数据，在github上是可以预览到的。 利用git命令将项目上传到github首先设置SSH key,网上的教程很多，推荐一个简书里面的两种方法上传本地文件到github,完成后在github里面新建一个一个存放项目的仓库(建议勾选上初始化)，git命令： 1、先进入项目文件夹，通过命令 git init 把这个目录变成git可以管理的仓库 git init 2、把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意思为添加文件夹下的所有文件。 git add . 3、用命令 git commit告诉Git，把文件提交到仓库。引号内为提交说明。 git commit -m ‘message’ 4、关联到远程库。 git remote add origin 你的远程库地(如：https://github.com/Aaron0525/Vue-juejin-App.git) 5、将项目所有push文件到仓库中。 git push -u origin master 第五步操作时，有时会失败，我的方法是将 u 改为 f 来提交，即输入命令git push -f origin master回到github中该项目的仓库，项目文件就提交上去了，若失败，请仔细核对步骤。 制作github在线预览效果 github制作预览是需要利用GitHub Pages的，点击项目仓库的setting,找到source,切换到master branch,点击保存。 点击GitHub Pages下面出现的网址即为预览地址，但是此时点击进去会发现没有页面效果，没关系，下面继续： 我们生成githubPages的目的就是需要生成一个gh-pages分支(正常情况下只有一个master分支)。 生成gh-pages分支步骤： 1、将远程仓库克隆到本地： git clone https://github.com/Aaron0525/Vue-juejin-App.git(项目克隆地址) 2、生成分支gh-pages并切换到此分支 cd flexSupplement （进入到你克隆仓库的本地文件夹） git checkout - -orphan gh-pages (创建分支并切换，两个横杆) 3、将本地克隆文件(文件名为github仓库名)里面除.git文件以外的其他文件全部删除，再将根目录下dist文件夹里面的内容复制到克隆文件中。 依次执行以下命令： git add . （将本地所有文件加到仓库里） git commit -m “message” （设置提交信息） git remote add origin https://github.com/Aaron0525/ Vue-juejin-App.git（本地仓库链接远程仓库） git push -u origin gh-pages （push文件到仓库中） 完成以上步骤后，回到github里面，点击上面说到的GitHub Pages下面的地址，既能预览效果，注意耐心等待一小会，跟新同步还是需要一个过程的，同样这里面还是无法显示mock的数据。 总结 github，这个星球上最流行的开源托管服务的分布式网站，作为程序员，掌握基本的github使用方法，无论是对于分享、托管自己的项目，还是查阅其他优秀的开源项目，都是十分有帮助的。 以下是我的一些项目演示： Vue2.0移动端以音乐播放器 Vue2.0模仿掘金App 响应式网站 觉得有用的，可以给个start哦！ 感谢！！！","categories":[],"tags":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://upyang.com/tags/Vue2-0/"},{"name":"github","slug":"github","permalink":"http://upyang.com/tags/github/"}]},{"title":"Vue2.0仿掘金App(总结)","slug":"Vue学习","date":"2017-07-21T15:28:51.000Z","updated":"2017-08-07T02:55:46.111Z","comments":true,"path":"2017/07/21/Vue学习/","link":"","permalink":"http://upyang.com/2017/07/21/Vue学习/","excerpt":"","text":"前言 最近一段时间一直在学习Vue2.0的相关知识，之前只是看过相关的视频教学，但是一直没有动手去实践自己的项目，这次决定用Vue2.0去模仿一个移动端App,看了很多自己用过的App,最后决定模仿做掘金移动端App,恰好这款App也是用Vue做的。写下这篇博客，记录实践中的心得体会。 需求分析首先直观的看下掘金App的基本页面构成： 通过观察分析，总结出以下几点： 首页，底部和顶部分别有tab切换，在Vue中可以通过配置嵌套路由来实现。 发现页，顶部有一个轮播图，数据要求实时跟新。因为之前有在做Vue-music时有做过一个数据实时跟新的轮播图,这里直接引用过来，后面也会具体去讲怎么实现。沸点栏，有一个左右可以滑动的新闻栏。 消息、我的信息页面基本上都是数据交互，其中我的信息里面会包含一个h5调用摄像头、相册的功能。 项目中用到的字体图标采用阿里的iconfont,一些无法搜索到的图片，用firework切图工具切出来。 项目构建这里基本的node、git的安装就不一一介绍了，网上有很多相关的教程。选用webpack、vue-cli脚手架来快速搭建我们的项目骨架。 Vue创建项目命令： Vue init webpack juejin 根据提示完成相应的项目基本信息，个人意愿选择是否使用ESlint、单元测试、端到端测试等等,建议新手不使用ESlint做代码格式检查，不然可能在写的过程中遇到非常多代码格式错误，当然选择使用的话也有好处，能很好的规范自己的代码风格。 完成项目构建后，对目录进行修改，修改完成后如下： 目录介绍 api: 存放jsonp请求轮播图数据的js文件 base: 存放项目的基础组件，例如：轮播图组件(slider)、新闻列表组件(newslist)、新闻详情listdetail)、搜索组件(search)、修改个人信息组件(modify)等. common: 存放fonts、image、js、stylus文件。 components: 存放项目的主要组件 router: 路由配置 需要注意的是，因为想要模拟从后端获取数据并绑定到组件上，而不是把数据写死在结构上，所以这里在根目录新建了一个data.json的文件，里面写好了项目需要用到的数据。package.json配置依赖 npm install node_modules文件目录下查看到以上的依赖包，说明安装成功了。注意：因为项目用到的reset重置样式文件(copy来的)是stylus格式，所以还需要在devDependencies中配置stylus和stylus-loader依赖。 文件路径配置项目中会经常引入各种文件，为了引用方便会进行以下配置，觉得没必要的可以忽略。 打开build目录下的webpack.base.conf.js文件，在resolve下进行以下配置 这样的好处是引用某个文件的时候不用每次都带上一堆的前缀。引入字体图标前面说到本项目用的是阿里iconfont字体图标库，选择好所要用到的图标之后下载到本地，将其中除了3个html演示文件以外的其他7个文件拷贝到common/fonts目录下，然后将iconfont.css文件里的内容拷贝到common/stylus/icon.styl中,首先要修改的是引用路径，其他根据需要自行修改字体图标的基本样式。 测试字体图标是否引用成功：根目录main.js下 import ‘./common/stylus/icon.styl’，然后在组件中引用一个字体图标，用浏览器查看是否引用成功。Express获取data.json数据的路由配置data.json文件数据结构如下： 接下来配置Express路由，本项目只涉及到get数据，所以只进行了简单的路由配置，Express的详细使用可以查看Express官网,打开build.js文件下的dev-server.js文件，进行以下配置： npm run dev重启服务器，浏览器访问localhost:8080/api/infor,若能看到如data.json/infor里面的数据说明已经配置成功了。 页面嵌套路由配置前面讲到本项目需要配置嵌套路由，首先看一下路由组件的目录结构：components目录下除了四个主要页面组件，还需要在home目录下新建五个子路由对应的组件。 打开router下的index文件进行如下配置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import Home from &apos;../components/home/home&apos;import Find from &apos;../components/find/find&apos;import Infor from &apos;../components/infor/infor&apos;import My from &apos;../components/my/my&apos;import Homepage from &apos;../components/home/homepage/homepage&apos;import Frontend from &apos;../components/home/frontend/frontend&apos;import Product from &apos;../components/home/product/product&apos;import Design from &apos;../components/home/design/design&apos;import Afterend from &apos;../components/home/afterend/afterend&apos;Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, redirect: &apos;./home&apos; &#125;, &#123; path: &apos;/home&apos;, component: Home, children: [ &#123; path: &apos;/&apos;, redirect: &apos;./homepage&apos; &#125;, &#123; path: &apos;/home/homepage&apos;, component: Homepage &#125;, &#123; path: &apos;/home/frontend&apos;, component: Frontend &#125;, &#123; path: &apos;/home/product&apos;, component: Product &#125;, &#123; path: &apos;/home/design&apos;, component: Design &#125;, &#123; path: &apos;/home/afterend&apos;, component: Afterend &#125; ] &#125;, &#123; path: &apos;/find&apos;, component: Find &#125;, &#123; path: &apos;/infor&apos;, component: Infor &#125;, &#123; path: &apos;/my&apos;, component: My &#125; ]&#125;) redirect: &#39;./home&#39;，redirect重定向是规定运行项目后首次显示的页面，这里定向到home首页，子路由中同样需要重定向redirect: &#39;./homepage&#39;。观察可以发现主路由首次显示的页面内容是和子路由首次显示的页面内容是一样的，那么，我们是否可以用同一个组件呢?百般尝试后没有成功，因为主路由home页面渲染出来后，内容上是包含顶部的tab切换的(也就是子路由)，所以前面说到的内容一样其实是个伪命题，那么子路由的重定向不能是home而是homepage，公用的页面内容写在homepage里面。 接下来编写主路由和子路由的tab组件 1234567891011121314151617181920212223242526272829 &lt;!-- 底部tab，顶部同理 --&gt;&lt;template&gt; &lt;div class=&quot;tab&quot;&gt; &lt;router-link tag=&quot;div&quot; class=&quot;tab-item&quot; to=&quot;/home&quot;&gt; &lt;div class=&quot;tab-link&quot;&gt; &lt;div class=&quot;ic_container&quot;&gt;&lt;i class=&quot;iconfont ic home&quot;&gt;&amp;#xe6a6;&lt;/i&gt;&lt;/div&gt; &lt;span&gt;首页&lt;/span&gt; &lt;/div&gt; &lt;/router-link&gt; &lt;router-link tag=&quot;div&quot; class=&quot;tab-item&quot; to=&quot;/find&quot;&gt; &lt;div class=&quot;tab-link&quot;&gt; &lt;div class=&quot;ic_container&quot;&gt;&lt;i class=&quot;iconfont ic find&quot;&gt;&amp;#xe669;&lt;/i&gt;&lt;/div&gt; &lt;span&gt;发现&lt;/span&gt; &lt;/div&gt; &lt;/router-link&gt; &lt;router-link tag=&quot;div&quot; class=&quot;tab-item&quot; to=&quot;/infor&quot;&gt; &lt;div class=&quot;tab-link&quot;&gt; &lt;div class=&quot;ic_container&quot;&gt;&lt;i class=&quot;iconfont ic message&quot;&gt;&amp;#xe62d;&lt;/i&gt;&lt;/div&gt; &lt;span&gt;消息&lt;/span&gt; &lt;/div&gt; &lt;/router-link&gt; &lt;router-link tag=&quot;div&quot; class=&quot;tab-item&quot; to=&quot;/my&quot;&gt; &lt;div class=&quot;tab-link&quot;&gt; &lt;div class=&quot;ic_container&quot;&gt;&lt;i class=&quot;iconfont ic my&quot;&gt;&amp;#xe705;&lt;/i&gt;&lt;/div&gt; &lt;span&gt;我的&lt;/span&gt; &lt;/div&gt; &lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; 注意：检查路由是否配置成功不仅仅要看是否能正常切换，还需要观察地址栏路径变化，是否符合逻辑。底部点击切换时，http://localhost:8080/#/[home,find,infor,my]四个地址之间切换。点击顶部路由时，http://localhost:8080/#/home/[homepage,frontend,product,design,afterend]五个地址之间切换。 发现页轮播图轮播图对于前端工程师来说十分常见，以往的轮播图数据都是写死的，不能变化，这次希望模仿出来的掘金App更加真实，所以做了一个数据可变的的轮播图。很遗憾，掘金App上的轮播图数据暂时没有想到好的办法去拿到，chrome网页版掘金切换到手机模式依旧没有轮播图数据。这里选用的是QQ音乐首页轮播图数据，究竟怎么拿到数据并显示呢？ jsonp封装安装好jsonp依赖后，详见webmodules / jsonp，然后对对原始jsonp进行简单的封装:12345678910111213141516171819202122232425import originJsonp from &apos;jsonp&apos;//对外暴露一个方法也叫jsonp,参数url是干净的数据地址，参数data选择我们想要的数据并拼接url上export default function jsonp(url, data, option) &#123; url += (url.indexOf(&apos;?&apos;) &lt; 0 ? &apos;?&apos; : &apos;&amp;&apos;) + param(data) return new Promise((resolve, reject) =&gt; &#123; originJsonp(url, option, (err, data) =&gt; &#123; if (!err) &#123; resolve(data) &#125; else &#123; reject(err) &#125; &#125;) &#125;)&#125;export function param(data) &#123; let url = &apos;&apos; for (var k in data) &#123; let value = data[k] !== undefined ? data[k] : &apos;&apos; url += &apos;&amp;&apos; + k + &apos;=&apos; + encodeURIComponent(value) &#125; return url ? url.substring(1) : &apos;&apos;&#125; 获取数据后渲染到组件中：12345678910111213&lt;div class=&quot;recommend&quot;&gt; &lt;div class=&quot;recommend-content&quot;&gt; &lt;div v-if=&quot;recommends.length&quot; class=&quot;slider-wrapper&quot;&gt; &lt;slider&gt; &lt;div v-for=&quot;item in recommends&quot;&gt; &lt;a :href=&quot;item.linkUrl&quot;&gt; &lt;img :src=&quot;item.picUrl&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;/slider&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; better-scroll 滚动区域的子元素高度大于父元素时才会滚动，通常需要给滚动区域加上一层定高度的盒子。如果列表是数据渲染来的，初始化better-scroll的时机要在获取数据函数执行时就初始化better-scroll，保证能正确就计算出子元素的高度，子、父元素高度差即为可滚动的高度。 父组件与子组件数据通信 在点击新闻列表后,会出现新闻详情页面，新闻详情页面是一个单独的子组件模板,里面的作者、图像、文章banner图、文章标题等一系列数据是需要在点击新闻列表后将数据传递过来并绑定在组件结构上的。 定义子组件：1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;transition name=&quot;move&quot;&gt; &lt;div v-show=&quot;showFlag&quot; class=&quot;listdetail&quot;&gt; &lt;div class=&quot;foot&quot;&gt; &lt;div class=&quot;like-num&quot;&gt;喜欢 &#123;&#123;list.like&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script type=&quot;text/ecmascript-6&quot;&gt; export default &#123; data() &#123; return &#123; showFlag: false &#125; &#125;, props: &#123; list: &#123; type: Object &#125; &#125;, methods: &#123; show() &#123; this.showFlag = true; &#125;, hide() &#123; this.showFlag = false; &#125; &#125; &#125;;&lt;/script&gt; 在props中定义一个变量list来接受父组件传过来的数据 父组件：引入子组件listdetail并注册 父组件中新闻列表是通过v-for在li标签上渲染出来的，点击某新闻列表传给子组件的数据也必须是对应的，添加click事件@selectlist(item)，并传入一个参数item,这个item就是该新闻列表所对应的相关数据。12345678910111213141516&lt;!-- ref 被用来给元素或子组件注册引用信息，直接指向组件实例。 list接受数据。--&gt;&lt;listdetail :list=&quot;selectedlist&quot; ref=&quot;listdetail&quot;&gt;&lt;/listdetail&gt;&lt;!--data里面定义一个中间变量selectedlist,缓存item的数据(数据为某个新闻列表而非所有数据)并将其绑定在&lt;listdetail&gt;标签上--&gt;data: &#123; return &#123; selectedlist: &#123;&#125;, &#125;&#125;&lt;!--定义selectlist函数，将数据赋值给中间变量selectedlist,并在点击时触发子组件的show()方法 --&gt;methods: &#123; selectlist(item) &#123; this.selectedlist = item; this.$refs.listdetail.show(); &#125;,&#125; 小结 子组件在props中创建一个属性，用来接受父组件传过来的数据。 父组件中注册和引用子组件。 在子组件变迁中添加子组件props中创建的属性。 点击事件触发子组件show()方法时将数据一并赋值给改属性。 父组件可以调用子组件中的方法。 Vue中transition过渡动画App很多地方会有点击后出现一个新的页面的操作，如果不做动画看起来会感觉差点什么，Vue中也提供了了过渡动画的API，官网教程：https://cn.vuejs.org/v2/guide/transitions.html。 在点击新闻列表后，会从右至左出来新闻详情页面，实现也十分简单：123456789101112131415&lt;template&gt; &lt;transition name=&quot;move&quot;&gt; &lt;div v-show=&quot;showFlag&quot; class=&quot;listdetail&quot;&gt; &lt;!-- 组件内容--&gt; &lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;style&gt; .move-enter-active, .move-leave-active &#123; transition: all 0.2s linear; &#125; .move-enter, .move-leave-active &#123; transform: translate3d(100%, 0, 0); &#125;&lt;/style&gt; h5调用摄像头 h5调用摄像头在IOS设备和安卓设备上存在很大的兼容性问题，目前也只是实现了能打开摄像头和相册，对图片进行编辑和上传功能还没有实现(正在研究中)。 移动端实现图片上传并预览，需要用到h5标签input的file属性及filereader对象；accept=”image/*” 表示接受的是图片(不限制格式），若想限制格式需要这样写capture=”camera” 直接打开摄像头，若不加会出现选择打开相机或打开相册总结模仿掘金App是对Vue2.0知识的一种实践，整个做完还是很有收获的，巩固了自己的CSS布局方面的基本功，也对Vue2.0语法的具体应用场景更加清晰。","categories":[],"tags":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://upyang.com/tags/Vue2-0/"},{"name":"ES6","slug":"ES6","permalink":"http://upyang.com/tags/ES6/"},{"name":"jsonp","slug":"jsonp","permalink":"http://upyang.com/tags/jsonp/"},{"name":"webpack","slug":"webpack","permalink":"http://upyang.com/tags/webpack/"}]},{"title":"Vue2.0掘金App","slug":"Vue-juejin-App","date":"2017-07-21T09:56:15.000Z","updated":"2017-08-02T02:43:02.984Z","comments":true,"path":"2017/07/21/Vue-juejin-App/","link":"","permalink":"http://upyang.com/2017/07/21/Vue-juejin-App/","excerpt":"","text":"掘金移动端APP 👉 github： https://github.com/Aaron0525/Vue-juejin-App 👉 演示地址: http://www.upyang.com/Vue-juejin-App/#/home/homepage 项目介绍：&emsp;&emsp;这是一个用Vue2.0模仿的掘金App,使用了Vue2.0+ES6+webpack等前端热门技术。技术栈：&emsp;&emsp;Vue.js: MVVM轻量组件化的热门前端框架。&emsp;&emsp;Vuex：状态管理。 采用集中式存储管理应用的所有组件的状态。&emsp;&emsp;Vue Router：前端路由，它是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。&emsp;&emsp;better-scroll：页面滚动插件，实现了页面无滚动条形式的滚动，且在此基础上实现了首页的轮播图。&emsp;&emsp;axios、jsonp：抓取掘金PC端线上新闻列表数据并渲染到组建中。&emsp;&emsp;Vue-lazyload：图片懒加载。 &emsp;&emsp;构建工具： webpack","categories":[],"tags":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://upyang.com/tags/Vue2-0/"},{"name":"ES6","slug":"ES6","permalink":"http://upyang.com/tags/ES6/"},{"name":"jsonp","slug":"jsonp","permalink":"http://upyang.com/tags/jsonp/"}]},{"title":"Vue2.0移动端音乐App","slug":"Vue-music","date":"2017-07-18T11:02:20.000Z","updated":"2017-07-28T03:09:06.931Z","comments":true,"path":"2017/07/18/Vue-music/","link":"","permalink":"http://upyang.com/2017/07/18/Vue-music/","excerpt":"","text":"Vue2.0搭建移动端音乐APP 👉 github: https://github.com/Aaron0525/Vue-music 👉 演示地址: http://www.upyang.com/Vue-music/index.html#/recommend 项目介绍：&emsp;&emsp;这是一个用Vue.js写的移动端音乐App(SPA),使用了Vue2.0+ES6+webpack等前端热门技术。核心功能热门歌曲推荐、音乐播放、歌曲歌手搜索等。技术栈：&emsp;&emsp;MVVM框架：Vue.js（版本2.0）轻量组件化的热门前端框架。&emsp;&emsp;状态管理：Vuex。 采用集中式存储管理应用的所有组件的状态。&emsp;&emsp;前端路由：Vue Router。它是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。&emsp;&emsp;滚动插件：better-scroll。实现了页面无滚动条形式的滚动，且在此基础上实现了首页的轮播图。&emsp;&emsp;构建工具： webpack&emsp;&emsp;服务端通信：axios、jsonp。从QQ音乐抓取数据显示到页面。&emsp;&emsp;构建工具： webpack","categories":[],"tags":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://upyang.com/tags/Vue2-0/"},{"name":"ES6","slug":"ES6","permalink":"http://upyang.com/tags/ES6/"},{"name":"jsonp","slug":"jsonp","permalink":"http://upyang.com/tags/jsonp/"}]},{"title":"前端性能优化之雅虎军规","slug":"雅虎军规","date":"2017-07-15T08:08:55.000Z","updated":"2017-08-03T15:28:23.316Z","comments":true,"path":"2017/07/15/雅虎军规/","link":"","permalink":"http://upyang.com/2017/07/15/雅虎军规/","excerpt":"","text":"尽量减少HTTP请求数 80%的终端用户响应时间都花在了前端上，其中大部分时间都在下载页面上的各种组件：图片，样式表，脚本，Flash等等。减少组件数必然能够减少页面提交的HTTP请求数。这是让页面更快的关键。 减少页面组件数的一种方式是简化页面设计。但有没有一种方法可以在构建复杂的页面同时加快响应时间呢？嗯，确实有鱼和熊掌兼得的办法。 合并文件是通过把所有脚本放在一个文件中的方式来减少请求数的，当然，也可以合并所有的CSS。如果各个页面的脚本和样式不一样的话，合并文件就是一项比较麻烦的工作了，但把这个作为站点发布过程的一部分确实可以提高响应时间。 CSS Sprites是减少图片请求数量的首选方式。把背景图片都整合到一张图片中，然后用CSS的background-image和background-position属性来定位要显示的部分。 图像映射可以把多张图片合并成单张图片，总大小是一样的，但减少了请求数并加速了页面加载。图片映射只有在图像在页面中连续的时候才有用，比如导航条。给image map设置坐标的过程既无聊又容易出错，用image map来做导航也不容易，所以不推荐用这种方式。 行内图片（Base64编码）用data: URL模式来把图片嵌入页面。这样会增加HTML文件的大小，把行内图片放在（缓存的）样式表中是个好办法，而且成功避免了页面变“重”。但目前主流浏览器并不能很好地支持行内图片。 减少页面的HTTP请求数是个起点，这是提升站点首次访问速度的重要指导原则。 减少DNS查找 域名系统建立了主机名和IP地址间的映射，就像电话簿上人名和号码的映射一样。当你在浏览器输入www.yahoo.com的时候，浏览器就会联系DNS解析器返回服务器的IP地址。DNS是有成本的，它需要20到120毫秒去查找给定主机名的IP地址。在DNS查找完成之前，浏览器无法从主机名下载任何东西。 DNS查找被缓存起来更高效，由用户的ISP（网络服务提供商）或者本地网络存在一个特殊的缓存服务器上，但还可以缓存在个人用户的计算机上。DNS信息被保存在操作系统的DNS cache(微软Windows上的”DNS客户端服务”)里。大多数浏览器有独立于操作系统的自己的cache。只要浏览器在自己的cache里还保留着这条记录，它就不会向操作系统查询DNS。 IE默认缓存DNS查找30分钟，写在DnsCacheTimeout注册表设置中。Firefox缓存1分钟，可以用network.dnsCacheExpiration配置项设置。(Fasterfox把缓存时间改成了1小时 P.S. Fasterfox是FF的一个提速插件) 如果客户端的DNS cache是空的（包括浏览器的和操作系统的），DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本文件，样式表，Flash对象等等组件中的主机名，减少不同的主机名就可以减少DNS查找。 减少不同主机名的数量同时也减少了页面能够并行下载的组件数量，避免DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散在2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。 避免重定向重定向用301和302状态码，下面是一个有301状态码的HTTP头： 123HTTP/1.1 301 Moved Permanently Location: http://example.com/newuri Content-Type: text/html 浏览器会自动跳转到Location域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其实额外的HTTP头，比如Expires和Cache-Control也表示重定向。除此之外还有别的跳转方式：refresh元标签和JavaScript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。 牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。 有一种常见的极其浪费资源的重定向，而且web开发人员一般都意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到http://astrology.yahoo.com/astrology会返回一个重定向到http://astrology.yahoo.com/astrology/的301响应（注意添在尾部的斜线）。在Apache中可以用Alias，mod_rewrite或者DirectorySlash指令来取消不必要的重定向。 重定向最常见的用途是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用Alias和mod_rewrite，前提是两个代码路径都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合Alias或者mod_rewrite指令。 让Ajax可缓存Ajax的一个好处是可以给用户提供即时反馈，因为它能够从后台服务器异步请求信息。然而，用了Ajax就无法保证用户在等待异步JavaScript和XML响应返回期间不会非常无聊。在很多应用程序中，用户能够一直等待取决于如何使用Ajax。例如，在基于web的电子邮件客户端中，用户为了寻找符合他们搜索标准的邮件消息，将会保持对Ajax请求返回结果的关注。重要的是，要记得“异步”并不意味着“即时”。要提高性能，优化这些Ajax响应至关重要。最重要的提高Ajax性能的方法就是让响应变得可缓存，就像在添上Expires或者Cache-Control HTTP头中讨论的一样。下面适用于Ajax的其它规则： Gzip组件 减少DNS查找 压缩JavaScript 避免重定向 配置ETags 我们一起看看例子，一个Web2.0的电子邮件客户端用了Ajax来下载用户的通讯录，以便实现自动完成功能。如果用户从上一次使用之后再没有修改过她的通讯录，而且Ajax响应是可缓存的，有尚未过期的Expires或者Cache-Control HTTP头，那么之前的通讯录就可以从缓存中读出。必须通知浏览器，应该继续使用之前缓存的通讯录响应，还是去请求一个新的。可以通过给通讯录的Ajax URL里添加一个表明用户通讯录最后修改时间的时间戳来实现，例如&amp;t=1190241612。如果通讯录从上一次下载之后再没有被修改过，时间戳不变，通讯录就将从浏览器缓存中直接读出，从而避免一次额外的HTTP往返消耗。如果用户已经修改了通讯录，时间戳也可以确保新的URL不会匹配缓存的响应，浏览器将请求新的通讯录条目。 即使Ajax响应是动态创建的，而且可能只适用于单用户，它们也可以被缓存，而这样会让你的Web 2.0应用更快。 延迟加载组件可以凑近看看页面并问自己：什么才是一开始渲染页面所必须的？其余内容都可以等会儿。 JavaScript是分隔onload事件之前和之后的一个理想选择。例如，如果有JavaScript代码和支持拖放以及动画的库，这些都可以先等会儿，因为拖放元素是在页面最初渲染之后的。其它可以延迟加载的部分包括隐藏内容（在某个交互动作之后才出现的内容）和折叠的图片。 工具可帮你减轻工作量：YUI Image Loader可以延迟加载折叠的图片，还有YUI Get utility是一种引入JS和CSS的简单方法。Yahoo!主页就是一个例子，可以打开Firebug的网络面板仔细看看。 最好让性能目标符合其它web开发最佳实践，比如“渐进增强”。如果客户端支持JavaScript，可以提高用户体验，但必须确保页面在不支持JavaScript时也能正常工作。所以，在确定页面运行正常之后，可以用一些延迟加载脚本增强它，以支持一些拖放和动画之类的华丽效果。 预加载组件 预加载可能看起来和延迟加载是相反的，但它其实有不同的目标。通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。用户访问下一页的时候，大部分组件都已经在缓存里了，所以在用户看来页面会加载得更快。 实际应用中有以下几种预加载的类型： 无条件预加载——尽快开始加载，获取一些额外的组件。google.com就是一个sprite图片预加载的好例子，这个sprite图片并不是google.com主页需要的，而是搜索结果页面上的内容。条件性预加载——根据用户操作猜测用户将要跳转到哪里并据此预加载。在search.yahoo.com的输入框里键入内容后，可以看到那些额外组件是怎样请求加载的。提前预加载——在推出新设计之前预加载。经常在重新设计之后会听到：“这个新网站不错，但比以前更慢了”，一部分原因是用户访问先前的页面都是有旧缓存的，但新的却是一种空缓存状态下的体验。可以通过在将要推出新设计之前预加载一些组件来减轻这种负面影响，老站可以利用浏览器空闲的时间来请求那些新站需要的图片和脚本。 减少DOM元素的数量 一个复杂的页面意味着要下载更多的字节，而且用JavaScript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素和5000个DOM元素是有区别的。 大量的DOM元素是一种征兆——页面上有些内容无关的标记需要清理。正在用嵌套表格来布局吗？还是为了修复布局问题而添了一堆的s？或许应该用更好的语义化标记。 YUI CSS utilities对布局有很大帮助：grids.css针对整体布局，fonts.css和reset.css可以用来去除浏览器的默认格式。这是个开始清理和思考标记的好机会，例如只在语义上有意义的时候使用，而不是因为它能够渲染一个新行。 DOM元素的数量很容易测试，只需要在Firebug的控制台里输入： 1document.getElementsByTagName(&apos;*&apos;).length 那么多少DOM元素才算是太多呢？可以参考其它类似的标记良好的页面，例如Yahoo!主页是一个相当繁忙的页面，但只有不到700个元素（HTML标签）。 跨域分离组件 分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。例如，可以把HTML和动态内容部署在www.example.org，而把静态组件分离到static1.example.org和static2.example.org。 尽量少用iframe 用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。 &lt;iframe&gt;的优点： 引入缓慢的第三方内容，比如标志和广告安全沙箱并行下载脚本&lt;iframe&gt;的缺点： 代价高昂，即使是空白的iframe阻塞页面加载非语义 杜绝404 HTTP请求代价高昂，完全没有必要用一个HTTP请求去获取一个无用的响应（比如404 Not Found），只会拖慢用户体验而没有任何好处。 有些站点用的是有帮助的404——“你的意思是xxx？”，这样做有利于用户体验，，但也浪费了服务器资源（比如数据库等等）。最糟糕的是链接到的外部JavaScript有错误而且结果是404。首先，这种下载将阻塞并行下载。其次，浏览器会试图解析404响应体，因为它是JavaScript代码，需要找出其中可用的部分。 避免使用CSS表达式用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但从IE8起就不推荐使用了。例如，可以用CSS表达式把背景颜色设置成按小时交替的： 1background-color: expression( (new Date()).getHours()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; ); 选择舍弃@import前面提到了一个最佳实践：为了实现逐步渲染，CSS应该放在顶部。 在IE中用@import与在底部用效果一样，所以最好不要用它。 避免使用滤镜 IE专有的AlphaImageLoader滤镜可以用来修复IE7之前的版本中半透明PNG图片的问题。在图片加载过程中，这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗而且是被应用到每个元素的，而不是每个图片，所以会存在一大堆问题。 最好的方法是干脆不要用AlphaImageLoader，而优雅地降级到用在IE中支持性很好的PNG8图片来代替。如果非要用AlphaImageLoader，应该用下划线hack：_filter来避免影响IE7及更高版本的用户。 把样式表放在顶部 在Yahoo!研究性能的时候，我们发现把样式表放到文档的HEAD部分能让页面看起来加载地更快。这是因为把样式表放在head里能让页面逐步渲染。 关注性能的前端工程师想让页面逐步渲染。也就是说，我们想让浏览器尽快显示已有内容，这在页面上有一大堆内容或者用户网速很慢时显得尤为重要。给用户显示反馈（比如进度指标）的重要性已经被广泛研究过，并且被记录下来了。在我们的例子中，HTML页面就是进度指标！当浏览器逐渐加载页面头部，导航条，顶部logo等等内容的时候，这些都被正在等待页面加载的用户当作反馈，能够提高整体用户体验。 去除重复脚本 页面含有重复的脚本文件会影响性能，这可能和你想象的不一样。在对美国前10大web站点的评审中，发现只有2个站点含有重复脚本。两个主要原因增加了在单一页面中出现重复脚本的几率：团队大小和脚本数量。在这种情况下，重复脚本会创建不必要的HTTP请求，执行无用的JavaScript代码，而影响页面性能。 IE会产生不必要的HTTP请求，而Firefox不会。在IE中，如果一个不可缓存的外部脚本被页面引入了两次，它会在页面加载时产生两个HTTP请求。即使脚本是可缓存的，在用户重新加载页面时也会产生额外的HTTP请求。 除了产生没有意义的HTTP请求之外，多次对脚本求值也会浪费时间。因为无论脚本是否可缓存，在Firefox和IE中都会执行冗余的JavaScript代码。 避免不小心把相同脚本引入两次的一种方法就是在模版系统中实现脚本管理模块。典型的脚本引入方法就是在HTML页面中用SCRIPT标签：1&lt;script type=&quot;text/javascript&quot; src=&quot;menu_1.0.17.js&quot;&gt;&lt;/script&gt; 尽量减少DOM访问用JavaScript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该： 缓存已访问过的元素的索引先“离线”更新节点，再把它们添到DOM树上避免用JavaScript修复布局问题 用智能的事件处理器 有时候感觉页面反映不够灵敏，是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上，这就是推荐使用事件委托的原因。如果一个div里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮都添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。 把脚本放在底部 脚本会阻塞并行下载，HTTP/1.1官方文档建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个主机名，并行下载的数量就可以超过两个。如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同主机名下的。 有时候，并不容易把脚本移动到底部。举个例子，如果脚本是用document.write插入到页面内容中的，就没办法再往下移了。还可能存在作用域问题，在多数情况下，这些问题都是可以解决的。 一个常见的建议是用推迟（deferred）脚本，有DEFER属性的脚本意味着不能含有document.write，并且提示浏览器告诉他们可以继续渲染。不幸的是，Firefox不支持DEFER属性。在IE中，脚本可能被推迟，但不尽如人意。如果脚本可以推迟，我们就可以把它放到页面底部，页面就可以更快地载入。 把JavaScript和CSS放到外面 很多性能原则都是关于如何管理外部组件的，然而，在这些顾虑出现之前你应该问一个更基础的问题：应该把JavaScript和CSS放到外部文件中还是直接写在页面里？ 实际上，用外部文件可以让页面更快，因为JavaScript和CSS文件会被缓存在浏览器。HTML文档中的行内JavaScript和CSS在每次请求该HTML文档的时候都会重新下载。这样做减少了所需的HTTP请求数，但增加了HTML文档的大小。另一方面，如果JavaScript和CSS在外部文件中，并且已经被浏览器缓存起来了，那么我们就成功地把HTML文档变小了，而且还没有增加HTTP请求数。 压缩JavaScript和CSS 压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行和tab）。在JavaScript中这样做能够提高响应性能，因为要下载的文件变小了。两个最常用的JavaScript代码压缩工具是JSMin和YUI Compressor，YUI compressor还可以压缩CSS。 混淆是一种可选的源码优化措施，要比压缩更复杂，所以混淆过程也更容易产生bug。在对美国前十的网站调查中，压缩可以缩小21%，而混淆能缩小25%。虽然混淆的缩小程度更高，但比压缩风险更大。 除了压缩外部脚本和样式，行内的&lt;script&gt;和&lt;style&gt;块也可以压缩。即使启用了gzip模块，先进行压缩也能够缩小5%或者更多的大小。JavaScript和CSS的用处越来越多，所以压缩代码会有不错的效果。 优化图片尝试把GIF格式转换成PNG格式，看看是否节省空间。在所有的PNG图片上运行pngcrush（或者其它PNG优化工具） 优化CSS Sprite在Sprite图片中横向排列一般都比纵向排列的最终文件小组合Sprite图片中的相似颜色可以保持低色数，最理想的是256色以下PNG8格式“对移动端友好”，不要在Sprite图片中留下太大的空隙。虽然不会在很大程度上影响图片文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100×100的图片是1万个像素，而1000×1000的图片就是100万个像素了。 不要用HTML缩放图片 不要因为在HTML中可以设置宽高而使用本不需要的大图。如果需要1&lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt; 那么图片本身（mycat.jpg）应该是100x100px的，而不是去缩小500x500px的图片。 用小的可缓存的favicon.ico（P.S. 收藏夹图标） favicon.ico是放在服务器根目录的图片，它会带来一堆麻烦，因为即便你不管它，浏览器也会自动请求它，所以最好不要给一个404 Not Found响应。而且只要在同一个服务器上，每次请求它时都会发送cookie，此外这个图片还会干扰下载顺序，例如在IE中，当你在onload中请求额外组件时，将会先下载favicon。 所以为了缓解favicon.ico的缺点，应该确保： 足够小，最好在1K以下设置合适的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为几个月后一般比较安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。 给Cookie减肥 使用cookie的原因有很多，比如授权和个性化。HTTP头中cookie信息在web服务器和浏览器之间交换。重要的是保证cookie尽可能的小，以最小化对用户响应时间的影响。 清除不必要的cookie保证cookie尽可能小，以最小化对用户响应时间的影响注意给cookie设置合适的域级别，以免影响其它子域设置合适的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间 把组件放在不含cookie的域下 当浏览器发送对静态图像的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。所以它们只会造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署在那儿。 如果域名是www.example.org，可以把静态组件部署到static.example.org。然而，如果已经在顶级域example.org或者www.example.org设置了cookie，那么所有对static.example.org的请求都会含有这些cookie。这时候可以再买一个新域名，把所有的静态组件部署上去，并保持这个新域名不含cookie。Yahoo!用的是yimg.com，YouTube是ytimg.com，Amazon是images-amazon.com等等。 把静态组件部署在不含cookie的域下还有一个好处是有些代理可能会拒绝缓存带cookie的组件。有一点需要注意：如果不知道应该用example.org还是www.example.org作为主页，可以考虑一下cookie的影响。省略www的话，就只能把cookie写到*.example.org，所以因为性能原因最好用www子域，并且把cookie写到这个子域下。 保证所有组件都小于25K 这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。 把组件打包到一个复合文档里 把各个组件打包成一个像有附件的电子邮件一样的复合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。 Gzip组件 前端工程师可以想办法明显地缩短通过网络传输HTTP请求和响应的时间。毫无疑问，终端用户的带宽速度，网络服务商，对等交换点的距离等等，都是开发团队所无法控制的。但还有别的能够影响响应时间的因素，压缩可以通过减少HTTP响应的大小来缩短响应时间。 从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头。 1Accept-Encoding: gzip, deflate 如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding相应头来通知客户端。1Content-Encoding: gzip 尽可能多地用gzip压缩能够给页面减肥，这也是提升用户体验最简单的方法。 避免图片src属性为空Image with empty string src属性是空字符串的图片很常见，主要以两种形式出现：straight HTML1&lt;img src=””&gt; JavaScript 12var img = new Image();img.src = “”; 配置ETags 实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器中的组件是否匹配的一种机制（“实体”也就是组件：图片，脚本，样式表等等）。添加ETags可以提供一种实体验证机制，比最后修改日期更加灵活。一个ETag是一个字符串，作为一个组件某一具体版本的唯一标识符。唯一的格式约束是字符串必须用引号括起来，源服务器用相应头中的ETag来指定组件的ETag： 对Ajax用GET请求Yahoo!邮箱团队发现使用XMLHttpRequest时，浏览器的POST请求是通过一个两步的过程来实现的：先发送HTTP头，在发送数据。所以最好用GET请求，它只需要发送一个TCP报文（除非cookie特别多）。IE的URL长度最大值是2K，所以如果要发送的数据超过2K就无法使用GET了。 POST请求的一个有趣的副作用是实际上没有发送任何数据，就像GET请求一样。正如HTTP说明文档中描述的，GET请求是用来检索信息的。所以它的语义只是用GET请求来请求数据，而不是用来发送需要存储到服务器的数据。 尽早清空缓冲区当用户请求一个页面时，服务器需要用大约200到500毫秒来组装HTML页面，在这期间，浏览器闲等着数据到达。PHP中有一个flush()函数，允许给浏览器发送一部分已经准备完毕的HTML响应，以便浏览器可以在后台准备剩余部分的同时开始获取组件，好处主要体现在很忙的后台或者很“轻”的前端页面上（P.S. 也就是说，响应时耗主要在后台方面时最能体现优势）。 较理想的清空缓冲区的位置是HEAD后面，因为HTML的HEAD部分通常更容易生成，并且允许引入任何CSS和JavaScript文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取组件。 例如： 12345... &lt;!-- css, js --&gt; &lt;/head&gt; &lt;?php flush(); ?&gt; &lt;body&gt; ... &lt;!-- content --&gt; 使用CDN（内容分发网络） 用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。但具体要怎么做呢？ 实现内容在地理位置上分散的第一步是：不要尝试去重新设计你的web应用程序来适应分布式结构。这取决于应用程序，改变结构可能包括一些让人望而生畏的任务，比如同步会话状态和跨服务器复制数据库事务（翻译可能不准确）。缩短用户和内容之间距离的提议可能被推迟，或者根本不可能通过，就是因为这个难题。 记住终端用户80%到90%的响应时间都花在下载页面组件上了：图片，样式，脚本，Flash等等，这是业绩黄金法则。最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。 内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。 添上Expires或者Cache-Control HTTP头这条规则有两个方面： 对于静态组件：通过设置一个遥远的将来时间作为Expires来实现永不失效多余动态组件：用合适的Cache-ControlHTTP头来让浏览器进行条件性的请求 网页设计越来越丰富，这意味着页面里有更多的脚本，图片和Flash。站点的新访客可能还是不得不提交几个HTTP请求，但通过使用有效期能让组件变得可缓存，这避免了在接下来的浏览过程中不必要的HTTP请求。有效期HTTP头通常被用在图片上，但它们应该用在所有组件上，包括脚本、样式和Flash组件。 浏览器（和代理）用缓存来减少HTTP请求的数目和大小，让页面能够更快加载。web服务器通过有效期HTTP响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在2010年4月15日前不会改变。 1Expires: Thu, 15 Apr 2010 20:00:00 GMT 如果你用的是Apache服务器，用ExpiresDefault指令来设置相对于当前日期的有效期。下面的例子设置了从请求时间起10年的有效期：1ExpiresDefault &quot;access plus 10 years&quot;","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://upyang.com/tags/性能优化/"},{"name":"SEO","slug":"SEO","permalink":"http://upyang.com/tags/SEO/"}]},{"title":"原生js实现Ajax实例讲解(二)","slug":"ajax2","date":"2017-07-12T14:30:38.000Z","updated":"2017-07-16T14:43:11.553Z","comments":true,"path":"2017/07/12/ajax2/","link":"","permalink":"http://upyang.com/2017/07/12/ajax2/","excerpt":"","text":"导语Ajax的核心技术是XMLHttpRequest对象,它可以在不向服务器提交整个页面的情况下，实现局部更新网页。通过这个对象，Ajax可以像桌面应用程序那样只与服务器进行数据层的交换，而不必每次都刷新界面，也不必每次将数据处理的工作都交给服务器来做。这样既减轻了服务器负担又提高了响应速度，还缩短了用户的等待时间。通常一个Ajax的实现过程有五步，下面我们以上篇博客中的小实例为例来逐步学习。 XMLHttpRequest对象的五步使用法创建XMLHttpRequest对象。IE浏览器将XMLHttpRequest实现为一个ActiveX对象，其他浏览器如Firefox，Opera，Netscape等将其实现为一个本地JavaScript对象。1234567891011121314151617181920212223242526272829function CreatXHR() &#123; //判断浏览器是否支持ActiveX控件，针对IE6及之前版本 if (window.ActiveXObject) &#123; //将所有可能出现的ActiveXObject版本都放在一个数组中 var arrXHR = [&apos;Microsoft.XMLHTTP&apos;, &apos;MSXML2.XMLHTTP.6.0&apos;, &apos;MSXML2.XMLHTTP.5.0&apos;, &apos;MSXML2.XMLHTTP.4.0&apos;, &apos;MSXML2.XMLHTTP.3.0&apos;, &apos;MSXML2.XMLHTTP&apos;]; //通过循环创建XMLHttpRequest对象 var temp = arrXHR.length; for (var i=0;i&lt;temp;i++) &#123; try &#123; //创建XMLHttpRequest对象 xhr = new ActiveXObject(arrXHR[i]); //如果创建XMLHttpRequest对象成功，则跳出循环 break; &#125; catch(ex) &#123; &#125; &#125; &#125; //判断浏览器是否将XMLHttpRequest作为本地对象实现，针对IE7，Firefox，Opera等浏览器 else if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; &#125; 123456789101112131415//创建XMLHttpRequest对象，调用前面定义好的函数 creatXMLHTTP(); if (xhr!=null) &#123; //创建响应XMLHttpRequest对象状态变化的函数 //创建http请求 //发送http请求 &#125; else &#123; alert(&quot;您的浏览器不支持XMLHTTP&quot;); &#125; 注册回调函数12//创建响应XMLHttpRequest对象状态变化的函数 xhr.onreadystatechange = httpStateChange; 在异步调用时，XMLHttpRequest对象有几个不同的状态，这些状态表示了异步调用的过程。 0：未初始化状态，刚创建完一个XMLHttpRequest对象； 1：初始化状态，即XMLHttpRequest对象已经获得了要将数据发送到哪个服务器上、以什么方式发送等信息； 2：发送状态，XMLHttpRequest开始发送数据； 3：数据传送状态，此时XMLHttpRequest正在接受从服务器端返回的数据，但是数据还没有传送完毕； 4：完成状态：此时XMLHttpRequest对象已经将从服务器端返回的数据接受完毕。使用XMLHttpRequest对象的onreadystatechange属性，可以设置响应XMLHttpRequest对象状态变化的函数。设置回调函数时，不要在函数名后而加括号。加括号表示将回调函数的返回值注册给onreadystatechange属性。 open方法设置和服务器端交互的信息12//创建http请求 xhr.open(&quot;get&quot;,&quot;Readme.txt&quot;, true); 请求根目录下存储用户名为Readme的txt文件,稍后利用它进行用户名的验证。 XMLHttpRequest的open(method,URL,flag,name,password)方法用来初始化对象，前两个参数必选，后三个参数是可选。method：指定用什么方式向服务器发送http请求，参数值可以是get，post，head，put和delete五种。URL：指定服务器的URL，也就是用户处理和返回数据的程序的URL。该URL可以是绝对地址，也可以是相对地址。flag：指定提交http请求的方式，true指异步方式，为默认值；false指同步方式。name和password：如果服务器需要验证，这两个参数用来提交用户名和密码。 设置发送的数据与服务器端开始交互。12//发送http请求 xhr.send(null); 发送http请求使用XMLHttpRequest的send(data)方法，data参数就是传递给open()方法中URL参数所指定的文件的参数。若果要传递多个参数，用”&amp;”来分隔，不需要传递参数写”null”。 回调函数中判断交互是否结束判断异步调用是否成功：1234if (xhr.readyState==4)//异步调用完毕&#123; if (xhr.status==200 || xhr.status==0)&#123;&#125;//异步调用成功||在本机上调试&#125; readyState属性值为4，说明异步调用完成，但并不代表异步调用执行成功。XMLHttpRequest的status属性可以获得从服务器返回的状态码。0代表不能理解的http状态，通常只有在本地计算机打开文件时才会返回。比较常用的http状态码有以下三个：200：服务器成功返回网页。404：客户端请求的网页不存在。503：服务器响应超时。 获得服务器返回的数据123456if (xhr.readyState==4)&#123; if (xhr.status==200 || xhr.status==0)&#123; var Names = xhr.responseText; &#125;&#125; 异步调用的最终目的是接收从服务器返回的数据，并根据该数据决定如何显示在客户端网页中。异步调用成功后，XMLHttpRequest对象通过使用以下4个属性来获得服务器返回的数据。responseText：表示将服务器返回的数据以字符串形式返回。responseXML：表示以XML的形式返回。responseBody：表示以unsigned byte数组的形式返回。responseStream：表示以IStream对象的形式返回。 局部更新1234567891011var OWarn = document.getElementById(&quot;Warn&quot;);if (Flag)&#123; OWarn.innerHTML = &quot;您输入的用户名已存在，请重新输入！&quot;; Form.Btn.disabled = true;//提交按钮不可用&#125;else&#123; OWarn.innerHTML = &quot;合法用户名&quot;; Form.Btn.disabled = false;//提交按钮可用&#125; 获取服务器返回的数据之后就要显示出来。Ajax通过DOM来完成局部更新数据。 结束语 在ajax的编程中是必须对XMLHttpRequest进行上述的5步操作的，封装成一个具有复用性效果的方法，对我们的日常使用是非常来说是非常方便的。","categories":[],"tags":[{"name":"jsonp","slug":"jsonp","permalink":"http://upyang.com/tags/jsonp/"},{"name":"ajax","slug":"ajax","permalink":"http://upyang.com/tags/ajax/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","permalink":"http://upyang.com/tags/XMLHttpRequest/"}]},{"title":"原生js实现Ajax实例讲解(一)","slug":"ajax","date":"2017-07-12T02:02:20.000Z","updated":"2017-07-16T14:44:18.440Z","comments":true,"path":"2017/07/12/ajax/","link":"","permalink":"http://upyang.com/2017/07/12/ajax/","excerpt":"","text":"Ajax简介 ajax = 异步 JavaScript 和 XML。 ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。我们知道，传统的网页（不使用ajax）如果需要更新内容，必须重新加载整个网页。Ajax的出现，使得使网可以实现异步更新，这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 注意：ajax本身不支持跨域请求，需要在服务器端处理。 工作原理 ajax的技术核心是 XMLHttpRequest 对象。 ajax请求过程：创建XMLHttpRequest、连接服务器、发送请求、服务器做出响应、接收响应数据 图示： ajax与jsonp区别从实现方式上来讲，ajax是通过创建XMLHttpRequest来获取同源的数据。而jsonp是通过&lt;script&gt;标签来调用服务器提供的js脚本。 jsonp产生原因 1. Ajax直接请求普通文件存在跨域无权限访问的问题（静态页、动态页、web服务、wcf只要是跨域请求一律不准） 2. web的页面上调用js文件是不受跨域的影响（凡拥有src属性的标签都拥有跨域能力script img iframe） 3. 可以判断 现在想通过纯web端(ActiveX控件、服务端代理、H5之Websocket等方式不算)跨域访问数据就只有一种可能，就是在远程服务器上设法把数据装进js格式的文件里，供客户度调用和进一步处理； 4. json的纯字符数格式可以简洁的描述复杂数据还被js原生支持 5. web客户端通过与调用脚本一样的方式来调用跨域服务器上动态生成的js格式文件(后缀.json)，服务器之所以要动态生成json文件目的把客户端需要的数据装入进去 6. 客户端在对json文件调用成功后获得自己所需的数据剩下的就按照自己需求进行处理和展现，这种获取远程数据的方式非常像ajax其实并一样 7. 为了方便客户端使用数据逐渐形成非正式传输协议jsonp 其实，说到ajax就会面临两个不可避免的问题，一是以何种格式来减缓数据；二是如何解决跨域问题。目前来说，所被推崇的方案是JSON作数据交换，JSONP来解决跨域问题。 JSON与JSONP虽然看上去只有一字之差，但是实际上根本不是一回事。JSON是一种key/value形式的数据格式，二JSONP则是一种跨域数据交互协议。 实例 题目：注册时，会要求输入用户名和密码，同时要验证用户名是否合法。 实现功能，用户在输入用户名后，需要给出提醒该名称是否已经存在。 html文档结构123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Ajax实例详解&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;reg&quot; style=&quot;margin-top: 50px;margin-left:100px;&quot;&gt; &lt;p&gt;注册页(ajax检测用户名是否合法)&lt;/p&gt; &lt;form name=&quot;Form&quot;&gt; 用户名: &lt;input type=&quot;text&quot; name=&quot;Name&quot; onblur=&quot;check()&quot;&gt; &lt;span id=&quot;myDiv&quot;&gt;&lt;/span&gt;&lt;br&gt; 密 码: &lt;input type=&quot;text&quot; name=&quot;Password&quot;&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot; 提交&quot; name=&quot;Btn&quot; disabled=&quot;false&quot;&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; JavaScript代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;script type=&quot;text/javascript&quot;&gt; //初始化一个存储XMLHttpRequest对象的变量 var xhr = null; //定义一个函数用来创建XMLHttpRequest对象,兼容各个版本 function CreatXHR() &#123; //判断浏览器是否支持ActiveX控件，针对IE6及之前版本 if (window.ActiveXObject) &#123; //将所有可能出现的ActiveXObject版本都放在一个数组中 var arrXHR = [&apos;Microsoft.XMLHTTP&apos;, &apos;MSXML2.XMLHTTP.6.0&apos;, &apos;MSXML2.XMLHTTP.5.0&apos;, &apos;MSXML2.XMLHTTP.4.0&apos;, &apos;MSXML2.XMLHTTP.3.0&apos;, &apos;MSXML2.XMLHTTP&apos;]; //通过循环创建XMLHttpRequest对象 var temp = arrXHR.length; for (var i=0;i&lt;temp;i++) &#123; try &#123; //创建XMLHttpRequest对象 xhr = new ActiveXObject(arrXHR[i]); //如果创建XMLHttpRequest对象成功，则跳出循环 break; &#125; catch(ex) &#123; &#125; &#125; &#125; //判断浏览器是否将XMLHttpRequest作为本地对象实现，针对IE7，Firefox，Opera等浏览器 else if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; &#125; //响应XMLHttpRequest对象状态变化的函数 function httpStateChange() &#123; if (xhr.readyState==4)//异步调用完毕 &#123; if (xhr.status==200 || xhr.status==0)//异步调用成功，在本机上调试 &#123; //获得服务器返回的数据 var Names = xhr.responseText; var arrName = Names.split(&quot;;&quot;);//把获取到的一个字符串分割成字符串数组。 //定义一个变量，用于判断用户名是否已经存在 var Flag = false; for(i=0;i&lt;arrName.length;i++) &#123; if (arrName[i]== Form.Name.value) &#123; Flag = true;//用户名存在 break; &#125; &#125; //合法性验证提醒 var OWarn = document.getElementById(&quot;Warn&quot;); if (Flag) &#123; OWarn.innerHTML = &quot;您输入的用户名已存在，请重新输入！&quot;; Form.Btn.disabled = true;//提交按钮不可用 &#125; else &#123; OWarn.innerHTML = &quot;合法用户名&quot;; Form.Btn.disabled = false;//提交按钮可用 &#125; &#125; &#125; &#125; //校验用户名是否有效 function check() &#123; //创建XMLHttpRequest对象，调用前面定义好的函数 CreatXHR(); if (xhr!=null) &#123; //创建响应XMLHttpRequest对象状态变化的函数 xhr.onreadystatechange = httpStateChange; //创建http请求 xhr.open(&quot;get&quot;,&quot;Readme.txt&quot;, true); //发送http请求 xhr.send(null); &#125; else &#123; alert(&quot;您的浏览器不支持XMLHTTP&quot;); &#125; &#125;&lt;/script&gt; 注意 注意：需要在html同级目录下创建一个Reademe.txt文件来存储已经存在的用户名，多个用户名之间用分好隔开。 效果图 可以复制代码亲自试看下效果哦！(建议Firefox下调试)详细代码讲解请看下一章通俗易懂Ajax实例讲解(二)","categories":[],"tags":[{"name":"jsonp","slug":"jsonp","permalink":"http://upyang.com/tags/jsonp/"},{"name":"ajax","slug":"ajax","permalink":"http://upyang.com/tags/ajax/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","permalink":"http://upyang.com/tags/XMLHttpRequest/"}]},{"title":"响应式网站设计","slug":"Responsive-website","date":"2017-07-09T06:35:42.000Z","updated":"2017-07-28T03:01:53.577Z","comments":true,"path":"2017/07/09/Responsive-website/","link":"","permalink":"http://upyang.com/2017/07/09/Responsive-website/","excerpt":"","text":"响应式网站 👉 github: https://github.com/Aaron0525/Responsive-website 👉 演示地址: http://www.upyang.com/Responsive-website/ 项目介绍：&emsp;&emsp;响应式网站设计(Responsive Web design)的理念是：集中创建页面的图片排版大小，可以智能地根据用户行为以及使用的设备环境（系统平台、屏幕尺寸、屏幕定向等）进行相对应的布局。响应式布局要点： &emsp;&emsp;一、媒体查询（media query）。媒体查询是响应式网页的核心，它能检测当前设备的宽度来选用不同的CSS样式文件。在写CSS样式时，从最小的设备开始写为好。&emsp;&emsp;二、流式布局。它的特点就是百分比布局，相比采用具体尺寸的布局，百分比布局在用户缩放浏览器窗口时，不会出现内容被隐藏和出现横向滚动条。&emsp;&emsp;三、弹性图片。 要让图片自适应缩放，一般使用css将图片的宽度设置成100%，这样就能使图片在布局中保持特定的比例。但随着浏览器的缩放，当图片的实际大小超过图片本身的大小时，图片就会变的模糊。有效的解决方案，就是及时替换成一张尺寸更大的图片。响应式布局优缺点： &emsp;&emsp;优点：在不同终端、不同分辨率下有很强的适配性；只需一套代码，一定程度上节省了开发和维护的成本。缺点：兼容各种设备工作量大，效率低下；代码累赘，会出现隐藏无用的元素，加载时间加长。&emsp;&emsp;所以响应式布局不适合数据量大，操作复杂的网站，适用于博客、中小型企业网站等。","categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://upyang.com/tags/HTML5/"},{"name":"CSS3","slug":"CSS3","permalink":"http://upyang.com/tags/CSS3/"},{"name":"media","slug":"media","permalink":"http://upyang.com/tags/media/"}]},{"title":"jsonp跨域实现","slug":"jsonp跨域实现","date":"2017-07-08T10:57:30.000Z","updated":"2017-07-09T15:25:11.436Z","comments":true,"path":"2017/07/08/jsonp跨域实现/","link":"","permalink":"http://upyang.com/2017/07/08/jsonp跨域实现/","excerpt":"","text":"同源策略在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于JavaScript代码能够访问的页面内容做了很重要的限制，即JavaScript只能访问与包含它的文档在同一域下的内容。（图片来自MDN） JSONP在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上用标签引入&lt;script&gt;不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 jsonp的客户端实现 tocat服务器上有个remote.js（这里用tocat，web项目演示） alert(&quot;跨域成功&quot;); 本地index.html文件 1234567891011&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;跨域资源&lt;/title&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;/* 完成跨域 */&lt;script src=&quot;http://localhost:8080/web/js/remote.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 很明显，显示跨域成功 接下来我们在本地index.html定义callback函数 ，然后远程tomcat.js传入回调数据 123456789101112131415161718&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;跨域资源&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; /* 完成跨域 */ &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var callback = function(data) &#123; alert(&quot;跨域调用远程tomcat.js成功: &quot; + data.name); &#125; &#125; &lt;/script&gt; &lt;script src=&quot;http://localhost:8080/web/js/tomcat.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 远程服务器： tomcat.js 1callback(&#123;&quot;name&quot;:&quot;kk&quot;&#125;); 到此，跨域基本实现，但是这里有个问题，远程站点怎么知道要调用哪个callback呢？ 所以就有了jsonp的核心：服务端提供的callback是动态生成的， 本地只要动态传一个callback给服务端，服务端就知道该调用哪个了 像这样：客户端12345678910111213141516171819202122&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;跨域资源&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var callback = function(data) &#123; alert(&quot;跨域调用远程成功: &quot; + data.name); &#125; var url = &quot;http://localhost:8080/web/js/helloServlet?userid=1&amp;callback=callback&quot;; // 创建script标签，设置其属性 var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 服务端：（这里选用java解释）// 从客户端获取参数userid和callback1PrintWriter out =response.getWriter(); // 根据userid查找到的数据存储为json1out.println(callback+&quot;(&quot;+json+&quot;)&quot;); jsonp的执行全过程就是这么回事了（个人理解） 现在再来看JQuery中的实现，我们最经常用的$.ajax，似乎通透了不少，也就是这么回事 12345678910111213141516171819202122232425$(function() &#123; $.ajax(&#123; async: false, url: http, //跨域url地址 type: &quot;GET&quot;, dataType: &apos;jsonp&apos;, jsonp: &apos;jsoncallback&apos;, data: &#123; &quot;userid&quot;: &quot;1&quot; &#125;, timeout: 5000, beforeSend: function() &#123; //jsonp 方式此方法不被触发.原因可能是dataType如果指定为jsonp的话,就已经不是ajax事件了 &#125;, success: function(json) &#123; //客户端jquery预先定义好的callback函数,成功获取跨域服务器上的json数据后,会动态执行这个callback函数 &#125; error: function(xhr) &#123; //jsonp 方式此方法不被触发.原因是:dataType如果指定为jsonp的话,就已经不是ajax事件了 //请求出错处理 alert(&quot;请求出错(请检查相关度网络状况.)&quot;); &#125; &#125;); &#125;) 这里发现，$.ajax和ajax并不是一回事啊,ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;script&gt;标签来调用服务器提供的js脚本。 window.name注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。实例：假设有三个页面：http://a.com/a.html //渴望获得数据的页面http://a.com/b.html //a的兄弟页面，充当中间人角色http://b.com/data.html //不同源的数据页 http://a.com/a.html,监听iframe的onload事件，在此事件中设置这个iframe的src指向本地域的代理页面http://a.com/b.html（代理文件和应用页面在同一域下，所以可以相互通信）动态创建iframe 1234567891011121314151617181920212223242526272829&lt;script type=&quot;text/javascript&quot;&gt;var state = 0, iframe = document.createElement(&apos;iframe&apos;);// 通过iframe的src与data.html通信iframe.src = &apos;http://b.com/data.html&apos;;//监听onloadif (iframe.attachEvent) &#123; iframe.attachEvent(&apos;onload&apos;, loadfn);&#125; else &#123; iframe.onload = loadfn;var loadfn = function() &#123; if (state === 0) &#123; state = 1; iframe.contentWindow.location = &quot;http://a.com/b.html&quot;; // 设置的代理页面 &#125; else if (state === 1) &#123; var data = iframe.contentWindow.name; // 读取数据 alert(data); //弹出&apos;data.html!&apos; &#125; &#125;;&lt;/script&gt; ● http://b.com/data.html&lt;script type=&quot;text/javascript&quot;&gt; window.name = &apos;data.html&apos;;&lt;/script&gt; 这样就可以成功解决了，理一下思路，应该是这样:充当中间人的iframe想要获取到data.html的通过window.name设置的数据，只需要把这个iframe的src设为www.cnblogs.com/data.html就行了。然后a.html想要得到iframe所获取到的数据，也就是想要得到iframe的window.name的值，还必须把这个iframe的src设成跟a.html页面同一个域才行 图示： HTML5中新引进的window.postMessage方法在HTML5中新增了postMessage方法，postMessage可以实现跨文档消息传输（Cross Document Messaging），Internet Explorer 8, Firefox 3, Opera 9, Chrome 3和 Safari 4都支持postMessage。实现：发送信息的页面http://a.com/a.html12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;客户端&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; window.frames[0].postMessage(&apos;data&apos;, &apos;http://b.com/data.html&apos;); //postMessage接收两个参数，第一个数据，第二个字符串参数，指明目标窗口的源，具体看MDN &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe id=&quot;child&quot; src=&quot;http://b.com/data.html&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt;接收信息的页面http://b.com/data.html// 通过监听message事件获取数据window.addEventListener(&apos;message&apos;,function(e)&#123; var e =e||event; alert(e.data); &#125;,false); 图示： 跨域资源共享（CORS）CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。具体原理参见MDN","categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://upyang.com/tags/HTML5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://upyang.com/tags/JavaScript/"},{"name":"Jsonp","slug":"Jsonp","permalink":"http://upyang.com/tags/Jsonp/"},{"name":"CORS","slug":"CORS","permalink":"http://upyang.com/tags/CORS/"}]}]}