{"meta":{"title":"途中人的博客","subtitle":"IT技术分享！","description":null,"author":"途中人","url":"http://upyang.com"},"pages":[{"title":"关于我","date":"2017-07-08T14:18:02.000Z","updated":"2017-07-17T15:01:25.520Z","comments":true,"path":"about/index.html","permalink":"http://upyang.com/about/index.html","excerpt":"","text":"HTML个人简历 PDF个人简历 姓名： 杨钊 学历： 长江大学 本科 软件工程 Q Q： 1067896503 邮箱： 1067896503@qq.com github： https://github.com/Aaron0525 个人简介： 大四学生，求实习工作! 目前技术栈： 前端：HTML/HTML5、CSS/CSS3、JavaScript、jQuery、bootstrap、微信小程序 框架：Vue.js 后端：Java、Node.js 数据库：MySQL、mongodb、SqlServer 自动化构建工具： webpack、gulp"},{"title":"tags","date":"2017-07-07T10:02:16.000Z","updated":"2017-07-08T10:32:52.698Z","comments":false,"path":"tags/index.html","permalink":"http://upyang.com/tags/index.html","excerpt":"","text":"你好！"},{"title":"我的作品","date":"2017-07-07T10:02:57.000Z","updated":"2017-07-17T15:13:20.344Z","comments":true,"path":"categories/index.html","permalink":"http://upyang.com/categories/index.html","excerpt":"","text":"Vue2.0搭建移动端音乐APP 👉 github: https://github.com/Aaron0525/Vue-music 👉 演示地址: http://www.upyang.com/Vue-music/index.html#/recommend 项目介绍：&emsp;&emsp;这是一个用Vue.js写的移动端音乐App(SPA),使用了Vue2.0+ES6+webpack等前端热门技术。核心功能热门歌曲推荐、音乐播放、歌曲歌手搜索等。技术栈：&emsp;&emsp;MVVM框架：Vue.js（版本2.0）轻量组件化的热门前端框架。&emsp;&emsp;状态管理：Vuex。 采用集中式存储管理应用的所有组件的状态。&emsp;&emsp;前端路由：Vue Router。它是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。&emsp;&emsp;滚动插件：better-scroll。实现了页面无滚动条形式的滚动，且在此基础上实现了首页的轮播图。&emsp;&emsp;构建工具： webpack&emsp;&emsp;服务端通信：axios、jsonp。从QQ音乐抓取数据显示到页面。&emsp;&emsp;构建工具： webpack 响应式网站 👉 github: https://github.com/Aaron0525/Responsive-website 👉 演示地址: http://www.upyang.com/Responsive-website/ 项目介绍：&emsp;&emsp;响应式网站设计(Responsive Web design)的理念是：集中创建页面的图片排版大小，可以智能地根据用户行为以及使用的设备环境（系统平台、屏幕尺寸、屏幕定向等）进行相对应的布局。响应式布局要点： &emsp;&emsp;一、媒体查询（media query）。媒体查询是响应式网页的核心，它能检测当前设备的宽度来选用不同的CSS样式文件。在写CSS样式时，从最小的设备开始写为好。&emsp;&emsp;二、流式布局。它的特点就是百分比布局，相比采用具体尺寸的布局，百分比布局在用户缩放浏览器窗口时，不会出现内容被隐藏和出现横向滚动条。&emsp;&emsp;三、弹性图片。 要让图片自适应缩放，一般使用css将图片的宽度设置成100%，这样就能使图片在布局中保持特定的比例。但随着浏览器的缩放，当图片的实际大小超过图片本身的大小时，图片就会变的模糊。有效的解决方案，就是及时替换成一张尺寸更大的图片。响应式布局优缺点： &emsp;&emsp;优点：在不同终端、不同分辨率下有很强的适配性；只需一套代码，一定程度上节省了开发和维护的成本。缺点：兼容各种设备工作量大，效率低下；代码累赘，会出现隐藏无用的元素，加载时间加长。&emsp;&emsp;所以响应式布局不适合数据量大，操作复杂的网站，适用于博客、中小型企业网站等。"}],"posts":[{"title":"Vue学习","slug":"Vue学习","date":"2017-07-21T15:28:51.000Z","updated":"2017-07-23T02:52:36.451Z","comments":true,"path":"2017/07/21/Vue学习/","link":"","permalink":"http://upyang.com/2017/07/21/Vue学习/","excerpt":"","text":"前言 最近一段时间一直在学习Vue2.0的相关知识，之前只是看过相关的视频教学，但是一直没有动手去实践自己的项目，这次决定用Vue2.0去模仿一个移动端App,看了很多自己用过的App,最后决定模仿做掘金移动端App,恰好这款App也是用Vue做的。写下这篇博客，记录实践中的新的体会。 需求分析首先直观的看下掘金App的基本页面构成：","categories":[],"tags":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://upyang.com/tags/Vue2-0/"},{"name":"ES6","slug":"ES6","permalink":"http://upyang.com/tags/ES6/"}]},{"title":"原生js实现Ajax实例讲解(二)","slug":"ajax2","date":"2017-07-12T14:30:38.000Z","updated":"2017-07-16T14:43:11.553Z","comments":true,"path":"2017/07/12/ajax2/","link":"","permalink":"http://upyang.com/2017/07/12/ajax2/","excerpt":"","text":"导语Ajax的核心技术是XMLHttpRequest对象,它可以在不向服务器提交整个页面的情况下，实现局部更新网页。通过这个对象，Ajax可以像桌面应用程序那样只与服务器进行数据层的交换，而不必每次都刷新界面，也不必每次将数据处理的工作都交给服务器来做。这样既减轻了服务器负担又提高了响应速度，还缩短了用户的等待时间。通常一个Ajax的实现过程有五步，下面我们以上篇博客中的小实例为例来逐步学习。 XMLHttpRequest对象的五步使用法创建XMLHttpRequest对象。IE浏览器将XMLHttpRequest实现为一个ActiveX对象，其他浏览器如Firefox，Opera，Netscape等将其实现为一个本地JavaScript对象。1234567891011121314151617181920212223242526272829function CreatXHR() &#123; //判断浏览器是否支持ActiveX控件，针对IE6及之前版本 if (window.ActiveXObject) &#123; //将所有可能出现的ActiveXObject版本都放在一个数组中 var arrXHR = [&apos;Microsoft.XMLHTTP&apos;, &apos;MSXML2.XMLHTTP.6.0&apos;, &apos;MSXML2.XMLHTTP.5.0&apos;, &apos;MSXML2.XMLHTTP.4.0&apos;, &apos;MSXML2.XMLHTTP.3.0&apos;, &apos;MSXML2.XMLHTTP&apos;]; //通过循环创建XMLHttpRequest对象 var temp = arrXHR.length; for (var i=0;i&lt;temp;i++) &#123; try &#123; //创建XMLHttpRequest对象 xhr = new ActiveXObject(arrXHR[i]); //如果创建XMLHttpRequest对象成功，则跳出循环 break; &#125; catch(ex) &#123; &#125; &#125; &#125; //判断浏览器是否将XMLHttpRequest作为本地对象实现，针对IE7，Firefox，Opera等浏览器 else if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; &#125; 123456789101112131415//创建XMLHttpRequest对象，调用前面定义好的函数 creatXMLHTTP(); if (xhr!=null) &#123; //创建响应XMLHttpRequest对象状态变化的函数 //创建http请求 //发送http请求 &#125; else &#123; alert(&quot;您的浏览器不支持XMLHTTP&quot;); &#125; 注册回调函数12//创建响应XMLHttpRequest对象状态变化的函数 xhr.onreadystatechange = httpStateChange; 在异步调用时，XMLHttpRequest对象有几个不同的状态，这些状态表示了异步调用的过程。 0：未初始化状态，刚创建完一个XMLHttpRequest对象； 1：初始化状态，即XMLHttpRequest对象已经获得了要将数据发送到哪个服务器上、以什么方式发送等信息； 2：发送状态，XMLHttpRequest开始发送数据； 3：数据传送状态，此时XMLHttpRequest正在接受从服务器端返回的数据，但是数据还没有传送完毕； 4：完成状态：此时XMLHttpRequest对象已经将从服务器端返回的数据接受完毕。使用XMLHttpRequest对象的onreadystatechange属性，可以设置响应XMLHttpRequest对象状态变化的函数。设置回调函数时，不要在函数名后而加括号。加括号表示将回调函数的返回值注册给onreadystatechange属性。 open方法设置和服务器端交互的信息12//创建http请求 xhr.open(&quot;get&quot;,&quot;Readme.txt&quot;, true); 请求根目录下存储用户名为Readme的txt文件,稍后利用它进行用户名的验证。 XMLHttpRequest的open(method,URL,flag,name,password)方法用来初始化对象，前两个参数必选，后三个参数是可选。method：指定用什么方式向服务器发送http请求，参数值可以是get，post，head，put和delete五种。URL：指定服务器的URL，也就是用户处理和返回数据的程序的URL。该URL可以是绝对地址，也可以是相对地址。flag：指定提交http请求的方式，true指异步方式，为默认值；false指同步方式。name和password：如果服务器需要验证，这两个参数用来提交用户名和密码。 设置发送的数据与服务器端开始交互。12//发送http请求 xhr.send(null); 发送http请求使用XMLHttpRequest的send(data)方法，data参数就是传递给open()方法中URL参数所指定的文件的参数。若果要传递多个参数，用”&amp;”来分隔，不需要传递参数写”null”。 回调函数中判断交互是否结束判断异步调用是否成功：1234if (xhr.readyState==4)//异步调用完毕&#123; if (xhr.status==200 || xhr.status==0)&#123;&#125;//异步调用成功||在本机上调试&#125; readyState属性值为4，说明异步调用完成，但并不代表异步调用执行成功。XMLHttpRequest的status属性可以获得从服务器返回的状态码。0代表不能理解的http状态，通常只有在本地计算机打开文件时才会返回。比较常用的http状态码有以下三个：200：服务器成功返回网页。404：客户端请求的网页不存在。503：服务器响应超时。 获得服务器返回的数据123456if (xhr.readyState==4)&#123; if (xhr.status==200 || xhr.status==0)&#123; var Names = xhr.responseText; &#125;&#125; 异步调用的最终目的是接收从服务器返回的数据，并根据该数据决定如何显示在客户端网页中。异步调用成功后，XMLHttpRequest对象通过使用以下4个属性来获得服务器返回的数据。responseText：表示将服务器返回的数据以字符串形式返回。responseXML：表示以XML的形式返回。responseBody：表示以unsigned byte数组的形式返回。responseStream：表示以IStream对象的形式返回。 局部更新1234567891011var OWarn = document.getElementById(&quot;Warn&quot;);if (Flag)&#123; OWarn.innerHTML = &quot;您输入的用户名已存在，请重新输入！&quot;; Form.Btn.disabled = true;//提交按钮不可用&#125;else&#123; OWarn.innerHTML = &quot;合法用户名&quot;; Form.Btn.disabled = false;//提交按钮可用&#125; 获取服务器返回的数据之后就要显示出来。Ajax通过DOM来完成局部更新数据。 结束语 在ajax的编程中是必须对XMLHttpRequest进行上述的5步操作的，封装成一个具有复用性效果的方法，对我们的日常使用是非常来说是非常方便的。","categories":[],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://upyang.com/tags/ajax/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","permalink":"http://upyang.com/tags/XMLHttpRequest/"},{"name":"jsonp","slug":"jsonp","permalink":"http://upyang.com/tags/jsonp/"}]},{"title":"原生js实现Ajax实例讲解(一)","slug":"ajax","date":"2017-07-12T02:02:20.000Z","updated":"2017-07-16T14:44:18.440Z","comments":true,"path":"2017/07/12/ajax/","link":"","permalink":"http://upyang.com/2017/07/12/ajax/","excerpt":"","text":"Ajax简介 ajax = 异步 JavaScript 和 XML。 ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。我们知道，传统的网页（不使用ajax）如果需要更新内容，必须重新加载整个网页。Ajax的出现，使得使网可以实现异步更新，这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 注意：ajax本身不支持跨域请求，需要在服务器端处理。 工作原理 ajax的技术核心是 XMLHttpRequest 对象。 ajax请求过程：创建XMLHttpRequest、连接服务器、发送请求、服务器做出响应、接收响应数据 图示： ajax与jsonp区别从实现方式上来讲，ajax是通过创建XMLHttpRequest来获取同源的数据。而jsonp是通过&lt;script&gt;标签来调用服务器提供的js脚本。 jsonp产生原因 1. Ajax直接请求普通文件存在跨域无权限访问的问题（静态页、动态页、web服务、wcf只要是跨域请求一律不准） 2. web的页面上调用js文件是不受跨域的影响（凡拥有src属性的标签都拥有跨域能力script img iframe） 3. 可以判断 现在想通过纯web端(ActiveX控件、服务端代理、H5之Websocket等方式不算)跨域访问数据就只有一种可能，就是在远程服务器上设法把数据装进js格式的文件里，供客户度调用和进一步处理； 4. json的纯字符数格式可以简洁的描述复杂数据还被js原生支持 5. web客户端通过与调用脚本一样的方式来调用跨域服务器上动态生成的js格式文件(后缀.json)，服务器之所以要动态生成json文件目的把客户端需要的数据装入进去 6. 客户端在对json文件调用成功后获得自己所需的数据剩下的就按照自己需求进行处理和展现，这种获取远程数据的方式非常像ajax其实并一样 7. 为了方便客户端使用数据逐渐形成非正式传输协议jsonp 其实，说到ajax就会面临两个不可避免的问题，一是以何种格式来减缓数据；二是如何解决跨域问题。目前来说，所被推崇的方案是JSON作数据交换，JSONP来解决跨域问题。 JSON与JSONP虽然看上去只有一字之差，但是实际上根本不是一回事。JSON是一种key/value形式的数据格式，二JSONP则是一种跨域数据交互协议。 实例 题目：注册时，会要求输入用户名和密码，同时要验证用户名是否合法。 实现功能，用户在输入用户名后，需要给出提醒该名称是否已经存在。 html文档结构123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Ajax实例详解&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;reg&quot; style=&quot;margin-top: 50px;margin-left:100px;&quot;&gt; &lt;p&gt;注册页(ajax检测用户名是否合法)&lt;/p&gt; &lt;form name=&quot;Form&quot;&gt; 用户名: &lt;input type=&quot;text&quot; name=&quot;Name&quot; onblur=&quot;check()&quot;&gt; &lt;span id=&quot;myDiv&quot;&gt;&lt;/span&gt;&lt;br&gt; 密 码: &lt;input type=&quot;text&quot; name=&quot;Password&quot;&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot; 提交&quot; name=&quot;Btn&quot; disabled=&quot;false&quot;&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; JavaScript代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;script type=&quot;text/javascript&quot;&gt; //初始化一个存储XMLHttpRequest对象的变量 var xhr = null; //定义一个函数用来创建XMLHttpRequest对象,兼容各个版本 function CreatXHR() &#123; //判断浏览器是否支持ActiveX控件，针对IE6及之前版本 if (window.ActiveXObject) &#123; //将所有可能出现的ActiveXObject版本都放在一个数组中 var arrXHR = [&apos;Microsoft.XMLHTTP&apos;, &apos;MSXML2.XMLHTTP.6.0&apos;, &apos;MSXML2.XMLHTTP.5.0&apos;, &apos;MSXML2.XMLHTTP.4.0&apos;, &apos;MSXML2.XMLHTTP.3.0&apos;, &apos;MSXML2.XMLHTTP&apos;]; //通过循环创建XMLHttpRequest对象 var temp = arrXHR.length; for (var i=0;i&lt;temp;i++) &#123; try &#123; //创建XMLHttpRequest对象 xhr = new ActiveXObject(arrXHR[i]); //如果创建XMLHttpRequest对象成功，则跳出循环 break; &#125; catch(ex) &#123; &#125; &#125; &#125; //判断浏览器是否将XMLHttpRequest作为本地对象实现，针对IE7，Firefox，Opera等浏览器 else if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; &#125; //响应XMLHttpRequest对象状态变化的函数 function httpStateChange() &#123; if (xhr.readyState==4)//异步调用完毕 &#123; if (xhr.status==200 || xhr.status==0)//异步调用成功，在本机上调试 &#123; //获得服务器返回的数据 var Names = xhr.responseText; var arrName = Names.split(&quot;;&quot;);//把获取到的一个字符串分割成字符串数组。 //定义一个变量，用于判断用户名是否已经存在 var Flag = false; for(i=0;i&lt;arrName.length;i++) &#123; if (arrName[i]== Form.Name.value) &#123; Flag = true;//用户名存在 break; &#125; &#125; //合法性验证提醒 var OWarn = document.getElementById(&quot;Warn&quot;); if (Flag) &#123; OWarn.innerHTML = &quot;您输入的用户名已存在，请重新输入！&quot;; Form.Btn.disabled = true;//提交按钮不可用 &#125; else &#123; OWarn.innerHTML = &quot;合法用户名&quot;; Form.Btn.disabled = false;//提交按钮可用 &#125; &#125; &#125; &#125; //校验用户名是否有效 function check() &#123; //创建XMLHttpRequest对象，调用前面定义好的函数 CreatXHR(); if (xhr!=null) &#123; //创建响应XMLHttpRequest对象状态变化的函数 xhr.onreadystatechange = httpStateChange; //创建http请求 xhr.open(&quot;get&quot;,&quot;Readme.txt&quot;, true); //发送http请求 xhr.send(null); &#125; else &#123; alert(&quot;您的浏览器不支持XMLHTTP&quot;); &#125; &#125;&lt;/script&gt; 注意 注意：需要在html同级目录下创建一个Reademe.txt文件来存储已经存在的用户名，多个用户名之间用分好隔开。 效果图 可以复制代码亲自试看下效果哦！(建议Firefox下调试)详细代码讲解请看下一章通俗易懂Ajax实例讲解(二)","categories":[],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://upyang.com/tags/ajax/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","permalink":"http://upyang.com/tags/XMLHttpRequest/"},{"name":"jsonp","slug":"jsonp","permalink":"http://upyang.com/tags/jsonp/"}]},{"title":"jsonp跨域实现","slug":"jsonp跨域实现","date":"2017-07-08T10:57:30.000Z","updated":"2017-07-09T15:25:11.436Z","comments":true,"path":"2017/07/08/jsonp跨域实现/","link":"","permalink":"http://upyang.com/2017/07/08/jsonp跨域实现/","excerpt":"","text":"同源策略在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于JavaScript代码能够访问的页面内容做了很重要的限制，即JavaScript只能访问与包含它的文档在同一域下的内容。（图片来自MDN） JSONP在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上用标签引入&lt;script&gt;不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 jsonp的客户端实现 tocat服务器上有个remote.js（这里用tocat，web项目演示） alert(&quot;跨域成功&quot;); 本地index.html文件 1234567891011&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;跨域资源&lt;/title&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;/* 完成跨域 */&lt;script src=&quot;http://localhost:8080/web/js/remote.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 很明显，显示跨域成功 接下来我们在本地index.html定义callback函数 ，然后远程tomcat.js传入回调数据 123456789101112131415161718&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;跨域资源&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; /* 完成跨域 */ &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var callback = function(data) &#123; alert(&quot;跨域调用远程tomcat.js成功: &quot; + data.name); &#125; &#125; &lt;/script&gt; &lt;script src=&quot;http://localhost:8080/web/js/tomcat.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 远程服务器： tomcat.js 1callback(&#123;&quot;name&quot;:&quot;kk&quot;&#125;); 到此，跨域基本实现，但是这里有个问题，远程站点怎么知道要调用哪个callback呢？ 所以就有了jsonp的核心：服务端提供的callback是动态生成的， 本地只要动态传一个callback给服务端，服务端就知道该调用哪个了 像这样：客户端12345678910111213141516171819202122&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;跨域资源&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var callback = function(data) &#123; alert(&quot;跨域调用远程成功: &quot; + data.name); &#125; var url = &quot;http://localhost:8080/web/js/helloServlet?userid=1&amp;callback=callback&quot;; // 创建script标签，设置其属性 var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 服务端：（这里选用java解释）// 从客户端获取参数userid和callback1PrintWriter out =response.getWriter(); // 根据userid查找到的数据存储为json1out.println(callback+&quot;(&quot;+json+&quot;)&quot;); jsonp的执行全过程就是这么回事了（个人理解） 现在再来看JQuery中的实现，我们最经常用的$.ajax，似乎通透了不少，也就是这么回事 12345678910111213141516171819202122232425$(function() &#123; $.ajax(&#123; async: false, url: http, //跨域url地址 type: &quot;GET&quot;, dataType: &apos;jsonp&apos;, jsonp: &apos;jsoncallback&apos;, data: &#123; &quot;userid&quot;: &quot;1&quot; &#125;, timeout: 5000, beforeSend: function() &#123; //jsonp 方式此方法不被触发.原因可能是dataType如果指定为jsonp的话,就已经不是ajax事件了 &#125;, success: function(json) &#123; //客户端jquery预先定义好的callback函数,成功获取跨域服务器上的json数据后,会动态执行这个callback函数 &#125; error: function(xhr) &#123; //jsonp 方式此方法不被触发.原因是:dataType如果指定为jsonp的话,就已经不是ajax事件了 //请求出错处理 alert(&quot;请求出错(请检查相关度网络状况.)&quot;); &#125; &#125;); &#125;) 这里发现，$.ajax和ajax并不是一回事啊,ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;script&gt;标签来调用服务器提供的js脚本。 window.name注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。实例：假设有三个页面：http://a.com/a.html //渴望获得数据的页面http://a.com/b.html //a的兄弟页面，充当中间人角色http://b.com/data.html //不同源的数据页 http://a.com/a.html,监听iframe的onload事件，在此事件中设置这个iframe的src指向本地域的代理页面http://a.com/b.html（代理文件和应用页面在同一域下，所以可以相互通信）动态创建iframe 1234567891011121314151617181920212223242526272829&lt;script type=&quot;text/javascript&quot;&gt;var state = 0, iframe = document.createElement(&apos;iframe&apos;);// 通过iframe的src与data.html通信iframe.src = &apos;http://b.com/data.html&apos;;//监听onloadif (iframe.attachEvent) &#123; iframe.attachEvent(&apos;onload&apos;, loadfn);&#125; else &#123; iframe.onload = loadfn;var loadfn = function() &#123; if (state === 0) &#123; state = 1; iframe.contentWindow.location = &quot;http://a.com/b.html&quot;; // 设置的代理页面 &#125; else if (state === 1) &#123; var data = iframe.contentWindow.name; // 读取数据 alert(data); //弹出&apos;data.html!&apos; &#125; &#125;;&lt;/script&gt; ● http://b.com/data.html&lt;script type=&quot;text/javascript&quot;&gt; window.name = &apos;data.html&apos;;&lt;/script&gt; 这样就可以成功解决了，理一下思路，应该是这样:充当中间人的iframe想要获取到data.html的通过window.name设置的数据，只需要把这个iframe的src设为www.cnblogs.com/data.html就行了。然后a.html想要得到iframe所获取到的数据，也就是想要得到iframe的window.name的值，还必须把这个iframe的src设成跟a.html页面同一个域才行 图示： HTML5中新引进的window.postMessage方法在HTML5中新增了postMessage方法，postMessage可以实现跨文档消息传输（Cross Document Messaging），Internet Explorer 8, Firefox 3, Opera 9, Chrome 3和 Safari 4都支持postMessage。实现：发送信息的页面http://a.com/a.html12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;客户端&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; window.frames[0].postMessage(&apos;data&apos;, &apos;http://b.com/data.html&apos;); //postMessage接收两个参数，第一个数据，第二个字符串参数，指明目标窗口的源，具体看MDN &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe id=&quot;child&quot; src=&quot;http://b.com/data.html&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt;接收信息的页面http://b.com/data.html// 通过监听message事件获取数据window.addEventListener(&apos;message&apos;,function(e)&#123; var e =e||event; alert(e.data); &#125;,false); 图示： 跨域资源共享（CORS）CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。具体原理参见MDN","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://upyang.com/tags/JavaScript/"},{"name":"Jsonp","slug":"Jsonp","permalink":"http://upyang.com/tags/Jsonp/"},{"name":"HTML5","slug":"HTML5","permalink":"http://upyang.com/tags/HTML5/"},{"name":"CORS","slug":"CORS","permalink":"http://upyang.com/tags/CORS/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-07T08:00:29.363Z","updated":"2017-07-07T08:00:29.363Z","comments":true,"path":"2017/07/07/hello-world/","link":"","permalink":"http://upyang.com/2017/07/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}