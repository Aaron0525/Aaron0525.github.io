{"meta":{"title":"途中人的博客","subtitle":"IT技术分享！","description":null,"author":"途中人","url":"http://upyang.com"},"pages":[{"title":"tags","date":"2017-07-07T10:02:16.000Z","updated":"2017-07-08T10:32:52.698Z","comments":false,"path":"tags/index.html","permalink":"http://upyang.com/tags/index.html","excerpt":"","text":"你好！"},{"title":"关于我","date":"2017-07-08T14:18:02.000Z","updated":"2017-07-10T02:18:25.472Z","comments":true,"path":"about/index.html","permalink":"http://upyang.com/about/index.html","excerpt":"","text":"HTML个人简历 PDF个人简历 姓名： 杨钊 学历： 长江大学 本科 软件工程 Q Q： 1067896503 邮箱： 1067896503@qq.com github： https://github.com/Aaron0525 个人简介： 大四待业中！ 目前技术栈： 前端：HTML/HTML5、CSS/CSS3、JavaScript、jQuery、bootstrap、微信小程序 框架：Vue.js 后端：Node.js、Java 数据库：mongodb、MySQL、SqlServer 自动化构建工具： webpack"},{"title":"我的作品","date":"2017-07-07T10:02:57.000Z","updated":"2017-07-10T04:39:39.122Z","comments":true,"path":"categories/index.html","permalink":"http://upyang.com/categories/index.html","excerpt":"","text":"响应式网站 👉 github: https://github.com/Aaron0525/Responsive-website 👉 演示地址: http://www.upyang.com/Responsive-website/ 项目介绍：&emsp;&emsp;响应式网站设计(Responsive Web design)的理念是：集中创建页面的图片排版大小，可以智能地根据用户行为以及使用的设备环境（系统平台、屏幕尺寸、屏幕定向等）进行相对应的布局。响应式布局要点： &emsp;&emsp;一、媒体查询（media query）。媒体查询是响应式网页的核心，它能检测当前设备的宽度来选用不同的CSS样式文件。在写CSS样式时，从最小的设备开始写为好。&emsp;&emsp;二、流式布局。它的特点就是百分比布局，相比采用具体尺寸的布局，百分比布局在用户缩放浏览器窗口时，不会出现内容被隐藏和出现横向滚动条。&emsp;&emsp;三、弹性图片。 要让图片自适应缩放，一般使用css将图片的宽度设置成100%，这样就能使图片在布局中保持特定的比例。但随着浏览器的缩放，当图片的实际大小超过图片本身的大小时，图片就会变的模糊。有效的解决方案，就是及时替换成一张尺寸更大的图片。响应式布局优缺点： &emsp;&emsp;优点：在不同终端、不同分辨率下有很强的适配性；只需一套代码，一定程度上节省了开发和维护的成本。缺点：兼容各种设备工作量大，效率低下；代码累赘，会出现隐藏无用的元素，加载时间加长。&emsp;&emsp;所以响应式布局不适合数据量大，操作复杂的网站，适用于博客、中小型企业网站等。 Vue2.0搭建移动端音乐APP 👉 github: https://github.com/Aaron0525/Vue-music 👉 演示地址: http://www.upyang.com/Vue-music/index.html#/recommend 项目介绍：&emsp;&emsp;这是一个用Vue.js写的移动端音乐App(SPA),使用了Vue2.0+ES6+webpack+node等前端热门技术。核心功能热门歌曲推荐、音乐播放、歌曲歌手搜索等。技术栈：&emsp;&emsp;MVVM框架：Vue.js（版本2.0）轻量组件化的热门前端框架。&emsp;&emsp;状态管理：Vuex。 采用集中式存储管理应用的所有组件的状态。&emsp;&emsp;前端路由：Vue Router。它是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。&emsp;&emsp;服务端通信：axios、jsonp。通过axios、jsonp来获取mock的.json数据并渲染到组件中，模拟从后台获取数据。&emsp;&emsp;构建工具： webpack2.0"}],"posts":[{"title":"通俗易懂Ajax实例详解","slug":"ajax","date":"2017-07-12T02:02:20.000Z","updated":"2017-07-12T13:30:07.124Z","comments":true,"path":"2017/07/12/ajax/","link":"","permalink":"http://upyang.com/2017/07/12/ajax/","excerpt":"","text":"Ajax简介 ajax = 异步 JavaScript 和 XML。 ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。我们知道，传统的网页（不使用ajax）如果需要更新内容，必须重新加载整个网页。Ajax的出现，使得使网可以实现异步更新，这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 注意：ajax不支持跨域请求 工作原理 ajax的技术核心是 XMLHttpRequest 对象。 ajax请求过程：创建XMLHttpRequest、连接服务器、发送请求、服务器做出响应、接收响应数据 图示： ajax与jsonp区别从实现方式上来讲，ajax是通过创建XMLHttpRequest来获取同源(什么是同源，可以q去看我的另一片文章jsonp跨域实现 的数据。而jsonp是通过&lt;script&gt;标签来团挑用服务器提供的js脚本。 jsonp产生原因 1.Ajax直接请求普通文件存在跨域无权限访问的问题（静态页、动态页、web服务、wcf只要是跨域请求一律不准） 2.web的页面上调用js文件是不受跨域的影响（凡拥有src属性的标签都拥有跨域能力script img iframe） 3.可以判断 现在想通过纯web端(ActiveX控件、服务端代理、H5之Websocket等方式不算)跨域访问数据就只有一种可能，就是在远程服务器上设法把数据装进js格式的文件里，供客户度调用和进一步处理； 4.json的纯字符数格式可以简洁的描述复杂数据还被js原生支持 5.web客户端通过与调用脚本一样的方式来调用跨域服务器上动态生成的js格式文件(后缀.json)，服务器之所以要动态生成json文件目的把客户端需要的数据装入进去 6.客户端在对json文件调用成功后获得自己所需的数据剩下的就按照自己需求进行处理和展现，这种获取远程数据的方式非常像ajax其实并一样 7.为了方便客户端使用数据逐渐形成非正式传输协议jsonp 其实，说到ajax就会面临两个不可避免的问题，一是以何种格式来减缓数据；二是如何解决跨域问题。目前来说，所被推崇的方案是JSON作数据交换，JSONP来解决跨域问题。 JSON与JSONP虽然看上去只有一字之差，但是实际上根本不是一回事。JSON是一种key/value形式的数据格式，二JSONP则是一种跨域数据交互协议。 ajax实例讲解 题目：注册时，会要求输入用户名和密码，同时要验证用户名是否已经存在 实现功能，用户在输入用户名后，需要给出提醒该名称是否已经存在。 html文档结构：123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Ajax实例详解&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;reg&quot; style=&quot;margin-top: 50px;margin-left:100px;&quot;&gt; &lt;p&gt;注册页(ajax检测用户名是否合法)&lt;/p&gt; &lt;form name=&quot;Form&quot;&gt; 用户名: &lt;input type=&quot;text&quot; name=&quot;Name&quot; onblur=&quot;check()&quot;&gt; &lt;span id=&quot;myDiv&quot;&gt;&lt;/span&gt;&lt;br&gt; 密 码: &lt;input type=&quot;text&quot; name=&quot;Password&quot;&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot; 提交&quot; name=&quot;Btn&quot; disabled=&quot;false&quot;&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; JavaScript代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;script type=&quot;text/javascript&quot;&gt; //初始化一个存储XMLHttpRequest对象的变量 var xhr = null; //定义一个函数用来创建XMLHttpRequest对象,兼容各个版本 function CreatXHR() &#123; //判断浏览器是否支持ActiveX控件，针对IE6及之前版本 if (window.ActiveXObject) &#123; //将所有可能出现的ActiveXObject版本都放在一个数组中 var arrXHR = [&apos;Microsoft.XMLHTTP&apos;, &apos;MSXML2.XMLHTTP.6.0&apos;, &apos;MSXML2.XMLHTTP.5.0&apos;, &apos;MSXML2.XMLHTTP.4.0&apos;, &apos;MSXML2.XMLHTTP.3.0&apos;, &apos;MSXML2.XMLHTTP&apos;]; //通过循环创建XMLHttpRequest对象 var temp = arrXHR.length; for (var i=0;i&lt;temp;i++) &#123; try &#123; //创建XMLHttpRequest对象 xhr = new ActiveXObject(arrXHR[i]); //如果创建XMLHttpRequest对象成功，则跳出循环 break; &#125; catch(ex) &#123; &#125; &#125; &#125; //判断浏览器是否将XMLHttpRequest作为本地对象实现，针对IE7，Firefox，Opera等浏览器 else if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; &#125; //响应XMLHttpRequest对象状态变化的函数 function httpStateChange() &#123; if (xhr.readyState==4)//异步调用完毕 &#123; if (xhr.status==200 || xhr.status==0)//异步调用成功，在本机上调试 &#123; //获得服务器返回的数据 var Names = xhr.responseText; var arrName = Names.split(&quot;;&quot;);//把获取到的一个字符串分割成字符串数组。 //定义一个变量，用于判断用户名是否已经存在 var Flag = false; for(i=0;i&lt;arrName.length;i++) &#123; if (arrName[i]== Form.Name.value) &#123; Flag = true;//用户名存在 break; &#125; &#125; //合法性验证提醒 var OWarn = document.getElementById(&quot;Warn&quot;); if (Flag) &#123; OWarn.innerHTML = &quot;您输入的用户名已存在，请重新输入！&quot;; Form.Btn.disabled = true;//提交按钮不可用 &#125; else &#123; OWarn.innerHTML = &quot;合法用户名&quot;; Form.Btn.disabled = false;//提交按钮可用 &#125; &#125; &#125; &#125; //校验用户名是否有效 function check() &#123; //创建XMLHttpRequest对象，调用前面定义好的函数 CreatXHR(); if (xhr!=null) &#123; //创建响应XMLHttpRequest对象状态变化的函数 xhr.onreadystatechange = httpStateChange; //创建http请求 xhr.open(&quot;get&quot;,&quot;Readme.txt&quot;, true); //发送http请求 xhr.send(null); &#125; else &#123; alert(&quot;您的浏览器不支持XMLHTTP&quot;); &#125; &#125;&lt;/script&gt; 注意：需要在html同级目录下创建一个Reademe.text文件来存储已经存在的用户名，多个用户名之间用分好隔开。","categories":[],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://upyang.com/tags/ajax/"}]},{"title":"jsonp跨域实现","slug":"jsonp跨域实现","date":"2017-07-08T10:57:30.000Z","updated":"2017-07-09T15:25:11.436Z","comments":true,"path":"2017/07/08/jsonp跨域实现/","link":"","permalink":"http://upyang.com/2017/07/08/jsonp跨域实现/","excerpt":"","text":"同源策略在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于JavaScript代码能够访问的页面内容做了很重要的限制，即JavaScript只能访问与包含它的文档在同一域下的内容。（图片来自MDN） JSONP在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上用标签引入&lt;script&gt;不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 jsonp的客户端实现 tocat服务器上有个remote.js（这里用tocat，web项目演示） alert(&quot;跨域成功&quot;); 本地index.html文件 1234567891011&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;跨域资源&lt;/title&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;/* 完成跨域 */&lt;script src=&quot;http://localhost:8080/web/js/remote.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 很明显，显示跨域成功 接下来我们在本地index.html定义callback函数 ，然后远程tomcat.js传入回调数据 123456789101112131415161718&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;跨域资源&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; /* 完成跨域 */ &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var callback = function(data) &#123; alert(&quot;跨域调用远程tomcat.js成功: &quot; + data.name); &#125; &#125; &lt;/script&gt; &lt;script src=&quot;http://localhost:8080/web/js/tomcat.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 远程服务器： tomcat.js 1callback(&#123;&quot;name&quot;:&quot;kk&quot;&#125;); 到此，跨域基本实现，但是这里有个问题，远程站点怎么知道要调用哪个callback呢？ 所以就有了jsonp的核心：服务端提供的callback是动态生成的， 本地只要动态传一个callback给服务端，服务端就知道该调用哪个了 像这样：客户端12345678910111213141516171819202122&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;跨域资源&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var callback = function(data) &#123; alert(&quot;跨域调用远程成功: &quot; + data.name); &#125; var url = &quot;http://localhost:8080/web/js/helloServlet?userid=1&amp;callback=callback&quot;; // 创建script标签，设置其属性 var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 服务端：（这里选用java解释）// 从客户端获取参数userid和callback1PrintWriter out =response.getWriter(); // 根据userid查找到的数据存储为json1out.println(callback+&quot;(&quot;+json+&quot;)&quot;); jsonp的执行全过程就是这么回事了（个人理解） 现在再来看JQuery中的实现，我们最经常用的$.ajax，似乎通透了不少，也就是这么回事 12345678910111213141516171819202122232425$(function() &#123; $.ajax(&#123; async: false, url: http, //跨域url地址 type: &quot;GET&quot;, dataType: &apos;jsonp&apos;, jsonp: &apos;jsoncallback&apos;, data: &#123; &quot;userid&quot;: &quot;1&quot; &#125;, timeout: 5000, beforeSend: function() &#123; //jsonp 方式此方法不被触发.原因可能是dataType如果指定为jsonp的话,就已经不是ajax事件了 &#125;, success: function(json) &#123; //客户端jquery预先定义好的callback函数,成功获取跨域服务器上的json数据后,会动态执行这个callback函数 &#125; error: function(xhr) &#123; //jsonp 方式此方法不被触发.原因是:dataType如果指定为jsonp的话,就已经不是ajax事件了 //请求出错处理 alert(&quot;请求出错(请检查相关度网络状况.)&quot;); &#125; &#125;); &#125;) 这里发现，$.ajax和ajax并不是一回事啊,ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;script&gt;标签来调用服务器提供的js脚本。 window.name注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。实例：假设有三个页面：http://a.com/a.html //渴望获得数据的页面http://a.com/b.html //a的兄弟页面，充当中间人角色http://b.com/data.html //不同源的数据页 http://a.com/a.html,监听iframe的onload事件，在此事件中设置这个iframe的src指向本地域的代理页面http://a.com/b.html（代理文件和应用页面在同一域下，所以可以相互通信）动态创建iframe 1234567891011121314151617181920212223242526272829&lt;script type=&quot;text/javascript&quot;&gt;var state = 0, iframe = document.createElement(&apos;iframe&apos;);// 通过iframe的src与data.html通信iframe.src = &apos;http://b.com/data.html&apos;;//监听onloadif (iframe.attachEvent) &#123; iframe.attachEvent(&apos;onload&apos;, loadfn);&#125; else &#123; iframe.onload = loadfn;var loadfn = function() &#123; if (state === 0) &#123; state = 1; iframe.contentWindow.location = &quot;http://a.com/b.html&quot;; // 设置的代理页面 &#125; else if (state === 1) &#123; var data = iframe.contentWindow.name; // 读取数据 alert(data); //弹出&apos;data.html!&apos; &#125; &#125;;&lt;/script&gt; ● http://b.com/data.html&lt;script type=&quot;text/javascript&quot;&gt; window.name = &apos;data.html&apos;;&lt;/script&gt; 这样就可以成功解决了，理一下思路，应该是这样:充当中间人的iframe想要获取到data.html的通过window.name设置的数据，只需要把这个iframe的src设为www.cnblogs.com/data.html就行了。然后a.html想要得到iframe所获取到的数据，也就是想要得到iframe的window.name的值，还必须把这个iframe的src设成跟a.html页面同一个域才行 图示： HTML5中新引进的window.postMessage方法在HTML5中新增了postMessage方法，postMessage可以实现跨文档消息传输（Cross Document Messaging），Internet Explorer 8, Firefox 3, Opera 9, Chrome 3和 Safari 4都支持postMessage。实现：发送信息的页面http://a.com/a.html12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;客户端&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; window.frames[0].postMessage(&apos;data&apos;, &apos;http://b.com/data.html&apos;); //postMessage接收两个参数，第一个数据，第二个字符串参数，指明目标窗口的源，具体看MDN &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe id=&quot;child&quot; src=&quot;http://b.com/data.html&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt;接收信息的页面http://b.com/data.html// 通过监听message事件获取数据window.addEventListener(&apos;message&apos;,function(e)&#123; var e =e||event; alert(e.data); &#125;,false); 图示： 跨域资源共享（CORS）CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。具体原理参见MDN","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://upyang.com/tags/JavaScript/"},{"name":"Jsonp","slug":"Jsonp","permalink":"http://upyang.com/tags/Jsonp/"},{"name":"HTML5","slug":"HTML5","permalink":"http://upyang.com/tags/HTML5/"},{"name":"CORS","slug":"CORS","permalink":"http://upyang.com/tags/CORS/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-07T08:00:29.363Z","updated":"2017-07-07T08:00:29.363Z","comments":true,"path":"2017/07/07/hello-world/","link":"","permalink":"http://upyang.com/2017/07/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}