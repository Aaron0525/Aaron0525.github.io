{"meta":{"title":"途中人的博客","subtitle":"IT技术分享！","description":null,"author":"途中人","url":"http://yoursite.com"},"pages":[{"title":"我的作品","date":"2017-07-07T10:02:57.000Z","updated":"2017-07-08T13:37:43.558Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"加油"},{"title":"关于我","date":"2017-07-08T14:18:02.000Z","updated":"2017-07-09T10:32:58.185Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"HTML个人简历 PDF个人简历 姓名： 杨钊 学历： 长江大学 本科 软件工程 Q Q： 1067896503 邮箱： 1067896503@qq.com github： https://github.com/Aaron0525 个人简介： 大四待业中的前端工程师！ 目前技术栈： 前端：HTML/HTML5、CSS/CSS3、JavaScript、jQuery、bootstrap 框架：Vue.js 后端：Node.js、Java 数据库：mongodb、MySQL、SqlServer 自动化构建工具： webpack"},{"title":"tags","date":"2017-07-07T10:02:16.000Z","updated":"2017-07-08T10:32:52.698Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"你好！"}],"posts":[{"title":"jsonp跨域实现","slug":"jsonp跨域实现","date":"2017-07-08T10:57:30.000Z","updated":"2017-07-08T12:27:59.910Z","comments":true,"path":"2017/07/08/jsonp跨域实现/","link":"","permalink":"http://yoursite.com/2017/07/08/jsonp跨域实现/","excerpt":"","text":"同源策略在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于JavaScript代码能够访问的页面内容做了很重要的限制，即JavaScript只能访问与包含它的文档在同一域下的内容。（图片来自MDN） JSONP在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上用标签引入&lt;script&gt;不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 jsonp的客户端实现 tocat服务器上有个remote.js（这里用tocat，web项目演示） alert(&quot;跨域成功&quot;); 本地index.html文件 1234567891011&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;跨域资源&lt;/title&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;/* 完成跨域 */&lt;script src=&quot;http://localhost:8080/web/js/remote.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 很明显，显示跨域成功 接下来我们在本地index.html定义callback函数 ，然后远程tomcat.js传入回调数据 123456789101112131415161718&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;跨域资源&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; /* 完成跨域 */ &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var callback = function(data) &#123; alert(&quot;跨域调用远程tomcat.js成功: &quot; + data.name); &#125; &#125; &lt;/script&gt; &lt;script src=&quot;http://localhost:8080/web/js/tomcat.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 远程服务器： tomcat.js 1callback(&#123;&quot;name&quot;:&quot;kk&quot;&#125;); 到此，跨域基本实现，但是这里有个问题，远程站点怎么知道要调用哪个callback呢？ 所以就有了jsonp的核心：服务端提供的callback是动态生成的， 本地只要动态传一个callback给服务端，服务端就知道该调用哪个了 像这样：客户端12345678910111213141516171819202122&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;跨域资源&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var callback = function(data) &#123; alert(&quot;跨域调用远程成功: &quot; + data.name); &#125; var url = &quot;http://localhost:8080/web/js/helloServlet?userid=1&amp;callback=callback&quot;; // 创建script标签，设置其属性 var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 服务端：（这里选用java解释）// 从客户端获取参数userid和callback1PrintWriter out =response.getWriter(); // 根据userid查找到的数据存储为json1out.println(callback+&quot;(&quot;+json+&quot;)&quot;); jsonp的执行全过程就是这么回事了（个人理解） 现在再来看JQuery中的实现，我们最经常用的$.ajax，似乎通透了不少，也就是这么回事 12345678910111213141516171819202122232425$(function() &#123; $.ajax(&#123; async: false, url: http, //跨域url地址 type: &quot;GET&quot;, dataType: &apos;jsonp&apos;, jsonp: &apos;jsoncallback&apos;, data: &#123; &quot;userid&quot;: &quot;1&quot; &#125;, timeout: 5000, beforeSend: function() &#123; //jsonp 方式此方法不被触发.原因可能是dataType如果指定为jsonp的话,就已经不是ajax事件了 &#125;, success: function(json) &#123; //客户端jquery预先定义好的callback函数,成功获取跨域服务器上的json数据后,会动态执行这个callback函数 &#125; error: function(xhr) &#123; //jsonp 方式此方法不被触发.原因是:dataType如果指定为jsonp的话,就已经不是ajax事件了 //请求出错处理 alert(&quot;请求出错(请检查相关度网络状况.)&quot;); &#125; &#125;); &#125;) 这里发现，$.ajax和ajax并不是一回事啊,ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;script&gt;标签来调用服务器提供的js脚本。 window.name注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。实例：假设有三个页面：http://a.com/a.html //渴望获得数据的页面http://a.com/b.html //a的兄弟页面，充当中间人角色http://b.com/data.html //不同源的数据页 http://a.com/a.html,监听iframe的onload事件，在此事件中设置这个iframe的src指向本地域的代理页面http://a.com/b.html（代理文件和应用页面在同一域下，所以可以相互通信）动态创建iframe 1234567891011121314151617181920212223242526272829&lt;script type=&quot;text/javascript&quot;&gt;var state = 0, iframe = document.createElement(&apos;iframe&apos;);// 通过iframe的src与data.html通信iframe.src = &apos;http://b.com/data.html&apos;;//监听onloadif (iframe.attachEvent) &#123; iframe.attachEvent(&apos;onload&apos;, loadfn);&#125; else &#123; iframe.onload = loadfn;var loadfn = function() &#123; if (state === 0) &#123; state = 1; iframe.contentWindow.location = &quot;http://a.com/b.html&quot;; // 设置的代理页面 &#125; else if (state === 1) &#123; var data = iframe.contentWindow.name; // 读取数据 alert(data); //弹出&apos;data.html!&apos; &#125; &#125;;&lt;/script&gt; ● http://b.com/data.html&lt;script type=&quot;text/javascript&quot;&gt; window.name = &apos;data.html&apos;;&lt;/script&gt; 这样就可以成功解决了，理一下思路，应该是这样:充当中间人的iframe想要获取到data.html的通过window.name设置的数据，只需要把这个iframe的src设为www.cnblogs.com/data.html就行了。然后a.html想要得到iframe所获取到的数据，也就是想要得到iframe的window.name的值，还必须把这个iframe的src设成跟a.html页面同一个域才行 图示： HTML5中新引进的window.postMessage方法在HTML5中新增了postMessage方法，postMessage可以实现跨文档消息传输（Cross Document Messaging），Internet Explorer 8, Firefox 3, Opera 9, Chrome 3和 Safari 4都支持postMessage。实现：发送信息的页面http://a.com/a.html12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;客户端&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; window.frames[0].postMessage(&apos;data&apos;, &apos;http://b.com/data.html&apos;); //postMessage接收两个参数，第一个数据，第二个字符串参数，指明目标窗口的源，具体看MDN &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe id=&quot;child&quot; src=&quot;http://b.com/data.html&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt;接收信息的页面http://b.com/data.html// 通过监听message事件获取数据window.addEventListener(&apos;message&apos;,function(e)&#123; var e =e||event; alert(e.data); &#125;,false); 图示： 跨域资源共享（CORS）CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。具体原理参见MDN","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Jsonp","slug":"Jsonp","permalink":"http://yoursite.com/tags/Jsonp/"},{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"},{"name":"CORS","slug":"CORS","permalink":"http://yoursite.com/tags/CORS/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-07T08:00:29.363Z","updated":"2017-07-07T08:00:29.363Z","comments":true,"path":"2017/07/07/hello-world/","link":"","permalink":"http://yoursite.com/2017/07/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}