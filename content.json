{"meta":{"title":"途中人的博客","subtitle":"IT技术分享！","description":null,"author":"途中人","url":"http://upyang.com"},"pages":[{"title":"我的作品","date":"2017-07-27T06:50:04.207Z","updated":"2017-07-27T06:44:32.585Z","comments":false,"path":"categories/index.html","permalink":"http://upyang.com/categories/index.html","excerpt":"","text":"@timeline{ 详情索引@item{ 2016.10响应式理财网站以一个实际上线的金融网站为案例，学习响应式网页的制作 } @item{ 2016.11电商网站使用 HTML/CSS/JS 编写的纯前端电商网站 } @item{ 2016.12玩转 canvascanvas 众多作品 } @item{ 2017.2彩票项目（11选5）大量使用 ES6 原生语法，也是为了学习 ES6 而实战的项目 } @item{ 2017.4Vue.js 高仿饿了么外卖 APP基于 Vue.js + ES6 + webpack + Sass 等前端最新技术，高仿饿了么外卖 APP } @item{ 2017.7电影网站基于 Node.js + Express + pug + mongoDB + Bootstrap 搭建的电影网站 } }"},{"title":"关于我","date":"2017-07-08T14:18:02.000Z","updated":"2017-07-17T15:01:25.520Z","comments":true,"path":"about/index.html","permalink":"http://upyang.com/about/index.html","excerpt":"","text":"HTML个人简历 PDF个人简历 姓名： 杨钊 学历： 长江大学 本科 软件工程 Q Q： 1067896503 邮箱： 1067896503@qq.com github： https://github.com/Aaron0525 个人简介： 大四学生，求实习工作! 目前技术栈： 前端：HTML/HTML5、CSS/CSS3、JavaScript、jQuery、bootstrap、微信小程序 框架：Vue.js 后端：Java、Node.js 数据库：MySQL、mongodb、SqlServer 自动化构建工具： webpack、gulp"},{"title":"tags","date":"2017-07-07T10:02:16.000Z","updated":"2017-07-08T10:32:52.698Z","comments":false,"path":"tags/index.html","permalink":"http://upyang.com/tags/index.html","excerpt":"","text":"你好！"}],"posts":[{"title":"Vue项目上传github并预览","slug":"Vue项目上传github并预览","date":"2017-07-25T08:05:27.000Z","updated":"2017-07-26T15:14:48.353Z","comments":true,"path":"2017/07/25/Vue项目上传github并预览/","link":"","permalink":"http://upyang.com/2017/07/25/Vue项目上传github并预览/","excerpt":"","text":"前言最近在初步完成自己的掘金移动端App后，想要上传到github，并且制作一个简单的预览功能，期间遇到了一些问题，分享在此，以便查阅。 打包Vue项目当Vue项目完成后，在根目录下打开命令行，输入命令： npm run build 实际上此命令就是执行build.js文件，将项目打包成静态资源。此命令完成后，项目根目录下会多出一个dist文件夹，dist文件里面有： static文件下包括项目打包后的css、js、img、fonts(字体图标)。 项目资源无法加载点击index.html,浏览器显示该页面是空白的，打开控制台看到： 这里看到index.html文件中没有加载任何css、js文件，解决方法： 打开项目根目录 config 下的 index.js 文件，进行如下修改： 将 assetsPublicPath: ‘/‘, 改为 assetsPublicPath: ‘./‘, 保存后重新’npm run build’,在新生成的dist目录下点开index.html，这时页面结构正常显示出来了，但是页面字体图标和mock的数据无法正常加载。 字体图标无法加载页面中用background加载的图片可以正常显示，但是所有的字体图标都不能正常显示，解决方法：打开根目录下 build 中的 utils.js 文件，在控制build样式文件代码中添加 publicPath: ‘../../‘， 如下： 保存后，依旧重新’npm run build’,打开dist目录下的index.js可以看到字体图标正常显示了。这里为什么需要这样修改，可以参考https://github.com/vuejs-templates/webpack/issues/166。 Mock数据无法正常加载此项目的绝大部分页面内容是通过在跟目录下创建的data.json文件渲染到页面上的，是模拟从后端请求数据的，开发调试时用’npm run dev’命令，会借助node启动一个本地服务器，可以正常的渲染出相应的数据。而通过打包后的项目时属于静态资源的，点击index.html查看项目，是无法加载mock的数据的，浏览器也会报跨域的错误。若想正常的加载mock数据，最好的方式是讲打包后的资源丢到服务器中。 利用git命令将项目上传到github首先设置SSH key,网上的教程很多，推荐一个简书里面的两种方法上传本地文件到github,完成后在github里面新建一个一个存放项目的仓库(建议勾选上初始化)，git命令： 1、先进入项目文件夹，通过命令 git init 把这个目录变成git可以管理的仓库 git init 2、把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意思为添加文件夹下的所有文件。 git add . 3、用命令 git commit告诉Git，把文件提交到仓库。引号内为提交说明。 git commit -m ‘message’ 4、关联到远程库。 git remote add origin 你的远程库地(如：https://github.com/Aaron0525/Vue-juejin-App.git) 5、将项目所有push文件到仓库中。 git push -u origin master 第五步操作时，有时会失败，我的方法是将 u 改为 f 来提交，即输入命令git push -f origin master回到github中该项目的仓库，项目文件就提交上去了，若失败，请仔细核对步骤。 制作github在线预览效果 github制作预览是需要利用GitHub Pages的，点击项目仓库的setting,找到source,切换到master branch,点击保存。 点击GitHub Pages下面出现的网址即为预览地址，但是此时点击进去会发现没有页面效果，没关系，下面继续： 我们生成githubPages的目的就是需要生成一个gh-pages分支(正常情况下只有一个master分支)。 生成gh-pages分支步骤： 1、将远程仓库克隆到本地： git clone https://github.com/Aaron0525/Vue-juejin-App.git(项目克隆地址) 2、生成分支gh-pages并切换到此分支 cd flexSupplement （进入到你克隆仓库的本地文件夹） git checkout - -orphan gh-pages (创建分支并切换，两个横杆) 3、将本地克隆文件(文件名为github仓库名)里面除.git文件以外的其他文件全部删除，再将根目录下dist文件夹里面的内容复制到克隆文件中。 依次执行以下命令： git add . （将本地所有文件加到仓库里） git commit -m “message” （设置提交信息） git remote add origin https://github.com/Aaron0525/ Vue-juejin-App.git（本地仓库链接远程仓库） git push -u origin gh-pages （push文件到仓库中） 完成以上步骤后，回到github里面，点击上面说到的GitHub Pages下面的地址，既能预览效果，注意耐心等待一小会，跟新同步还是需要一个过程的，同样这里面还是无法显示mock的数据。 总结 github，这个星球上最流行的开源托管服务的分布式网站，作为程序员，掌握基本的github使用方法，无论是对于分享、托管自己的项目，还是查阅其他优秀的开源项目，都是十分有帮助的。 以下是我的一些项目演示： Vue2.0移动端以音乐播放器 Vue2.0模仿掘金App 响应式网站 觉得有用的，可以给个start哦！ 感谢！！！","categories":[],"tags":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://upyang.com/tags/Vue2-0/"},{"name":"github","slug":"github","permalink":"http://upyang.com/tags/github/"}]},{"title":"Vue2.0仿掘金App","slug":"Vue学习","date":"2017-07-21T15:28:51.000Z","updated":"2017-07-26T15:30:01.136Z","comments":true,"path":"2017/07/21/Vue学习/","link":"","permalink":"http://upyang.com/2017/07/21/Vue学习/","excerpt":"","text":"前言 最近一段时间一直在学习Vue2.0的相关知识，之前只是看过相关的视频教学，但是一直没有动手去实践自己的项目，这次决定用Vue2.0去模仿一个移动端App,看了很多自己用过的App,最后决定模仿做掘金移动端App,恰好这款App也是用Vue做的。写下这篇博客，记录实践中的心得体会。 需求分析首先直观的看下掘金App的基本页面构成： 通过观察分析，总结出以下几点： 首页，底部和顶部分别有tab切换，在Vue中可以通过配置嵌套路由来实现。 发现页，顶部有一个轮播图，数据要求实时跟新。因为之前有在做Vue-music时有做过一个数据实时跟新的轮播图,这里直接引用过来，后面也会具体去讲怎么实现。沸点栏，有一个左右可以滑动的新闻栏。 消息、我的信息页面基本上都是数据交互，其中我的信息里面会包含一个h5调用摄像头、相册的功能。 项目中用到的字体图标采用阿里的iconfont,一些无法搜索到的图片，用firework切图工具切出来。 项目构建这里基本的node、git的安装就不一一介绍了，网上有很多相关的教程。选用webpack、vue-cli脚手架来快速搭建我们的项目骨架。 Vue创建项目命令： Vue init webpack juejin 根据提示完成相应的项目基本信息，个人意愿选择是否使用ESlint、单元测试、端到端测试等等,建议新手不使用ESlint做代码格式检查，不然可能在写的过程中遇到非常多代码格式错误，当然选择使用的话也有好处，能很好的规范自己的代码风格。 完成项目构建后，对目录进行修改，修改完成后如下： 目录介绍 api: 存放jsonp请求轮播图数据的js文件 base: 存放项目的基础组件，例如：轮播图组件(slider)、新闻列表组件(newslist)、新闻详情listdetail)、搜索组件(search)、修改个人信息组件(modify)等. common: 存放fonts、image、js、stylus文件。 components: 存放项目的主要组件 router: 路由配置 需要注意的是，因为想要模拟从后端获取数据并绑定到组件上，而不是把数据写死在结构上，所以这里在根目录新建了一个data.json的文件，里面写好了项目需要用到的数据。package.json配置依赖 npm install node_modules文件目录下查看到以上的依赖包，说明安装成功了。注意：因为项目用到的reset重置样式文件(copy来的)是stylus格式，所以还需要在devDependencies中配置stylus和stylus-loader依赖。 文件路径配置项目中会经常引入各种文件，为了引用方便会进行以下配置，觉得没必要的可以忽略。 打开build目录下的webpack.base.conf.js文件，在resolve下进行以下配置 这样的好处是引用某个文件的时候不用每次都带上一堆的前缀。引入字体图标前面说到本项目用的是阿里iconfont字体图标库，选择好所要用到的图标之后下载到本地，将其中除了3个html演示文件以外的其他7个文件拷贝到common/fonts目录下，然后将iconfont.css文件里的内容拷贝到common/stylus/icon.styl中,首先要修改的是引用路径，其他根据需要自行修改字体图标的基本样式。 测试字体图标是否引用成功：根目录main.js下 import ‘./common/stylus/icon.styl’，然后在组件中引用一个字体图标，用浏览器查看是否引用成功。Express获取data.json数据的路由配置data.json文件数据结构如下： 接下来配置Express路由，本项目只涉及到get数据，所以只进行了简单的路由配置，Express的详细使用可以查看Express官网,打开build.js文件下的dev-server.js文件，进行以下配置： npm run dev重启服务器，浏览器访问localhost:8080/api/infor,若能看到如data.json/infor里面的数据说明已经配置成功了。 页面嵌套路由配置前面讲到本项目需要配置嵌套路由，首先看一下路由组件的目录结构：components目录下除了四个主要页面组件，还需要在home目录下新建五个子路由对应的组件。 打开router下的index文件进行如下配置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import Home from &apos;../components/home/home&apos;import Find from &apos;../components/find/find&apos;import Infor from &apos;../components/infor/infor&apos;import My from &apos;../components/my/my&apos;import Homepage from &apos;../components/home/homepage/homepage&apos;import Frontend from &apos;../components/home/frontend/frontend&apos;import Product from &apos;../components/home/product/product&apos;import Design from &apos;../components/home/design/design&apos;import Afterend from &apos;../components/home/afterend/afterend&apos;Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, redirect: &apos;./home&apos; &#125;, &#123; path: &apos;/home&apos;, component: Home, children: [ &#123; path: &apos;/&apos;, redirect: &apos;./homepage&apos; &#125;, &#123; path: &apos;/home/homepage&apos;, component: Homepage &#125;, &#123; path: &apos;/home/frontend&apos;, component: Frontend &#125;, &#123; path: &apos;/home/product&apos;, component: Product &#125;, &#123; path: &apos;/home/design&apos;, component: Design &#125;, &#123; path: &apos;/home/afterend&apos;, component: Afterend &#125; ] &#125;, &#123; path: &apos;/find&apos;, component: Find &#125;, &#123; path: &apos;/infor&apos;, component: Infor &#125;, &#123; path: &apos;/my&apos;, component: My &#125; ]&#125;) redirect: &#39;./home&#39;，redirect重定向是规定运行项目后首次显示的页面，这里定向到home首页，子路由中同样需要重定向redirect: &#39;./homepage&#39;。观察可以发现主路由首次显示的页面内容是和子路由首次显示的页面内容是一样的，那么，我们是否可以用同一个组件呢?百般尝试后没有成功，因为主路由home页面渲染出来后，内容上是包含顶部的tab切换的(也就是子路由)，所以前面说到的内容一样其实是个伪命题，那么子路由的重定向不能是home而是homepage，公用的页面内容写在homepage里面。 接下来编写主路由和子路由的tab组件 1234567891011121314151617181920212223242526272829 &lt;!-- 底部tab，顶部同理 --&gt;&lt;template&gt; &lt;div class=&quot;tab&quot;&gt; &lt;router-link tag=&quot;div&quot; class=&quot;tab-item&quot; to=&quot;/home&quot;&gt; &lt;div class=&quot;tab-link&quot;&gt; &lt;div class=&quot;ic_container&quot;&gt;&lt;i class=&quot;iconfont ic home&quot;&gt;&amp;#xe6a6;&lt;/i&gt;&lt;/div&gt; &lt;span&gt;首页&lt;/span&gt; &lt;/div&gt; &lt;/router-link&gt; &lt;router-link tag=&quot;div&quot; class=&quot;tab-item&quot; to=&quot;/find&quot;&gt; &lt;div class=&quot;tab-link&quot;&gt; &lt;div class=&quot;ic_container&quot;&gt;&lt;i class=&quot;iconfont ic find&quot;&gt;&amp;#xe669;&lt;/i&gt;&lt;/div&gt; &lt;span&gt;发现&lt;/span&gt; &lt;/div&gt; &lt;/router-link&gt; &lt;router-link tag=&quot;div&quot; class=&quot;tab-item&quot; to=&quot;/infor&quot;&gt; &lt;div class=&quot;tab-link&quot;&gt; &lt;div class=&quot;ic_container&quot;&gt;&lt;i class=&quot;iconfont ic message&quot;&gt;&amp;#xe62d;&lt;/i&gt;&lt;/div&gt; &lt;span&gt;消息&lt;/span&gt; &lt;/div&gt; &lt;/router-link&gt; &lt;router-link tag=&quot;div&quot; class=&quot;tab-item&quot; to=&quot;/my&quot;&gt; &lt;div class=&quot;tab-link&quot;&gt; &lt;div class=&quot;ic_container&quot;&gt;&lt;i class=&quot;iconfont ic my&quot;&gt;&amp;#xe705;&lt;/i&gt;&lt;/div&gt; &lt;span&gt;我的&lt;/span&gt; &lt;/div&gt; &lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; 注意：检查路由是否配置成功不仅仅要看是否能正常切换，还需要观察地址栏路径变化，是否符合逻辑。底部点击切换时，http://localhost:8080/#/[home,find,infor,my]四个地址之间切换。点击顶部路由时，http://localhost:8080/#/home/[homepage,frontend,product,design,afterend]五个地址之间切换。 发现页轮播图轮播图对于前端工程师来说十分常见，以往的轮播图数据都是写死的，不能变化，这次希望模仿出来的掘金App更加真实，所以做了一个数据可变的的轮播图。很遗憾，掘金App上的轮播图数据暂时没有想到好的办法去拿到，chrome网页版掘金切换到手机模式依旧没有轮播图数据。这里选用的是QQ音乐首页轮播图数据，究竟怎么拿到数据并显示呢？ jsonp封装安装好jsonp依赖后，需要对jsonp进行简单的封装:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import jsonp from &apos;common/js/jsonp&apos;import &#123;commonParams, options&#125; from &apos;./config&apos;import axios from &apos;axios&apos;export function getRecommend() &#123; const url = &apos;https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg&apos; const data = Object.assign(&#123;&#125;, commonParams, &#123; platform: &apos;h5&apos;, uin: 0, needNewCode: 1 &#125;) return jsonp(url, data, options)&#125;export function getDiscList() &#123; const url = &apos;/api/getDiscList&apos; const data = Object.assign(&#123;&#125;, commonParams, &#123; platform: &apos;yqq&apos;, hostUin: 0, sin: 0, ein: 29, sortId: 5, needNewCode: 0, categoryId: 10000000, rnd: Math.random(), format: &apos;json&apos; &#125;) return axios.get(url, &#123; params: data &#125;).then((res) =&gt; &#123; return Promise.resolve(res.data) &#125;)&#125;export function getSongList(disstid) &#123; const url = &apos;https://c.y.qq.com/qzone/fcg-bin/fcg_ucc_getcdinfo_byids_cp.fcg&apos; const data = Object.assign(&#123;&#125;, commonParams, &#123; disstid, type: 1, json: 1, utf8: 1, onlysong: 0, platform: &apos;yqq&apos;, hostUin: 0, needNewCode: 0 &#125;) return jsonp(url, data, options)&#125; 获取数据后渲染到组件中：12345678910111213&lt;div class=&quot;recommend&quot;&gt; &lt;div class=&quot;recommend-content&quot;&gt; &lt;div v-if=&quot;recommends.length&quot; class=&quot;slider-wrapper&quot;&gt; &lt;slider&gt; &lt;div v-for=&quot;item in recommends&quot;&gt; &lt;a :href=&quot;item.linkUrl&quot;&gt; &lt;img :src=&quot;item.picUrl&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;/slider&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; better-scroll父组件与子组件数据通信 在点击新闻列表后,会出现新闻详情页面，新闻详情页面是一个单独的子组件模板,里面的作者、图像、文章banner图、文章标题等一系列数据是需要在点击新闻列表后将数据传递过来并绑定在组件结构上的。 定义子组件：1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;transition name=&quot;move&quot;&gt; &lt;div v-show=&quot;showFlag&quot; class=&quot;listdetail&quot;&gt; &lt;div class=&quot;foot&quot;&gt; &lt;div class=&quot;like-num&quot;&gt;喜欢 &#123;&#123;list.like&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script type=&quot;text/ecmascript-6&quot;&gt; export default &#123; data() &#123; return &#123; showFlag: false &#125; &#125;, props: &#123; list: &#123; type: Object &#125; &#125;, methods: &#123; show() &#123; this.showFlag = true; &#125;, hide() &#123; this.showFlag = false; &#125; &#125; &#125;;&lt;/script&gt; 在props中定义一个变量list来接受父组件传过来的数据 父组件：引入子组件listdetail并注册 父组件中新闻列表是通过v-for在li标签上渲染出来的，点击某新闻列表传给子组件的数据也必须是对应的，添加click事件@selectlist(item)，并传入一个参数item,这个item就是该新闻列表所对应的相关数据。12345678910111213141516&lt;!-- ref 被用来给元素或子组件注册引用信息，直接指向组件实例。 list接受数据。--&gt;&lt;listdetail :list=&quot;selectedlist&quot; ref=&quot;listdetail&quot;&gt;&lt;/listdetail&gt;&lt;!--data里面定义一个中间变量selectedlist,缓存item的数据(数据为某个新闻列表而非所有数据)并将其绑定在&lt;listdetail&gt;标签上--&gt;data: &#123; return &#123; selectedlist: &#123;&#125;, &#125;&#125;&lt;!--定义selectlist函数，将数据赋值给中间变量selectedlist,并在点击时触发子组件的show()方法 --&gt;methods: &#123; selectlist(item) &#123; this.selectedlist = item; this.$refs.listdetail.show(); &#125;,&#125; 小结 子组件在props中创建一个属性，用来接受父组件传过来的数据。 父组件中注册和引用子组件。 在子组件变迁中添加子组件props中创建的属性。 点击事件触发子组件show()方法时将数据一并赋值给改属性。 父组件可以调用子组件中的方法。 Vue中transition过渡动画App很多地方会有点击后出现一个新的页面的操作，如果不做动画看起来会感觉差点什么，Vue中也提供了了过渡动画的API，官网教程：https://cn.vuejs.org/v2/guide/transitions.html。 在点击新闻列表后，会从右至左出来新闻详情页面，实现也十分简单：123456789101112131415&lt;template&gt; &lt;transition name=&quot;move&quot;&gt; &lt;div v-show=&quot;showFlag&quot; class=&quot;listdetail&quot;&gt; &lt;!-- 组件内容--&gt; &lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;style&gt; .move-enter-active, .move-leave-active &#123; transition: all 0.2s linear; &#125; .move-enter, .move-leave-active &#123; transform: translate3d(100%, 0, 0); &#125;&lt;/style&gt; h5调用摄像头 h5调用摄像头在IOS设备和安卓设备上存在很大的兼容性问题，目前也只是实现了能打开摄像头和相册，对图片进行编辑和上传功能还没有实现(正在研究中)。 移动端实现图片上传并预览，需要用到h5标签input的file属性及filereader对象；accept=”image/*” 表示接受的是图片(不限制格式），若想限制格式需要这样写capture=”camera” 直接打开摄像头，若不加会出现选择打开相机或打开相册总结模仿掘金App是对Vue2.0知识的一种实践，整个做完还是很有收获的，巩固了自己的CSS布局方面的基本功，也对Vue2.0语法的具体应用场景更加清晰。","categories":[],"tags":[{"name":"jsonp","slug":"jsonp","permalink":"http://upyang.com/tags/jsonp/"},{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://upyang.com/tags/Vue2-0/"},{"name":"ES6","slug":"ES6","permalink":"http://upyang.com/tags/ES6/"}]},{"title":"原生js实现Ajax实例讲解(二)","slug":"ajax2","date":"2017-07-12T14:30:38.000Z","updated":"2017-07-16T14:43:11.553Z","comments":true,"path":"2017/07/12/ajax2/","link":"","permalink":"http://upyang.com/2017/07/12/ajax2/","excerpt":"","text":"导语Ajax的核心技术是XMLHttpRequest对象,它可以在不向服务器提交整个页面的情况下，实现局部更新网页。通过这个对象，Ajax可以像桌面应用程序那样只与服务器进行数据层的交换，而不必每次都刷新界面，也不必每次将数据处理的工作都交给服务器来做。这样既减轻了服务器负担又提高了响应速度，还缩短了用户的等待时间。通常一个Ajax的实现过程有五步，下面我们以上篇博客中的小实例为例来逐步学习。 XMLHttpRequest对象的五步使用法创建XMLHttpRequest对象。IE浏览器将XMLHttpRequest实现为一个ActiveX对象，其他浏览器如Firefox，Opera，Netscape等将其实现为一个本地JavaScript对象。1234567891011121314151617181920212223242526272829function CreatXHR() &#123; //判断浏览器是否支持ActiveX控件，针对IE6及之前版本 if (window.ActiveXObject) &#123; //将所有可能出现的ActiveXObject版本都放在一个数组中 var arrXHR = [&apos;Microsoft.XMLHTTP&apos;, &apos;MSXML2.XMLHTTP.6.0&apos;, &apos;MSXML2.XMLHTTP.5.0&apos;, &apos;MSXML2.XMLHTTP.4.0&apos;, &apos;MSXML2.XMLHTTP.3.0&apos;, &apos;MSXML2.XMLHTTP&apos;]; //通过循环创建XMLHttpRequest对象 var temp = arrXHR.length; for (var i=0;i&lt;temp;i++) &#123; try &#123; //创建XMLHttpRequest对象 xhr = new ActiveXObject(arrXHR[i]); //如果创建XMLHttpRequest对象成功，则跳出循环 break; &#125; catch(ex) &#123; &#125; &#125; &#125; //判断浏览器是否将XMLHttpRequest作为本地对象实现，针对IE7，Firefox，Opera等浏览器 else if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; &#125; 123456789101112131415//创建XMLHttpRequest对象，调用前面定义好的函数 creatXMLHTTP(); if (xhr!=null) &#123; //创建响应XMLHttpRequest对象状态变化的函数 //创建http请求 //发送http请求 &#125; else &#123; alert(&quot;您的浏览器不支持XMLHTTP&quot;); &#125; 注册回调函数12//创建响应XMLHttpRequest对象状态变化的函数 xhr.onreadystatechange = httpStateChange; 在异步调用时，XMLHttpRequest对象有几个不同的状态，这些状态表示了异步调用的过程。 0：未初始化状态，刚创建完一个XMLHttpRequest对象； 1：初始化状态，即XMLHttpRequest对象已经获得了要将数据发送到哪个服务器上、以什么方式发送等信息； 2：发送状态，XMLHttpRequest开始发送数据； 3：数据传送状态，此时XMLHttpRequest正在接受从服务器端返回的数据，但是数据还没有传送完毕； 4：完成状态：此时XMLHttpRequest对象已经将从服务器端返回的数据接受完毕。使用XMLHttpRequest对象的onreadystatechange属性，可以设置响应XMLHttpRequest对象状态变化的函数。设置回调函数时，不要在函数名后而加括号。加括号表示将回调函数的返回值注册给onreadystatechange属性。 open方法设置和服务器端交互的信息12//创建http请求 xhr.open(&quot;get&quot;,&quot;Readme.txt&quot;, true); 请求根目录下存储用户名为Readme的txt文件,稍后利用它进行用户名的验证。 XMLHttpRequest的open(method,URL,flag,name,password)方法用来初始化对象，前两个参数必选，后三个参数是可选。method：指定用什么方式向服务器发送http请求，参数值可以是get，post，head，put和delete五种。URL：指定服务器的URL，也就是用户处理和返回数据的程序的URL。该URL可以是绝对地址，也可以是相对地址。flag：指定提交http请求的方式，true指异步方式，为默认值；false指同步方式。name和password：如果服务器需要验证，这两个参数用来提交用户名和密码。 设置发送的数据与服务器端开始交互。12//发送http请求 xhr.send(null); 发送http请求使用XMLHttpRequest的send(data)方法，data参数就是传递给open()方法中URL参数所指定的文件的参数。若果要传递多个参数，用”&amp;”来分隔，不需要传递参数写”null”。 回调函数中判断交互是否结束判断异步调用是否成功：1234if (xhr.readyState==4)//异步调用完毕&#123; if (xhr.status==200 || xhr.status==0)&#123;&#125;//异步调用成功||在本机上调试&#125; readyState属性值为4，说明异步调用完成，但并不代表异步调用执行成功。XMLHttpRequest的status属性可以获得从服务器返回的状态码。0代表不能理解的http状态，通常只有在本地计算机打开文件时才会返回。比较常用的http状态码有以下三个：200：服务器成功返回网页。404：客户端请求的网页不存在。503：服务器响应超时。 获得服务器返回的数据123456if (xhr.readyState==4)&#123; if (xhr.status==200 || xhr.status==0)&#123; var Names = xhr.responseText; &#125;&#125; 异步调用的最终目的是接收从服务器返回的数据，并根据该数据决定如何显示在客户端网页中。异步调用成功后，XMLHttpRequest对象通过使用以下4个属性来获得服务器返回的数据。responseText：表示将服务器返回的数据以字符串形式返回。responseXML：表示以XML的形式返回。responseBody：表示以unsigned byte数组的形式返回。responseStream：表示以IStream对象的形式返回。 局部更新1234567891011var OWarn = document.getElementById(&quot;Warn&quot;);if (Flag)&#123; OWarn.innerHTML = &quot;您输入的用户名已存在，请重新输入！&quot;; Form.Btn.disabled = true;//提交按钮不可用&#125;else&#123; OWarn.innerHTML = &quot;合法用户名&quot;; Form.Btn.disabled = false;//提交按钮可用&#125; 获取服务器返回的数据之后就要显示出来。Ajax通过DOM来完成局部更新数据。 结束语 在ajax的编程中是必须对XMLHttpRequest进行上述的5步操作的，封装成一个具有复用性效果的方法，对我们的日常使用是非常来说是非常方便的。","categories":[],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://upyang.com/tags/ajax/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","permalink":"http://upyang.com/tags/XMLHttpRequest/"},{"name":"jsonp","slug":"jsonp","permalink":"http://upyang.com/tags/jsonp/"}]},{"title":"原生js实现Ajax实例讲解(一)","slug":"ajax","date":"2017-07-12T02:02:20.000Z","updated":"2017-07-16T14:44:18.440Z","comments":true,"path":"2017/07/12/ajax/","link":"","permalink":"http://upyang.com/2017/07/12/ajax/","excerpt":"","text":"Ajax简介 ajax = 异步 JavaScript 和 XML。 ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。我们知道，传统的网页（不使用ajax）如果需要更新内容，必须重新加载整个网页。Ajax的出现，使得使网可以实现异步更新，这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 注意：ajax本身不支持跨域请求，需要在服务器端处理。 工作原理 ajax的技术核心是 XMLHttpRequest 对象。 ajax请求过程：创建XMLHttpRequest、连接服务器、发送请求、服务器做出响应、接收响应数据 图示： ajax与jsonp区别从实现方式上来讲，ajax是通过创建XMLHttpRequest来获取同源的数据。而jsonp是通过&lt;script&gt;标签来调用服务器提供的js脚本。 jsonp产生原因 1. Ajax直接请求普通文件存在跨域无权限访问的问题（静态页、动态页、web服务、wcf只要是跨域请求一律不准） 2. web的页面上调用js文件是不受跨域的影响（凡拥有src属性的标签都拥有跨域能力script img iframe） 3. 可以判断 现在想通过纯web端(ActiveX控件、服务端代理、H5之Websocket等方式不算)跨域访问数据就只有一种可能，就是在远程服务器上设法把数据装进js格式的文件里，供客户度调用和进一步处理； 4. json的纯字符数格式可以简洁的描述复杂数据还被js原生支持 5. web客户端通过与调用脚本一样的方式来调用跨域服务器上动态生成的js格式文件(后缀.json)，服务器之所以要动态生成json文件目的把客户端需要的数据装入进去 6. 客户端在对json文件调用成功后获得自己所需的数据剩下的就按照自己需求进行处理和展现，这种获取远程数据的方式非常像ajax其实并一样 7. 为了方便客户端使用数据逐渐形成非正式传输协议jsonp 其实，说到ajax就会面临两个不可避免的问题，一是以何种格式来减缓数据；二是如何解决跨域问题。目前来说，所被推崇的方案是JSON作数据交换，JSONP来解决跨域问题。 JSON与JSONP虽然看上去只有一字之差，但是实际上根本不是一回事。JSON是一种key/value形式的数据格式，二JSONP则是一种跨域数据交互协议。 实例 题目：注册时，会要求输入用户名和密码，同时要验证用户名是否合法。 实现功能，用户在输入用户名后，需要给出提醒该名称是否已经存在。 html文档结构123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Ajax实例详解&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;reg&quot; style=&quot;margin-top: 50px;margin-left:100px;&quot;&gt; &lt;p&gt;注册页(ajax检测用户名是否合法)&lt;/p&gt; &lt;form name=&quot;Form&quot;&gt; 用户名: &lt;input type=&quot;text&quot; name=&quot;Name&quot; onblur=&quot;check()&quot;&gt; &lt;span id=&quot;myDiv&quot;&gt;&lt;/span&gt;&lt;br&gt; 密 码: &lt;input type=&quot;text&quot; name=&quot;Password&quot;&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot; 提交&quot; name=&quot;Btn&quot; disabled=&quot;false&quot;&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; JavaScript代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;script type=&quot;text/javascript&quot;&gt; //初始化一个存储XMLHttpRequest对象的变量 var xhr = null; //定义一个函数用来创建XMLHttpRequest对象,兼容各个版本 function CreatXHR() &#123; //判断浏览器是否支持ActiveX控件，针对IE6及之前版本 if (window.ActiveXObject) &#123; //将所有可能出现的ActiveXObject版本都放在一个数组中 var arrXHR = [&apos;Microsoft.XMLHTTP&apos;, &apos;MSXML2.XMLHTTP.6.0&apos;, &apos;MSXML2.XMLHTTP.5.0&apos;, &apos;MSXML2.XMLHTTP.4.0&apos;, &apos;MSXML2.XMLHTTP.3.0&apos;, &apos;MSXML2.XMLHTTP&apos;]; //通过循环创建XMLHttpRequest对象 var temp = arrXHR.length; for (var i=0;i&lt;temp;i++) &#123; try &#123; //创建XMLHttpRequest对象 xhr = new ActiveXObject(arrXHR[i]); //如果创建XMLHttpRequest对象成功，则跳出循环 break; &#125; catch(ex) &#123; &#125; &#125; &#125; //判断浏览器是否将XMLHttpRequest作为本地对象实现，针对IE7，Firefox，Opera等浏览器 else if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; &#125; //响应XMLHttpRequest对象状态变化的函数 function httpStateChange() &#123; if (xhr.readyState==4)//异步调用完毕 &#123; if (xhr.status==200 || xhr.status==0)//异步调用成功，在本机上调试 &#123; //获得服务器返回的数据 var Names = xhr.responseText; var arrName = Names.split(&quot;;&quot;);//把获取到的一个字符串分割成字符串数组。 //定义一个变量，用于判断用户名是否已经存在 var Flag = false; for(i=0;i&lt;arrName.length;i++) &#123; if (arrName[i]== Form.Name.value) &#123; Flag = true;//用户名存在 break; &#125; &#125; //合法性验证提醒 var OWarn = document.getElementById(&quot;Warn&quot;); if (Flag) &#123; OWarn.innerHTML = &quot;您输入的用户名已存在，请重新输入！&quot;; Form.Btn.disabled = true;//提交按钮不可用 &#125; else &#123; OWarn.innerHTML = &quot;合法用户名&quot;; Form.Btn.disabled = false;//提交按钮可用 &#125; &#125; &#125; &#125; //校验用户名是否有效 function check() &#123; //创建XMLHttpRequest对象，调用前面定义好的函数 CreatXHR(); if (xhr!=null) &#123; //创建响应XMLHttpRequest对象状态变化的函数 xhr.onreadystatechange = httpStateChange; //创建http请求 xhr.open(&quot;get&quot;,&quot;Readme.txt&quot;, true); //发送http请求 xhr.send(null); &#125; else &#123; alert(&quot;您的浏览器不支持XMLHTTP&quot;); &#125; &#125;&lt;/script&gt; 注意 注意：需要在html同级目录下创建一个Reademe.txt文件来存储已经存在的用户名，多个用户名之间用分好隔开。 效果图 可以复制代码亲自试看下效果哦！(建议Firefox下调试)详细代码讲解请看下一章通俗易懂Ajax实例讲解(二)","categories":[],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://upyang.com/tags/ajax/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","permalink":"http://upyang.com/tags/XMLHttpRequest/"},{"name":"jsonp","slug":"jsonp","permalink":"http://upyang.com/tags/jsonp/"}]},{"title":"jsonp跨域实现","slug":"jsonp跨域实现","date":"2017-07-08T10:57:30.000Z","updated":"2017-07-09T15:25:11.436Z","comments":true,"path":"2017/07/08/jsonp跨域实现/","link":"","permalink":"http://upyang.com/2017/07/08/jsonp跨域实现/","excerpt":"","text":"同源策略在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于JavaScript代码能够访问的页面内容做了很重要的限制，即JavaScript只能访问与包含它的文档在同一域下的内容。（图片来自MDN） JSONP在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上用标签引入&lt;script&gt;不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 jsonp的客户端实现 tocat服务器上有个remote.js（这里用tocat，web项目演示） alert(&quot;跨域成功&quot;); 本地index.html文件 1234567891011&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;跨域资源&lt;/title&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt;/* 完成跨域 */&lt;script src=&quot;http://localhost:8080/web/js/remote.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 很明显，显示跨域成功 接下来我们在本地index.html定义callback函数 ，然后远程tomcat.js传入回调数据 123456789101112131415161718&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;跨域资源&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; /* 完成跨域 */ &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var callback = function(data) &#123; alert(&quot;跨域调用远程tomcat.js成功: &quot; + data.name); &#125; &#125; &lt;/script&gt; &lt;script src=&quot;http://localhost:8080/web/js/tomcat.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 远程服务器： tomcat.js 1callback(&#123;&quot;name&quot;:&quot;kk&quot;&#125;); 到此，跨域基本实现，但是这里有个问题，远程站点怎么知道要调用哪个callback呢？ 所以就有了jsonp的核心：服务端提供的callback是动态生成的， 本地只要动态传一个callback给服务端，服务端就知道该调用哪个了 像这样：客户端12345678910111213141516171819202122&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;跨域资源&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; var callback = function(data) &#123; alert(&quot;跨域调用远程成功: &quot; + data.name); &#125; var url = &quot;http://localhost:8080/web/js/helloServlet?userid=1&amp;callback=callback&quot;; // 创建script标签，设置其属性 var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 服务端：（这里选用java解释）// 从客户端获取参数userid和callback1PrintWriter out =response.getWriter(); // 根据userid查找到的数据存储为json1out.println(callback+&quot;(&quot;+json+&quot;)&quot;); jsonp的执行全过程就是这么回事了（个人理解） 现在再来看JQuery中的实现，我们最经常用的$.ajax，似乎通透了不少，也就是这么回事 12345678910111213141516171819202122232425$(function() &#123; $.ajax(&#123; async: false, url: http, //跨域url地址 type: &quot;GET&quot;, dataType: &apos;jsonp&apos;, jsonp: &apos;jsoncallback&apos;, data: &#123; &quot;userid&quot;: &quot;1&quot; &#125;, timeout: 5000, beforeSend: function() &#123; //jsonp 方式此方法不被触发.原因可能是dataType如果指定为jsonp的话,就已经不是ajax事件了 &#125;, success: function(json) &#123; //客户端jquery预先定义好的callback函数,成功获取跨域服务器上的json数据后,会动态执行这个callback函数 &#125; error: function(xhr) &#123; //jsonp 方式此方法不被触发.原因是:dataType如果指定为jsonp的话,就已经不是ajax事件了 //请求出错处理 alert(&quot;请求出错(请检查相关度网络状况.)&quot;); &#125; &#125;); &#125;) 这里发现，$.ajax和ajax并不是一回事啊,ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;script&gt;标签来调用服务器提供的js脚本。 window.name注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。实例：假设有三个页面：http://a.com/a.html //渴望获得数据的页面http://a.com/b.html //a的兄弟页面，充当中间人角色http://b.com/data.html //不同源的数据页 http://a.com/a.html,监听iframe的onload事件，在此事件中设置这个iframe的src指向本地域的代理页面http://a.com/b.html（代理文件和应用页面在同一域下，所以可以相互通信）动态创建iframe 1234567891011121314151617181920212223242526272829&lt;script type=&quot;text/javascript&quot;&gt;var state = 0, iframe = document.createElement(&apos;iframe&apos;);// 通过iframe的src与data.html通信iframe.src = &apos;http://b.com/data.html&apos;;//监听onloadif (iframe.attachEvent) &#123; iframe.attachEvent(&apos;onload&apos;, loadfn);&#125; else &#123; iframe.onload = loadfn;var loadfn = function() &#123; if (state === 0) &#123; state = 1; iframe.contentWindow.location = &quot;http://a.com/b.html&quot;; // 设置的代理页面 &#125; else if (state === 1) &#123; var data = iframe.contentWindow.name; // 读取数据 alert(data); //弹出&apos;data.html!&apos; &#125; &#125;;&lt;/script&gt; ● http://b.com/data.html&lt;script type=&quot;text/javascript&quot;&gt; window.name = &apos;data.html&apos;;&lt;/script&gt; 这样就可以成功解决了，理一下思路，应该是这样:充当中间人的iframe想要获取到data.html的通过window.name设置的数据，只需要把这个iframe的src设为www.cnblogs.com/data.html就行了。然后a.html想要得到iframe所获取到的数据，也就是想要得到iframe的window.name的值，还必须把这个iframe的src设成跟a.html页面同一个域才行 图示： HTML5中新引进的window.postMessage方法在HTML5中新增了postMessage方法，postMessage可以实现跨文档消息传输（Cross Document Messaging），Internet Explorer 8, Firefox 3, Opera 9, Chrome 3和 Safari 4都支持postMessage。实现：发送信息的页面http://a.com/a.html12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;客户端&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; window.frames[0].postMessage(&apos;data&apos;, &apos;http://b.com/data.html&apos;); //postMessage接收两个参数，第一个数据，第二个字符串参数，指明目标窗口的源，具体看MDN &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe id=&quot;child&quot; src=&quot;http://b.com/data.html&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt;接收信息的页面http://b.com/data.html// 通过监听message事件获取数据window.addEventListener(&apos;message&apos;,function(e)&#123; var e =e||event; alert(e.data); &#125;,false); 图示： 跨域资源共享（CORS）CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。具体原理参见MDN","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://upyang.com/tags/JavaScript/"},{"name":"Jsonp","slug":"Jsonp","permalink":"http://upyang.com/tags/Jsonp/"},{"name":"HTML5","slug":"HTML5","permalink":"http://upyang.com/tags/HTML5/"},{"name":"CORS","slug":"CORS","permalink":"http://upyang.com/tags/CORS/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-07T08:00:29.363Z","updated":"2017-07-07T08:00:29.363Z","comments":true,"path":"2017/07/07/hello-world/","link":"","permalink":"http://upyang.com/2017/07/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}